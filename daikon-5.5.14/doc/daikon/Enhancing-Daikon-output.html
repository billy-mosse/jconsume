<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head><link rel="icon" href="../daikon-favicon.png" type="image/png"/>
<title>The Daikon Invariant Detector User Manual: Enhancing Daikon output</title>

<meta name="description" content="The Daikon Invariant Detector User Manual: Enhancing Daikon output">
<meta name="keywords" content="The Daikon Invariant Detector User Manual: Enhancing Daikon output">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="General-Index.html#General-Index" rel="index" title="General Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="index.html#Top" rel="up" title="Top">
<link href="Front-ends-_0028instrumentation_0029.html#Front-ends-_0028instrumentation_0029" rel="next" title="Front ends (instrumentation)">
<link href="Daikon-output.html#Invariant-filters" rel="previous" title="Invariant filters">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Enhancing-Daikon-output"></a>
<div class="header">
<p>
Next: <a href="Front-ends-_0028instrumentation_0029.html#Front-ends-_0028instrumentation_0029" accesskey="n" rel="next">Front ends (instrumentation)</a>, Previous: <a href="Daikon-output.html#Daikon-output" accesskey="p" rel="previous">Daikon output</a>, Up: <a href="index.html#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Enhancing-Daikon-output-1"></a>
<h2 class="chapter">6 Enhancing Daikon output</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Configuration-options" accesskey="1">Configuration options</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Conditional-invariants" accesskey="2">Conditional invariants</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Enhancing-conditional-invariant-detection" accesskey="3">Enhancing conditional invariant detection</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Dynamic-abstract-type-inference-_0028DynComp_0029" accesskey="4">Dynamic abstract type inference (DynComp)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Loop-invariants" accesskey="5">Loop invariants</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Configuration-options"></a>
<div class="header">
<p>
Next: <a href="#Conditional-invariants" accesskey="n" rel="next">Conditional invariants</a>, Up: <a href="#Enhancing-Daikon-output" accesskey="u" rel="up">Enhancing Daikon output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Configuration-options-1"></a>
<h3 class="section">6.1 Configuration options</h3>

<a name="index-configuration-options"></a>
<a name="index-dkconfig_005f-variables"></a>

<p>Many aspects of Daikon&rsquo;s behavior can be controlled by setting various
configuration parameters.  These configuration parameters control which
invariants are checked and reported, the statistical tests for
invariants, which derived variables are created, and more.
</p>
<p>There are two ways to set configuration options.  You can
specify a configuration setting directly on the command line,
using the <samp>--config_option <var>name</var>=<var>value</var></samp> option (which you
may repeat as many times as you want).
Or, you can create a configuration file and
supplying it to Daikon on the command line using the <samp>--config
<var>filename</var></samp> option.  Daikon applies all the command-line arguments
in order.  You may wish to use the supplied
example configuration file
<samp>daikon/java/daikon/config/example-settings.txt</samp> as an example when
creating your own configuration files.  (If you did not download
Daikon&rsquo;s sources, you must extract the example from
<samp>daikon.jar</samp> to read it.)
</p>
<p>You can also control Daikon&rsquo;s output via its command-line options
(see <a href="Running-Daikon.html#Running-Daikon">Running Daikon</a>) and via the command-line options to its front
ends &mdash; such as DynComp (see <a href="Front-ends-_0028instrumentation_0029.html#DynComp-for-Java-options">DynComp for Java options</a>),
Chicory (see <a href="Front-ends-_0028instrumentation_0029.html#Chicory-options">Chicory options</a>) or Kvasir (see <a href="Front-ends-_0028instrumentation_0029.html#Kvasir-options">Kvasir options</a>).
</p>
<p>The configuration options are different from the debugging flags
<samp>--debug</samp> and <samp>--dbg <var>category</var></samp>
(see <a href="Running-Daikon.html#Daikon-debugging-options">Daikon debugging options</a>).
The debugging flags permit Daikon to produce debugging
output, but they do not affect the invariants that Daikon computes.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#List-of-configuration-options" accesskey="1">List of configuration options</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="List-of-configuration-options"></a>
<div class="header">
<p>
Up: <a href="#Configuration-options" accesskey="u" rel="up">Configuration options</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="List-of-configuration-options-1"></a>
<h4 class="subsection">6.1.1 List of configuration options</h4>

<p>This is a list of all Daikon configuration options.
The configuration option name contains the
Java class in which it is defined.  (In the Daikon source code, the
configuration value is stored in a variable whose name contains a
<code>dkconfig_</code> prefix, but that should be irrelevant to users.)
To learn more about a specific invariant or derived variable than
appears in this manual, see its source code.
</p>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Options-to-enable_002fdisable-filters" accesskey="1">Options to enable/disable filters</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Options-to-enable_002fdisable-specific-invariants" accesskey="2">Options to enable/disable specific invariants</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Other-invariant-configuration-parameters" accesskey="3">Other invariant configuration parameters</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Options-to-enable_002fdisable-derived-variables" accesskey="4">Options to enable/disable derived variables</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Simplify-interface-configuration-options" accesskey="5">Simplify interface configuration options</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Splitter-options" accesskey="6">Splitter options</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Debugging-options" accesskey="7">Debugging options</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#General-configuration-options" accesskey="8">General configuration options</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Options-to-enable_002fdisable-filters"></a>
<div class="header">
<p>
Next: <a href="#Options-to-enable_002fdisable-specific-invariants" accesskey="n" rel="next">Options to enable/disable specific invariants</a>, Previous: <a href="#List-of-configuration-options" accesskey="p" rel="previous">List of configuration options</a>, Up: <a href="#List-of-configuration-options" accesskey="u" rel="up">List of configuration options</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Options-to-enable_002fdisable-filters-1"></a>
<h4 class="subsubsection">6.1.1.1 Options to enable/disable filters</h4>

<a name="index-filters_002c-enabling_002fdisabling"></a>
<p>These configuration options enable or disable filters that suppress printing of certain invariants.  Invariants are filtered if they are found to be true but are considered uninteresting or redundant.  See <a href="Daikon-output.html#Invariant-filters">Invariant filters</a>, for more information.
</p>
<dl compact="compact">
<dt><samp>daikon.inv.filter.DerivedParameterFilter.enabled</samp></dt>
<dd><p>Boolean. If true, DerivedParameterFilter is initially turned on.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.filter.ObviousFilter.enabled</samp></dt>
<dd><p>Boolean. If true, ObviousFilter is initially turned on.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.filter.OnlyConstantVariablesFilter.enabled</samp></dt>
<dd><p>Boolean. If true, OnlyConstantVariablesFilter is initially turned on.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.filter.ParentFilter.enabled</samp></dt>
<dd><p>Boolean. If true, ParentFilter is initially turned on.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.filter.ReadonlyPrestateFilter.enabled</samp></dt>
<dd><p>Boolean. If true, ReadonlyPrestateFilter is initially turned on.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.filter.SimplifyFilter.enabled</samp></dt>
<dd><p>Boolean. If true, SimplifyFilter is initially turned on.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.filter.StringFilter.enabled</samp></dt>
<dd><p>Boolean. If true, StringFilter is initially turned on.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.filter.UnjustifiedFilter.enabled</samp></dt>
<dd><p>Boolean. If true, UnjustifiedFilter is initially turned on.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.filter.UnmodifiedVariableEqualityFilter.enabled</samp></dt>
<dd><p>Boolean. If true, UnmodifiedVariableEqualityFilter is initially turned on.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
</dl>

<hr>
<a name="Options-to-enable_002fdisable-specific-invariants"></a>
<div class="header">
<p>
Next: <a href="#Other-invariant-configuration-parameters" accesskey="n" rel="next">Other invariant configuration parameters</a>, Previous: <a href="#Options-to-enable_002fdisable-filters" accesskey="p" rel="previous">Options to enable/disable filters</a>, Up: <a href="#List-of-configuration-options" accesskey="u" rel="up">List of configuration options</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Options-to-enable_002fdisable-specific-invariants-1"></a>
<h4 class="subsubsection">6.1.1.2 Options to enable/disable specific invariants</h4>

<a name="index-invariants_002c-enabling_002fdisabling"></a>
<p>These options control whether Daikon looks for specific kinds of invariants.  See <a href="Daikon-output.html#Invariant-list">Invariant list</a>, for more information about the corresponding invariants.
</p>
<dl compact="compact">
<dt><samp>daikon.inv.binary.sequenceScalar.Member.enabled</samp></dt>
<dd><p>Boolean. True iff Member invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.sequenceScalar.MemberFloat.enabled</samp></dt>
<dd><p>Boolean. True iff Member invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.sequenceScalar.SeqFloatEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqFloatEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.sequenceScalar.SeqFloatGreaterEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqFloatGreaterEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.sequenceScalar.SeqFloatGreaterThan.enabled</samp></dt>
<dd><p>Boolean. True iff SeqFloatGreaterThan invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.sequenceScalar.SeqFloatLessEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqFloatLessEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.sequenceScalar.SeqFloatLessThan.enabled</samp></dt>
<dd><p>Boolean. True iff SeqFloatLessThan invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.sequenceScalar.SeqIntEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqIntEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.sequenceScalar.SeqIntGreaterEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqIntGreaterEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.sequenceScalar.SeqIntGreaterThan.enabled</samp></dt>
<dd><p>Boolean. True iff SeqIntGreaterThan invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.sequenceScalar.SeqIntLessEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqIntLessEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.sequenceScalar.SeqIntLessThan.enabled</samp></dt>
<dd><p>Boolean. True iff SeqIntLessThan invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.sequenceString.MemberString.enabled</samp></dt>
<dd><p>Boolean. True iff Member invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.FloatEqual.enabled</samp></dt>
<dd><p>Boolean. True iff FloatEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.FloatGreaterEqual.enabled</samp></dt>
<dd><p>Boolean. True iff FloatGreaterEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.FloatGreaterThan.enabled</samp></dt>
<dd><p>Boolean. True iff FloatGreaterThan invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.FloatLessEqual.enabled</samp></dt>
<dd><p>Boolean. True iff FloatLessEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.FloatLessThan.enabled</samp></dt>
<dd><p>Boolean. True iff FloatLessThan invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.FloatNonEqual.enabled</samp></dt>
<dd><p>Boolean. True iff FloatNonEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.IntEqual.enabled</samp></dt>
<dd><p>Boolean. True iff IntEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.IntGreaterEqual.enabled</samp></dt>
<dd><p>Boolean. True iff IntGreaterEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.IntGreaterThan.enabled</samp></dt>
<dd><p>Boolean. True iff IntGreaterThan invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.IntLessEqual.enabled</samp></dt>
<dd><p>Boolean. True iff IntLessEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.IntLessThan.enabled</samp></dt>
<dd><p>Boolean. True iff IntLessThan invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.IntNonEqual.enabled</samp></dt>
<dd><p>Boolean. True iff IntNonEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.LinearBinary.enabled</samp></dt>
<dd><p>Boolean. True iff LinearBinary invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.LinearBinaryFloat.enabled</samp></dt>
<dd><p>Boolean. True iff LinearBinary invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.NumericFloat.Divides.enabled</samp></dt>
<dd><p>Boolean. True iff divides invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.NumericFloat.Square.enabled</samp></dt>
<dd><p>Boolean. True iff square invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.NumericFloat.ZeroTrack.enabled</samp></dt>
<dd><p>Boolean. True iff zero-track invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.NumericInt.BitwiseAndZero.enabled</samp></dt>
<dd><p>Boolean. True iff BitwiseAndZero invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.NumericInt.BitwiseComplement.enabled</samp></dt>
<dd><p>Boolean. True iff bitwise complement invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.NumericInt.BitwiseSubset.enabled</samp></dt>
<dd><p>Boolean. True iff bitwise subset invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.NumericInt.Divides.enabled</samp></dt>
<dd><p>Boolean. True iff divides invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.NumericInt.ShiftZero.enabled</samp></dt>
<dd><p>Boolean. True iff ShiftZero invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.NumericInt.Square.enabled</samp></dt>
<dd><p>Boolean. True iff square invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.NumericInt.ZeroTrack.enabled</samp></dt>
<dd><p>Boolean. True iff zero-track invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseFloatEqual.enabled</samp></dt>
<dd><p>Boolean. True iff PairwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseFloatGreaterEqual.enabled</samp></dt>
<dd><p>Boolean. True iff PairwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseFloatGreaterThan.enabled</samp></dt>
<dd><p>Boolean. True iff PairwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseFloatLessEqual.enabled</samp></dt>
<dd><p>Boolean. True iff PairwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseFloatLessThan.enabled</samp></dt>
<dd><p>Boolean. True iff PairwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseIntEqual.enabled</samp></dt>
<dd><p>Boolean. True iff PairwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseIntGreaterEqual.enabled</samp></dt>
<dd><p>Boolean. True iff PairwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseIntGreaterThan.enabled</samp></dt>
<dd><p>Boolean. True iff PairwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseIntLessEqual.enabled</samp></dt>
<dd><p>Boolean. True iff PairwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseIntLessThan.enabled</samp></dt>
<dd><p>Boolean. True iff PairwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseLinearBinary.enabled</samp></dt>
<dd><p>Boolean. True iff PairwiseLinearBinary invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseLinearBinaryFloat.enabled</samp></dt>
<dd><p>Boolean. True iff PairwiseLinearBinary invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseNumericFloat.Divides.enabled</samp></dt>
<dd><p>Boolean. True iff divides invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseNumericFloat.Square.enabled</samp></dt>
<dd><p>Boolean. True iff square invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseNumericFloat.ZeroTrack.enabled</samp></dt>
<dd><p>Boolean. True iff zero-track invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseNumericInt.BitwiseAndZero.enabled</samp></dt>
<dd><p>Boolean. True iff BitwiseAndZero invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseNumericInt.BitwiseComplement.enabled</samp></dt>
<dd><p>Boolean. True iff bitwise complement invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseNumericInt.BitwiseSubset.enabled</samp></dt>
<dd><p>Boolean. True iff bitwise subset invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseNumericInt.Divides.enabled</samp></dt>
<dd><p>Boolean. True iff divides invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseNumericInt.ShiftZero.enabled</samp></dt>
<dd><p>Boolean. True iff ShiftZero invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseNumericInt.Square.enabled</samp></dt>
<dd><p>Boolean. True iff square invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseNumericInt.ZeroTrack.enabled</samp></dt>
<dd><p>Boolean. True iff zero-track invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseString.SubString.enabled</samp></dt>
<dd><p>Boolean. True iff SubString invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseStringEqual.enabled</samp></dt>
<dd><p>Boolean. True iff PairwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseStringGreaterEqual.enabled</samp></dt>
<dd><p>Boolean. True iff PairwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseStringGreaterThan.enabled</samp></dt>
<dd><p>Boolean. True iff PairwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseStringLessEqual.enabled</samp></dt>
<dd><p>Boolean. True iff PairwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.PairwiseStringLessThan.enabled</samp></dt>
<dd><p>Boolean. True iff PairwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.Reverse.enabled</samp></dt>
<dd><p>Boolean. True iff Reverse invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.ReverseFloat.enabled</samp></dt>
<dd><p>Boolean. True iff Reverse invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SeqSeqFloatEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqSeqFloatEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SeqSeqFloatGreaterEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqSeqFloatGreaterEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SeqSeqFloatGreaterThan.enabled</samp></dt>
<dd><p>Boolean. True iff SeqSeqFloatGreaterThan invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SeqSeqFloatLessEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqSeqFloatLessEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SeqSeqFloatLessThan.enabled</samp></dt>
<dd><p>Boolean. True iff SeqSeqFloatLessThan invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SeqSeqIntEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqSeqIntEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SeqSeqIntGreaterEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqSeqIntGreaterEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SeqSeqIntGreaterThan.enabled</samp></dt>
<dd><p>Boolean. True iff SeqSeqIntGreaterThan invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SeqSeqIntLessEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqSeqIntLessEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SeqSeqIntLessThan.enabled</samp></dt>
<dd><p>Boolean. True iff SeqSeqIntLessThan invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SeqSeqStringEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqSeqStringEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SeqSeqStringGreaterEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqSeqStringGreaterEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SeqSeqStringGreaterThan.enabled</samp></dt>
<dd><p>Boolean. True iff SeqSeqStringGreaterThan invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SeqSeqStringLessEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqSeqStringLessEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SeqSeqStringLessThan.enabled</samp></dt>
<dd><p>Boolean. True iff SeqSeqStringLessThan invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SubSequence.enabled</samp></dt>
<dd><p>Boolean. True iff SubSequence invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SubSequenceFloat.enabled</samp></dt>
<dd><p>Boolean. True iff SubSequence invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SubSet.enabled</samp></dt>
<dd><p>Boolean. True iff SubSet invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SubSetFloat.enabled</samp></dt>
<dd><p>Boolean. True iff SubSet invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SuperSequence.enabled</samp></dt>
<dd><p>Boolean. True iff SubSequence invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SuperSequenceFloat.enabled</samp></dt>
<dd><p>Boolean. True iff SubSequence invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SuperSet.enabled</samp></dt>
<dd><p>Boolean. True iff SubSet invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoSequence.SuperSetFloat.enabled</samp></dt>
<dd><p>Boolean. True iff SubSet invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoString.StdString.SubString.enabled</samp></dt>
<dd><p>Boolean. True iff SubString invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoString.StringEqual.enabled</samp></dt>
<dd><p>Boolean. True iff StringEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoString.StringGreaterEqual.enabled</samp></dt>
<dd><p>Boolean. True iff StringGreaterEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoString.StringGreaterThan.enabled</samp></dt>
<dd><p>Boolean. True iff StringGreaterThan invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoString.StringLessEqual.enabled</samp></dt>
<dd><p>Boolean. True iff StringLessEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoString.StringLessThan.enabled</samp></dt>
<dd><p>Boolean. True iff StringLessThan invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoString.StringNonEqual.enabled</samp></dt>
<dd><p>Boolean. True iff StringNonEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.ternary.threeScalar.FunctionBinary.enabled</samp></dt>
<dd><p>Boolean. True if FunctionBinary invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.ternary.threeScalar.FunctionBinaryFloat.enabled</samp></dt>
<dd><p>Boolean. True if FunctionBinaryFloat invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.ternary.threeScalar.LinearTernary.enabled</samp></dt>
<dd><p>Boolean. True iff LinearTernary invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.ternary.threeScalar.LinearTernaryFloat.enabled</samp></dt>
<dd><p>Boolean. True iff LinearTernary invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.CompleteOneOfScalar.enabled</samp></dt>
<dd><p>Boolean. True iff CompleteOneOfScalar invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.IsPointer.enabled</samp></dt>
<dd><p>Boolean. True iff IsPointer invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.LowerBound.enabled</samp></dt>
<dd><p>Boolean. True iff LowerBound invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.LowerBoundFloat.enabled</samp></dt>
<dd><p>Boolean. True iff LowerBoundFloat invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.Modulus.enabled</samp></dt>
<dd><p>Boolean. True iff Modulus invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.NonModulus.enabled</samp></dt>
<dd><p>Boolean. True iff NonModulus invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.NonZero.enabled</samp></dt>
<dd><p>Boolean. True iff NonZero invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.NonZeroFloat.enabled</samp></dt>
<dd><p>Boolean. True iff NonZeroFloat invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.OneOfFloat.enabled</samp></dt>
<dd><p>Boolean. True iff OneOf invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.OneOfScalar.enabled</samp></dt>
<dd><p>Boolean. True iff OneOf invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.Positive.enabled</samp></dt>
<dd><p>Boolean. True iff Positive invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.RangeInt.Even.enabled</samp></dt>
<dd><p>Boolean. True if Even invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.RangeInt.PowerOfTwo.enabled</samp></dt>
<dd><p>Boolean. True if PowerOfTwo invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.UpperBound.enabled</samp></dt>
<dd><p>Boolean. True iff UpperBound invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.UpperBoundFloat.enabled</samp></dt>
<dd><p>Boolean. True iff UpperBoundFloat invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.CommonFloatSequence.enabled</samp></dt>
<dd><p>Boolean. True iff CommonSequence invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.CommonSequence.enabled</samp></dt>
<dd><p>Boolean. True iff CommonSequence invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltLowerBound.enabled</samp></dt>
<dd><p>Boolean. True iff EltLowerBound invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltLowerBoundFloat.enabled</samp></dt>
<dd><p>Boolean. True iff EltLowerBoundFloat invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltNonZero.enabled</samp></dt>
<dd><p>Boolean. True iff EltNonZero invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltNonZeroFloat.enabled</samp></dt>
<dd><p>Boolean. True iff EltNonZero invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltOneOf.enabled</samp></dt>
<dd><p>Boolean. True iff OneOf invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltOneOfFloat.enabled</samp></dt>
<dd><p>Boolean. True iff OneOf invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltRangeInt.Even.enabled</samp></dt>
<dd><p>Boolean. True if Even invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltRangeInt.PowerOfTwo.enabled</samp></dt>
<dd><p>Boolean. True if PowerOfTwo invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltUpperBound.enabled</samp></dt>
<dd><p>Boolean. True iff EltUpperBound invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltUpperBoundFloat.enabled</samp></dt>
<dd><p>Boolean. True iff EltUpperBoundFloat invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltwiseFloatEqual.enabled</samp></dt>
<dd><p>Boolean. True iff EltwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltwiseFloatGreaterEqual.enabled</samp></dt>
<dd><p>Boolean. True iff EltwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltwiseFloatGreaterThan.enabled</samp></dt>
<dd><p>Boolean. True iff EltwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltwiseFloatLessEqual.enabled</samp></dt>
<dd><p>Boolean. True iff EltwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltwiseFloatLessThan.enabled</samp></dt>
<dd><p>Boolean. True iff EltwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltwiseIntEqual.enabled</samp></dt>
<dd><p>Boolean. True iff EltwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltwiseIntGreaterEqual.enabled</samp></dt>
<dd><p>Boolean. True iff EltwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltwiseIntGreaterThan.enabled</samp></dt>
<dd><p>Boolean. True iff EltwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltwiseIntLessEqual.enabled</samp></dt>
<dd><p>Boolean. True iff EltwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltwiseIntLessThan.enabled</samp></dt>
<dd><p>Boolean. True iff EltwiseIntComparison invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.NoDuplicates.enabled</samp></dt>
<dd><p>Boolean. True iff NoDuplicates invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.NoDuplicatesFloat.enabled</samp></dt>
<dd><p>Boolean. True iff NoDuplicates invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.OneOfFloatSequence.enabled</samp></dt>
<dd><p>Boolean. True iff OneOf invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.OneOfSequence.enabled</samp></dt>
<dd><p>Boolean. True iff OneOf invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.SeqIndexFloatEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqIndexFloatEqual invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.SeqIndexFloatGreaterEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqIndexFloatGreaterEqual invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.SeqIndexFloatGreaterThan.enabled</samp></dt>
<dd><p>Boolean. True iff SeqIndexFloatGreaterThan invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.SeqIndexFloatLessEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqIndexFloatLessEqual invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.SeqIndexFloatLessThan.enabled</samp></dt>
<dd><p>Boolean. True iff SeqIndexFloatLessThan invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.SeqIndexFloatNonEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqIndexFloatNonEqual invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.SeqIndexIntEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqIndexIntEqual invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.SeqIndexIntGreaterEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqIndexIntGreaterEqual invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.SeqIndexIntGreaterThan.enabled</samp></dt>
<dd><p>Boolean. True iff SeqIndexIntGreaterThan invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.SeqIndexIntLessEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqIndexIntLessEqual invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.SeqIndexIntLessThan.enabled</samp></dt>
<dd><p>Boolean. True iff SeqIndexIntLessThan invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.SeqIndexIntNonEqual.enabled</samp></dt>
<dd><p>Boolean. True iff SeqIndexIntNonEqual invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.string.CompleteOneOfString.enabled</samp></dt>
<dd><p>Boolean. True iff PrintableString invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.string.OneOfString.enabled</samp></dt>
<dd><p>Boolean. True iff OneOf invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.string.PrintableString.enabled</samp></dt>
<dd><p>Boolean. True iff PrintableString invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.stringsequence.CommonStringSequence.enabled</samp></dt>
<dd><p>Boolean. True iff CommonStringSequence invariants should be considered.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.stringsequence.EltOneOfString.enabled</samp></dt>
<dd><p>Boolean. True iff OneOf invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.stringsequence.OneOfStringSequence.enabled</samp></dt>
<dd><p>Boolean. True iff OneOf invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
</dl>

<hr>
<a name="Other-invariant-configuration-parameters"></a>
<div class="header">
<p>
Next: <a href="#Options-to-enable_002fdisable-derived-variables" accesskey="n" rel="next">Options to enable/disable derived variables</a>, Previous: <a href="#Options-to-enable_002fdisable-specific-invariants" accesskey="p" rel="previous">Options to enable/disable specific invariants</a>, Up: <a href="#List-of-configuration-options" accesskey="u" rel="up">List of configuration options</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Other-invariant-configuration-parameters-1"></a>
<h4 class="subsubsection">6.1.1.3 Other invariant configuration parameters</h4>

<a name="index-invariants_002c-configuring"></a>
<p>The configuration options listed in this section parameterize the behavior of certain invariants.  See <a href="Daikon-output.html#Invariant-list">Invariant list</a>, for more information about the invariants.
</p>
<dl compact="compact">
<dt><samp>daikon.inv.Invariant.confidence_limit</samp></dt>
<dd><p>Floating-point number between 0 and 1. Invariants are displayed only if the confidence that the
invariant did not occur by chance is greater than this. (May also be set via the
<code>--conf_limit</code> command-line option to Daikon; refer to manual.)
The default value is &lsquo;0.99&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.Invariant.fuzzy_ratio</samp></dt>
<dd><p>Floating-point number between 0 and 0.1, representing the maximum relative difference between
two floats for fuzzy comparisons. Larger values will result in floats that are relatively
farther apart being treated as equal. A value of 0 essentially disables fuzzy comparisons.
Specifically, if <code>abs(1 - f1/f2)</code> is less than or equal to this value, then the two
doubles (<code>f1</code> and <code>f2</code>) will be treated as equal by Daikon.
The default value is &lsquo;1.0E-4&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.Invariant.simplify_define_predicates</samp></dt>
<dd><p>A boolean value. If true, Daikon&rsquo;s Simplify output (printed when the <code>--format simplify</code>
flag is enabled, and used internally by <code>--suppress_redundant</code>) will include new
predicates representing some complex relationships in invariants, such as lexical ordering
among sequences. If false, some complex relationships will appear in the output as complex
quantified formulas, while others will not appear at all. When enabled, Simplify may be able to
make more inferences, allowing <code>--suppress_redundant</code> to suppress more redundant
invariants, but Simplify may also run more slowly.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.binary.twoScalar.IntNonEqual.integral_only</samp></dt>
<dd><p>Boolean. True iff IntNonEqual invariants should be considered.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.filter.DerivedVariableFilter.class_re</samp></dt>
<dd><p>Regular expression to match against the class name of derived variables. Invariants that
contain derived variables that match will be filtered out. If null, nothing will be filtered
out.
The default value is &lsquo;null&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.LowerBound.maximal_interesting</samp></dt>
<dd><p>Long integer. Together with the corresponding <code>minimal_interesting</code> parameter,
specifies the range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range that should
be reported. For instance, setting <code>minimal_interesting</code> to -1 and
<code>maximal_interesting</code> to 2 would only permit output of LowerBound invariants whose
cutoff was one of (-1,0,1,2).
The default value is &lsquo;2&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.LowerBound.minimal_interesting</samp></dt>
<dd><p>Long integer. Together with the corresponding <code>maximal_interesting</code> parameter,
specifies the range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range that should
be reported. For instance, setting <code>minimal_interesting</code> to -1 and
<code>maximal_interesting</code> to 2 would only permit output of LowerBound invariants whose
cutoff was one of (-1,0,1,2).
The default value is &lsquo;-1&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.LowerBoundFloat.maximal_interesting</samp></dt>
<dd><p>Long integer. Together with the corresponding <code>minimal_interesting</code> parameter,
specifies the range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range that should
be reported. For instance, setting <code>minimal_interesting</code> to -1 and
<code>maximal_interesting</code> to 2 would only permit output of LowerBoundFloat invariants whose
cutoff was one of (-1,0,1,2).
The default value is &lsquo;2&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.LowerBoundFloat.minimal_interesting</samp></dt>
<dd><p>Long integer. Together with the corresponding <code>maximal_interesting</code> parameter,
specifies the range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range that should
be reported. For instance, setting <code>minimal_interesting</code> to -1 and
<code>maximal_interesting</code> to 2 would only permit output of LowerBoundFloat invariants whose
cutoff was one of (-1,0,1,2).
The default value is &lsquo;-1&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.OneOfFloat.size</samp></dt>
<dd><p>Positive integer. Specifies the maximum set size for this type of invariant (x is one of
<code>size</code> items).
The default value is &lsquo;3&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.OneOfScalar.omit_hashcode_values_Simplify</samp></dt>
<dd><p>Boolean. If true, invariants describing hashcode-typed variables as having any particular value
will have an artificial value substituted for the exact hashhode values. The artificial values
will stay the same from run to run even if the actual hashcode values change (as long as the
OneOf invariants remain the same). If false, hashcodes will be formatted as the application of
a hashcode uninterpreted function to an integer representing the bit pattern of the hashcode.
One might wish to omit the exact values of the hashcodes because they are usually
uninteresting; this is the same reason they print in the native Daikon format, for instance, as
<code>var has only one value</code> rather than <code>var == 150924732</code>.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.OneOfScalar.size</samp></dt>
<dd><p>Positive integer. Specifies the maximum set size for this type of invariant (x is one of
<code>size</code> items).
The default value is &lsquo;3&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.UpperBound.maximal_interesting</samp></dt>
<dd><p>Long integer. Together with the corresponding <code>minimal_interesting</code> parameter,
specifies the range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range that should
be reported. For instance, setting <code>minimal_interesting</code> to -1 and
<code>maximal_interesting</code> to 2 would only permit output of UpperBound invariants whose
cutoff was one of (-1,0,1,2).
The default value is &lsquo;2&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.UpperBound.minimal_interesting</samp></dt>
<dd><p>Long integer. Together with the corresponding <code>maximal_interesting</code> parameter,
specifies the range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range that should
be reported. For instance, setting <code>minimal_interesting</code> to -1 and
<code>maximal_interesting</code> to 2 would only permit output of UpperBound invariants whose
cutoff was one of (-1,0,1,2).
The default value is &lsquo;-1&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.UpperBoundFloat.maximal_interesting</samp></dt>
<dd><p>Long integer. Together with the corresponding <code>minimal_interesting</code> parameter,
specifies the range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range that should
be reported. For instance, setting <code>minimal_interesting</code> to -1 and
<code>maximal_interesting</code> to 2 would only permit output of UpperBoundFloat invariants whose
cutoff was one of (-1,0,1,2).
The default value is &lsquo;2&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.scalar.UpperBoundFloat.minimal_interesting</samp></dt>
<dd><p>Long integer. Together with the corresponding <code>maximal_interesting</code> parameter,
specifies the range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range that should
be reported. For instance, setting <code>minimal_interesting</code> to -1 and
<code>maximal_interesting</code> to 2 would only permit output of UpperBoundFloat invariants whose
cutoff was one of (-1,0,1,2).
The default value is &lsquo;-1&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.CommonFloatSequence.hashcode_seqs</samp></dt>
<dd><p>Boolean. Set to true to consider common sequences over hashcodes (pointers).
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.CommonSequence.hashcode_seqs</samp></dt>
<dd><p>Boolean. Set to true to consider common sequences over hashcodes (pointers).
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltLowerBound.maximal_interesting</samp></dt>
<dd><p>Long integer. Together with the corresponding <code>minimal_interesting</code> parameter,
specifies the range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range that should
be reported. For instance, setting <code>minimal_interesting</code> to -1 and
<code>maximal_interesting</code> to 2 would only permit output of EltLowerBound invariants whose
cutoff was one of (-1,0,1,2).
The default value is &lsquo;2&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltLowerBound.minimal_interesting</samp></dt>
<dd><p>Long integer. Together with the corresponding <code>maximal_interesting</code> parameter,
specifies the range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range that should
be reported. For instance, setting <code>minimal_interesting</code> to -1 and
<code>maximal_interesting</code> to 2 would only permit output of EltLowerBound invariants whose
cutoff was one of (-1,0,1,2).
The default value is &lsquo;-1&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltLowerBoundFloat.maximal_interesting</samp></dt>
<dd><p>Long integer. Together with the corresponding <code>minimal_interesting</code> parameter,
specifies the range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range that should
be reported. For instance, setting <code>minimal_interesting</code> to -1 and
<code>maximal_interesting</code> to 2 would only permit output of EltLowerBoundFloat invariants whose
cutoff was one of (-1,0,1,2).
The default value is &lsquo;2&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltLowerBoundFloat.minimal_interesting</samp></dt>
<dd><p>Long integer. Together with the corresponding <code>maximal_interesting</code> parameter,
specifies the range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range that should
be reported. For instance, setting <code>minimal_interesting</code> to -1 and
<code>maximal_interesting</code> to 2 would only permit output of EltLowerBoundFloat invariants whose
cutoff was one of (-1,0,1,2).
The default value is &lsquo;-1&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltOneOf.omit_hashcode_values_Simplify</samp></dt>
<dd><p>Boolean. If true, invariants describing hashcode-typed variables as having any particular value
will have an artificial value substituted for the exact hashhode values. The artificial values
will stay the same from run to run even if the actual hashcode values change (as long as the
OneOf invariants remain the same). If false, hashcodes will be formatted as the application of
a hashcode uninterpreted function to an integer representing the bit pattern of the hashcode.
One might wish to omit the exact values of the hashcodes because they are usually
uninteresting; this is the same reason they print in the native Daikon format, for instance, as
<code>var has only one value</code> rather than <code>var == 150924732</code>.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltOneOf.size</samp></dt>
<dd><p>Positive integer. Specifies the maximum set size for this type of invariant (x is one of
<code>size</code> items).
The default value is &lsquo;3&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltOneOfFloat.size</samp></dt>
<dd><p>Positive integer. Specifies the maximum set size for this type of invariant (x is one of
<code>size</code> items).
The default value is &lsquo;3&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltUpperBound.maximal_interesting</samp></dt>
<dd><p>Long integer. Together with the corresponding <code>minimal_interesting</code> parameter,
specifies the range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range that should
be reported. For instance, setting <code>minimal_interesting</code> to -1 and
<code>maximal_interesting</code> to 2 would only permit output of EltUpperBound invariants whose
cutoff was one of (-1,0,1,2).
The default value is &lsquo;2&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltUpperBound.minimal_interesting</samp></dt>
<dd><p>Long integer. Together with the corresponding <code>maximal_interesting</code> parameter,
specifies the range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range that should
be reported. For instance, setting <code>minimal_interesting</code> to -1 and
<code>maximal_interesting</code> to 2 would only permit output of EltUpperBound invariants whose
cutoff was one of (-1,0,1,2).
The default value is &lsquo;-1&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltUpperBoundFloat.maximal_interesting</samp></dt>
<dd><p>Long integer. Together with the corresponding <code>minimal_interesting</code> parameter,
specifies the range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range that should
be reported. For instance, setting <code>minimal_interesting</code> to -1 and
<code>maximal_interesting</code> to 2 would only permit output of EltUpperBoundFloat invariants whose
cutoff was one of (-1,0,1,2).
The default value is &lsquo;2&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.EltUpperBoundFloat.minimal_interesting</samp></dt>
<dd><p>Long integer. Together with the corresponding <code>maximal_interesting</code> parameter,
specifies the range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range that should
be reported. For instance, setting <code>minimal_interesting</code> to -1 and
<code>maximal_interesting</code> to 2 would only permit output of EltUpperBoundFloat invariants whose
cutoff was one of (-1,0,1,2).
The default value is &lsquo;-1&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.OneOfFloatSequence.size</samp></dt>
<dd><p>Positive integer. Specifies the maximum set size for this type of invariant (x is one of
<code>size</code> items).
The default value is &lsquo;3&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.OneOfSequence.omit_hashcode_values_Simplify</samp></dt>
<dd><p>Boolean. If true, invariants describing hashcode-typed variables as having any particular value
will have an artificial value substituted for the exact hashhode values. The artificial values
will stay the same from run to run even if the actual hashcode values change (as long as the
OneOf invariants remain the same). If false, hashcodes will be formatted as the application of
a hashcode uninterpreted function to an integer representing the bit pattern of the hashcode.
One might wish to omit the exact values of the hashcodes because they are usually
uninteresting; this is the same reason they print in the native Daikon format, for instance, as
<code>var has only one value</code> rather than <code>var == 150924732</code>.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.OneOfSequence.size</samp></dt>
<dd><p>Positive integer. Specifies the maximum set size for this type of invariant (x is one of
<code>size</code> items).
The default value is &lsquo;3&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.sequence.SingleSequence.SeqIndexDisableAll</samp></dt>
<dd><p>Boolean. Set to true to disable all SeqIndex invariants (SeqIndexIntEqual,
SeqIndexFloatLessThan, etc). This overrides the settings of the individual SeqIndex enable
configuration options. To disable only some options, the options must be disabled individually.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.string.OneOfString.size</samp></dt>
<dd><p>Positive integer. Specifies the maximum set size for this type of invariant (x is one of
<code>size</code> items).
The default value is &lsquo;3&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.stringsequence.EltOneOfString.size</samp></dt>
<dd><p>Positive integer. Specifies the maximum set size for this type of invariant (x is one of
<code>size</code> items).
The default value is &lsquo;3&rsquo;.
</p>
</dd>
<dt><samp>daikon.inv.unary.stringsequence.OneOfStringSequence.size</samp></dt>
<dd><p>Positive integer. Specifies the maximum set size for this type of invariant (x is one of
<code>size</code> items).
The default value is &lsquo;2&rsquo;.
</p>
</dd>
</dl>

<hr>
<a name="Options-to-enable_002fdisable-derived-variables"></a>
<div class="header">
<p>
Next: <a href="#Simplify-interface-configuration-options" accesskey="n" rel="next">Simplify interface configuration options</a>, Previous: <a href="#Other-invariant-configuration-parameters" accesskey="p" rel="previous">Other invariant configuration parameters</a>, Up: <a href="#List-of-configuration-options" accesskey="u" rel="up">List of configuration options</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Options-to-enable_002fdisable-derived-variables-1"></a>
<h4 class="subsubsection">6.1.1.4 Options to enable/disable derived variables</h4>

<a name="index-derived-variables_002c-enabling_002fdisabling"></a>
<p>These options control whether Daikon looks for invariants involving certain forms of derived variables.  Also see <a href="Daikon-output.html#Variable-names">Variable names</a>.
</p>
<dl compact="compact">
<dt><samp>daikon.derive.Derivation.disable_derived_variables</samp></dt>
<dd><p>Boolean. If true, Daikon will not create any derived variables. Derived variables, which are
combinations of variables that appeared in the program, like <code>array[index]</code> if <code>array</code> and <code>index</code> appeared, can increase the number of properties Daikon finds,
especially over sequences. However, derived variables increase Daikon&rsquo;s time and memory usage,
sometimes dramatically. If false, individual kinds of derived variables can be enabled or
disabled individually using configuration options under <code>daikon.derive</code>.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequenceFloatIntersection.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceFloatIntersection derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequenceFloatSubscript.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceFloatSubscript derived variables should be generated.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequenceFloatSubsequence.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceFloatSubsequence derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequenceFloatUnion.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceFloatUnion derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequenceScalarIntersection.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceScalarIntersection derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequenceScalarSubscript.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceScalarSubscript derived variables should be generated.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequenceScalarSubsequence.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceScalarSubsequence derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequenceScalarUnion.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceScalarUnion derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequenceStringIntersection.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceStringIntersection derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequenceStringSubscript.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceStringSubscript derived variables should be generated.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequenceStringSubsequence.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceStringSubsequence derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequenceStringUnion.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceStringUnion derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequencesConcat.enabled</samp></dt>
<dd><p>Boolean. True iff SequencesConcat derived variables should be created.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequencesJoin.enabled</samp></dt>
<dd><p>Boolean. True iff SequencesJoin derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequencesJoinFloat.enabled</samp></dt>
<dd><p>Boolean. True iff SequencesJoin derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequencesPredicate.boolOnly</samp></dt>
<dd><p>Boolean. True if Daikon should only generate derivations on boolean predicates.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequencesPredicate.enabled</samp></dt>
<dd><p>Boolean. True iff SequencesPredicate derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequencesPredicate.fieldOnly</samp></dt>
<dd><p>Boolean. True if Daikon should only generate derivations on fields of the same data structure.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequencesPredicateFloat.boolOnly</samp></dt>
<dd><p>Boolean. True if Daikon should only generate derivations on boolean predicates.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequencesPredicateFloat.enabled</samp></dt>
<dd><p>Boolean. True iff SequencesPredicate derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.binary.SequencesPredicateFloat.fieldOnly</samp></dt>
<dd><p>Boolean. True if Daikon should only generate derivations on fields of the same data structure.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.ternary.SequenceFloatArbitrarySubsequence.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceFloatArbitrarySubsequence derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.ternary.SequenceScalarArbitrarySubsequence.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceScalarArbitrarySubsequence derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.ternary.SequenceStringArbitrarySubsequence.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceStringArbitrarySubsequence derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.unary.SequenceInitial.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceInitial derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.unary.SequenceInitialFloat.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceInitial derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.unary.SequenceLength.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceLength derived variables should be generated.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.unary.SequenceMax.enabled</samp></dt>
<dd><p>Boolean. True iff SequencesMax derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.unary.SequenceMin.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceMin derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.unary.SequenceSum.enabled</samp></dt>
<dd><p>Boolean. True iff SequenceSum derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.derive.unary.StringLength.enabled</samp></dt>
<dd><p>Boolean. True iff StringLength derived variables should be generated.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
</dl>

<hr>
<a name="Simplify-interface-configuration-options"></a>
<div class="header">
<p>
Next: <a href="#Splitter-options" accesskey="n" rel="next">Splitter options</a>, Previous: <a href="#Options-to-enable_002fdisable-derived-variables" accesskey="p" rel="previous">Options to enable/disable derived variables</a>, Up: <a href="#List-of-configuration-options" accesskey="u" rel="up">List of configuration options</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Simplify-interface-configuration-options-1"></a>
<h4 class="subsubsection">6.1.1.5 Simplify interface configuration options</h4>

<a name="index-Simplify-theorem-prover_002c-configuring"></a>
<p>The configuration options in this section are used to customize the interface to the Simplify theorem prover.  See the description of the <samp>--suppress_redundant</samp> command-line option in <a href="Running-Daikon.html#Options-to-control-invariant-detection">Options to control invariant detection</a>.
</p>
<dl compact="compact">
<dt><samp>daikon.simplify.LemmaStack.print_contradictions</samp></dt>
<dd><p>Boolean. Controls Daikon&rsquo;s response when inconsistent invariants are discovered while running
Simplify. If true, Daikon will print an error message to the standard error stream listing the
contradictory invariants. This is mainly intended for debugging Daikon itself, but can
sometimes be helpful in tracing down other problems. For more information, see the section on
troubleshooting contradictory invariants in the Daikon manual.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.simplify.LemmaStack.remove_contradictions</samp></dt>
<dd><p>Boolean. Controls Daikon&rsquo;s response when inconsistent invariants are discovered while running
Simplify. If false, Daikon will give up on using Simplify for that program point. If true,
Daikon will try to find a small subset of the invariants that cause the contradiction and avoid
them, to allow processing to continue. For more information, see the section on troubleshooting
contradictory invariants in the Daikon manual.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.simplify.LemmaStack.synchronous_errors</samp></dt>
<dd><p>Boolean. If true, ask Simplify to check a simple proposition after each assumption is pushed,
providing an opportunity to wait for output from Simplify and potentially receive error
messages about the assumption. When false, long sequences of assumptions may be pushed in a
row, so that by the time an error message arrives, it&rsquo;s not clear which input caused the error.
Of course, Daikon&rsquo;s input to Simplify isn&rsquo;t supposed to cause errors, so this option should
only be needed for debugging.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.simplify.Session.simplify_max_iterations</samp></dt>
<dd><p>A non-negative integer, representing the largest number of iterations for which Simplify should
be allowed to run on any single conjecture before giving up. Larger values may cause Simplify
to run longer, but will increase the number of invariants that can be recognized as redundant.
The default value is small enough to keep Simplify from running for more than a few seconds on
any one conjecture, allowing it to verify most simple facts without getting bogged down in long
searches. A value of 0 means not to bound the number of iterations at all, though see also the
<code>simplify_timeout</code> parameter..
</p>
</dd>
<dt><samp>daikon.simplify.Session.simplify_timeout</samp></dt>
<dd><p>A non-negative integer, representing the longest time period (in seconds) Simplify should be
allowed to run on any single conjecture before giving up. Larger values may cause Simplify to
run longer, but will increase the number of invariants that can be recognized as redundant.
Roughly speaking, the time spent in Simplify will be bounded by this value, times the number of
invariants generated, though it can be much less. A value of 0 means to not bound Simplify at
all by time, though also see the option <code>simplify_max_iterations</code>. Beware that using this
option might make Daikon&rsquo;s output depend on the speed of the machine it&rsquo;s run on.
The default value is &lsquo;0&rsquo;.
</p>
</dd>
<dt><samp>daikon.simplify.Session.trace_input</samp></dt>
<dd><p>Boolean. If true, the input to the Simplify theorem prover will also be directed to a file
named simplifyN.in (where N is a number starting from 0) in the current directory. Simplify&rsquo;s
operation can then be reproduced with a command like <code>Simplify -nosc &lt;simplify0.in</code>. This
is intended primarily for debugging when Simplify fails.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.simplify.Session.verbose_progress</samp></dt>
<dd><p>Positive values mean to print extra indications as each candidate invariant is passed to
Simplify during the <code>--suppress_redundant</code> check. If the value is 1 or higher, a hyphen
will be printed when each invariant is passed to Simplify, and then replaced by a <code>T</code> if
the invariant was redundant, <code>F</code> if it was not found to be, and <code>?</code> if Simplify
gave up because of a time limit. If the value is 2 or higher, a <code>&lt;</code> or <code>&gt;</code> will
also be printed for each invariant that is pushed onto or popped from from Simplify&rsquo;s
assumption stack. This option is mainly intended for debugging purposes, but can also provide
something to watch when Simplify takes a long time.
The default value is &lsquo;0&rsquo;.
</p>
</dd>
</dl>

<hr>
<a name="Splitter-options"></a>
<div class="header">
<p>
Next: <a href="#Debugging-options" accesskey="n" rel="next">Debugging options</a>, Previous: <a href="#Simplify-interface-configuration-options" accesskey="p" rel="previous">Simplify interface configuration options</a>, Up: <a href="#List-of-configuration-options" accesskey="u" rel="up">List of configuration options</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Splitter-options-1"></a>
<h4 class="subsubsection">6.1.1.6 Splitter options</h4>

<a name="index-Splitters_002c-configuring"></a>
<p>The configuration options in this section are used to customize the the behavior of splitters, which yield conditional invariants and implications (see <a href="#Conditional-invariants">Conditional invariants</a>).
</p>
<dl compact="compact">
<dt><samp>daikon.split.ContextSplitterFactory.granularity</samp></dt>
<dd><p>Enumeration (integer). Specifies the granularity to use for callsite splitter processing. (That
is, for creating invariants for a method that are dependent on where the method was called
from.) 0 is line-level granularity; 1 is method-level granularity; 2 is class-level
granularity.
The default value is &lsquo;1&rsquo;.
</p>
</dd>
<dt><samp>daikon.split.PptSplitter.disable_splitting</samp></dt>
<dd><p>Boolean. If true, the built-in splitting rules are disabled. The built-in rules look for
implications based on boolean return values and also when there are exactly two exit points
from a method.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.split.PptSplitter.dummy_invariant_level</samp></dt>
<dd><p>Integer. A value of zero indicates that DummyInvariant objects should not be created. A value
of one indicates that dummy invariants should be created only when no suitable condition was
found in the regular output. A value of two indicates that dummy invariants should be created
for each splitting condition.
The default value is &lsquo;0&rsquo;.
</p>
</dd>
<dt><samp>daikon.split.PptSplitter.split_bi_implications</samp></dt>
<dd><p>Split bi-implications (&quot;<code>a &lt;==&gt; b</code>&quot;) into two separate implications (&quot;<code>a ==&gt; b</code>&quot;
and &quot;<code>b ==&gt; a</code>&quot;).
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.split.PptSplitter.suppressSplitterErrors</samp></dt>
<dd><p>When true, compilation errors during splitter file generation will not be reported to the user.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.split.SplitterFactory.compile_timeout</samp></dt>
<dd><p>Positive integer. Specifies the Splitter compilation timeout, in seconds, after which the
compilation process is terminated and retried, on the assumption that it has hung.
The default value is &lsquo;20&rsquo;.
</p>
</dd>
<dt><samp>daikon.split.SplitterFactory.compiler</samp></dt>
<dd><p>String. Specifies which Java compiler is used to compile Splitters. This can be the full path
name or whatever is used on the command line.
</p>
<p>By default, $DAIKONDIR/java is part of the classpath. This is useful when working from the
sources directly.
</p>
<p>The default value is &quot;javac -classpath $DAIKONDIR/daikon.jar:$DAIKONDIR/java&quot; (with
appropriate classpath separator for the operating system).
</p>
</dd>
<dt><samp>daikon.split.SplitterFactory.delete_splitters_on_exit</samp></dt>
<dd><p>Boolean. If true, the temporary Splitter files are deleted on exit. Set it to &quot;false&quot; if you
are debugging splitters.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.split.SplitterList.all_splitters</samp></dt>
<dd><p>Boolean. Enables indiscriminate splitting (see Daikon manual, <a href="#Indiscriminate-splitting">Indiscriminate splitting</a>,
for an explanation of this technique).
The default value is &lsquo;true&rsquo;.
</p>
</dd>
</dl>

<hr>
<a name="Debugging-options"></a>
<div class="header">
<p>
Next: <a href="#General-configuration-options" accesskey="n" rel="next">General configuration options</a>, Previous: <a href="#Splitter-options" accesskey="p" rel="previous">Splitter options</a>, Up: <a href="#List-of-configuration-options" accesskey="u" rel="up">List of configuration options</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Debugging-options-1"></a>
<h4 class="subsubsection">6.1.1.7 Debugging options</h4>

<a name="index-Splitters_002c-configuring-1"></a>
<p>The configuration options in this section are used to cause extra output that is useful for debugging.
</p>
<dl compact="compact">
<dt><samp>daikon.Debug.internal_check</samp></dt>
<dd><p>When true, perform detailed internal checking. These are essentially additional, possibly
costly assert statements.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.Debug.logDetail</samp></dt>
<dd><p>Determines whether or not detailed info (such as from <code>add_modified</code>) is printed.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.Debug.showTraceback</samp></dt>
<dd><p>Determines whether or not traceback information is printed for each call to log.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.Debug.show_stack_trace</samp></dt>
<dd><p>If true, show stack traces for errors such as file format errors.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
</dl>

<hr>
<a name="General-configuration-options"></a>
<div class="header">
<p>
Previous: <a href="#Debugging-options" accesskey="p" rel="previous">Debugging options</a>, Up: <a href="#List-of-configuration-options" accesskey="u" rel="up">List of configuration options</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="General-configuration-options-1"></a>
<h4 class="subsubsection">6.1.1.8 General configuration options</h4>

<p>This section lists miscellaneous configuration options for Daikon.
</p>
<dl compact="compact">
<dt><samp>daikon.Daikon.calc_possible_invs</samp></dt>
<dd><p>Boolean. Just print the total number of possible invariants and exit.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.Daikon.enable_floats</samp></dt>
<dd><p>Boolean. Controls whether invariants are reported over floating-point values.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.Daikon.guardNulls</samp></dt>
<dd><p>If &quot;always&quot;, then invariants are always guarded. If &quot;never&quot;, then invariants are never guarded.
If &quot;missing&quot;, then invariants are guarded only for variables that were missing (&quot;can be
missing&quot;) in the dtrace (the observed executions). If &quot;default&quot;, then use &quot;missing&quot; mode for
Java output and &quot;never&quot; mode otherwise.
</p>
<p>Guarding means adding predicates that ensure that variables can be dereferenced. For
instance, if <code>a</code> can be null &mdash; that is, if <code>a.b</code> can be nonsensical &mdash; then the
guarded version of
</p>
<div class="example">
<pre class="example">a.b == 5
</pre></div>

<p>is
</p>
<div class="example">
<pre class="example">(a != null) -&gt; (a.b == 5)
</pre></div>

<p>.
</p>
<p>(To do: Some configuration option (maybe this one) should add guards for other reasons that
lead to nonsensical values (see <a href="Daikon-output.html#Variable-names">Variable names</a>).) <br>
<a name="index-nonsensical-values-for-variables_002c-guarding_002e"></a>
The default value is &lsquo;default&rsquo;.
</p>
</dd>
<dt><samp>daikon.Daikon.output_conditionals</samp></dt>
<dd><p>Boolean. Controls whether conditional program points are displayed.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.Daikon.ppt_perc</samp></dt>
<dd><p>Integer. Percentage of program points to process. All program points are sorted by name, and
all samples for the first <code>ppt_perc</code> program points are processed. A percentage of 100
matches all program points.
The default value is &lsquo;100&rsquo;.
</p>
</dd>
<dt><samp>daikon.Daikon.print_sample_totals</samp></dt>
<dd><p>Boolean. Controls whether or not the total samples read and processed are printed at the end of
processing.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.Daikon.progress_delay</samp></dt>
<dd><p>The amount of time to wait between updates of the progress display, measured in milliseconds. A
value of -1 means do not print the progress display at all.
The default value is &lsquo;1000&rsquo;.
</p>
</dd>
<dt><samp>daikon.Daikon.progress_display_width</samp></dt>
<dd><p>The number of columns of progress information to display. In many Unix shells, this can be set
to an appropriate value by <code>--config_option
daikon.Daikon.progress_display_width=$COLUMNS</code>.
The default value is &lsquo;80&rsquo;.
</p>
</dd>
<dt><samp>daikon.Daikon.quiet</samp></dt>
<dd><p>Boolean. Controls whether or not processing information is printed out. Setting this variable
to true also automatically sets <code>progress_delay</code> to -1.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.Daikon.undo_opts</samp></dt>
<dd><p>Boolean. Controls whether the Daikon optimizations (equality sets, suppressions) are undone at
the end to create a more complete set of invariants. Output does not include conditional
program points, implications, reflexive and partially reflexive invariants.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.DynamicConstants.OneOf_only</samp></dt>
<dd><p>Boolean. Controls which invariants are created for variables that are constant for the entire
run. If true, create only OneOf invariants. If false, create all possible invariants.
</p>
<p>Note that setting this to true only fails to create invariants between constants. Invariants
between constants and non-constants are created regardless.
</p>
<p>A problem occurs with merging when this is turned on. If a var_info is constant at one child
slice, but not constant at the other child slice, interesting invariants may not be merged
because they won&rsquo;t exist on the slice with the constant. This is thus currently defaulted to
false.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.DynamicConstants.use_dynamic_constant_optimization</samp></dt>
<dd><p>Whether to use the dynamic constants optimization. This optimization doesn&rsquo;t instantiate
invariants over constant variables (i.e., that that have only seen one value). When the
variable receives a second value, invariants are instantiated and are given the sample
representing the previous constant value.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.FileIO.add_changed</samp></dt>
<dd><p>Boolean. When false, set modbits to 1 iff the printed representation has changed. When true,
set modbits to 1 if the printed representation has changed; leave other modbits as is.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.FileIO.continue_after_file_exception</samp></dt>
<dd><p>Boolean. When true, suppress exceptions related to file reading. This permits Daikon to
continue even if there is a malformed trace file. Use this with care: in general, it is better
to fix the problem that caused a bad trace file, rather than to suppress the exception.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.FileIO.count_lines</samp></dt>
<dd><p>Boolean. When false, don&rsquo;t count the number of lines in the dtrace file before reading. This
will disable the percentage progress printout.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.FileIO.dtrace_line_count</samp></dt>
<dd><p>Long integer. If non-zero, this value will be used as the number of lines in (each) dtrace file
input for the purposes of the progress display, and the counting of the lines in the file will
be suppressed.
The default value is &lsquo;0&rsquo;.
</p>
</dd>
<dt><samp>daikon.FileIO.ignore_missing_enter</samp></dt>
<dd><p>When true, just ignore exit ppts that don&rsquo;t have a matching enter ppt rather than exiting with
an error. Unmatched exits can occur if only a portion of a dtrace file is processed.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.FileIO.max_line_number</samp></dt>
<dd><p>Integer. Maximum number of lines to read from the dtrace file. If 0, reads the entire file.
The default value is &lsquo;0&rsquo;.
</p>
</dd>
<dt><samp>daikon.FileIO.read_samples_only</samp></dt>
<dd><p>Boolean. When true, only read the samples, but don&rsquo;t process them. Used to gather timing
information.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.FileIO.rm_stack_dups</samp></dt>
<dd><p>If true, modified all ppt names to remove duplicate routine names within the ppt name. This is
used when a stack trace (of active methods) is used as the ppt name. The routine names must be
separated by vertical bars (|).
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.FileIO.unmatched_procedure_entries_quiet</samp></dt>
<dd><p>Boolean. When true, don&rsquo;t print a warning about unmatched procedure entries, which are ignored
by Daikon (unless the <code>--nohierarchy</code> command-line argument is provided).
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.FileIO.verbose_unmatched_procedure_entries</samp></dt>
<dd><p>Boolean. If true, prints the unmatched procedure entries verbosely.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.PptRelation.enable_object_user</samp></dt>
<dd><p>Boolean. Controls whether the object-user relation is created in the variable hierarchy.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.PptSliceEquality.set_per_var</samp></dt>
<dd><p>If true, create one equality set for each variable. This has the effect of turning the equality
optimization off, without actually removing the sets themselves (which are presumed to exist in
many parts of the code).
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.PptTopLevel.pairwise_implications</samp></dt>
<dd><p>Boolean. If true, create implications for all pairwise combinations of conditions, and all
pairwise combinations of exit points. If false, create implications for only the first two
conditions, and create implications only if there are exactly two exit points.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.PptTopLevel.remove_merged_invs</samp></dt>
<dd><p>Remove invariants at lower program points when a matching invariant is created at a higher
program point. For experimental purposes only.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.PrintInvariants.old_array_names</samp></dt>
<dd><p>In the new decl format, print array names as &rsquo;a[]&rsquo; as opposed to &rsquo;a[..]&rsquo; This creates names
that are more compatible with the old output. This option has no effect in the old decl format.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.PrintInvariants.print_all</samp></dt>
<dd><p>If true, print all invariants without any filtering.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.PrintInvariants.print_implementer_entry_ppts</samp></dt>
<dd><p>If false, don&rsquo;t print entry method program points for methods that override or implement
another method (i.e., entry program points that have a parent that is a method). Microsoft Code
Contracts does not allow contracts on such methods.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.PrintInvariants.print_inv_class</samp></dt>
<dd><p>Print invariant classname with invariants in output of <code>format()</code> method, normally used
only for debugging output rather than ordinary printing of invariants.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.PrintInvariants.remove_post_vars</samp></dt>
<dd><p>If true, remove as many variables as possible that need to be indicated as &rsquo;post&rsquo;. Post
variables occur when the subscript for a derived variable with an orig sequence is not orig.
For example: orig(a[post(i)]) An equivalent expression involving only orig variables is
substitued for the post variable when one exists.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.PrintInvariants.replace_prestate</samp></dt>
<dd><p>This option must be given with &quot;&ndash;format Java&quot; option.
</p>
<p>Instead of outputting prestate expressions as &quot;\old(E)&quot; within an invariant, output a
variable name (e.g. &lsquo;v1&rsquo;). At the end of each program point, output the list of
variable-to-expression mappings. For example: with this option set to false, a program point
might print like this:
</p>
<div class="example">
<pre class="example">foo.bar.Bar(int):::EXIT
\old(capacity) == sizeof(this.theArray)
</pre></div>

<p>With the option set to true, it would print like this:
</p>
<div class="example">
<pre class="example">foo.bar.Bar(int):::EXIT
v0 == sizeof(this.theArray)
prestate assignment: v0=capacity
</pre></div>

<p>The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.PrintInvariants.static_const_infer</samp></dt>
<dd><p>This enables a different way of treating static constant variables. They are not created into
invariants into slices. Instead, they are examined during print time. If a unary invariant
contains a value which matches the value of a static constant varible, the value will be
replaced by the name of the variable, &quot;if it makes sense&quot;. For example, if there is a static
constant variable a = 1. And if there exists an invariant x &lt;= 1, x &lt;= a would be the
result printed.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.PrintInvariants.true_inv_cnt</samp></dt>
<dd><p>If true, print the total number of true invariants. This includes invariants that are redundant
and would normally not be printed or even created due to optimizations.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.ProglangType.convert_to_signed</samp></dt>
<dd><p>If true, treat 32 bit values whose high bit is on, as a negative number (rather than as a 32
bit unsigned).
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.VarInfo.constant_fields_simplify</samp></dt>
<dd><p>If true, the treat static constants (such as MapQuick.GeoPoint.FACTOR) as fields within an
object rather than as a single name. Not correct, but used to obtain compatibility with
VarInfoName.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.VarInfo.declared_type_comparability</samp></dt>
<dd><p>If true, then variables are only considered comparable if they are declared with the same type.
For example, java.util.List is not comparable to java.util.ArrayList and float is not
comparable to double. This may miss valid invariants, but significant time can be saved and
many variables with different declared types are not comparable (e.g., java.util.Date and
java.util.ArrayList).
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.chicory.DaikonVariableInfo.constant_infer</samp></dt>
<dd><p>Enable experimental techniques on static constants.
The default value is &lsquo;false&rsquo;.
</p>
</dd>
<dt><samp>daikon.suppress.NIS.enabled</samp></dt>
<dd><p>Boolean. If true, enable non-instantiating suppressions.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.suppress.NIS.hybrid_threshhold</samp></dt>
<dd><p>Int. Less and equal to this number means use the falsified method in the hybrid method of
processing falsified invariants, while greater than this number means use the antecedent
method. Empirical data shows that number should not be more than 10000.
The default value is &lsquo;2500&rsquo;.
</p>
</dd>
<dt><samp>daikon.suppress.NIS.skip_hashcode_type</samp></dt>
<dd><p>Boolean. If true, skip variables of file rep type hashcode when creating invariants over
constants in the antecedent method.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
<dt><samp>daikon.suppress.NIS.suppression_processor</samp></dt>
<dd><p>Specifies the algorithm that NIS uses to process suppressions. Possible selections are
&rsquo;HYBRID&rsquo;, &rsquo;ANTECEDENT&rsquo;, and &rsquo;FALSIFIED&rsquo;. The default is the hybrid algorithm which uses the
falsified algorithm when only a small number of suppressions need to be processed and the
antecedent algorithm when a large number of suppressions are processed.
The default value is &lsquo;HYBRID&rsquo;.
</p>
</dd>
<dt><samp>daikon.suppress.NIS.suppressor_list</samp></dt>
<dd><p>Boolean. If true, use the specific list of suppressor related invariant prototypes when
creating constant invariants in the antecedent method.
The default value is &lsquo;true&rsquo;.
</p>
</dd>
</dl>




<hr>
<a name="Conditional-invariants"></a>
<div class="header">
<p>
Next: <a href="#Enhancing-conditional-invariant-detection" accesskey="n" rel="next">Enhancing conditional invariant detection</a>, Previous: <a href="#Configuration-options" accesskey="p" rel="previous">Configuration options</a>, Up: <a href="#Enhancing-Daikon-output" accesskey="u" rel="up">Enhancing Daikon output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Conditional-invariants-_0028disjunctions_0029-and-implications"></a>
<h3 class="section">6.2 Conditional invariants (disjunctions) and implications</h3>
<a name="index-splitting"></a>
<a name="index-splitting-condition"></a>
<a name="index-conditional-invariant"></a>
<a name="index-invariant_002c-conditional"></a>
<a name="index-implication-invariant"></a>
<a name="index-invariant_002c-implication"></a>
<a name="index-disjunction"></a>
<a name="index-disjunctive-invariant"></a>
<a name="index-invariant_002c-disjunctive"></a>

<p>Conditional invariants are invariants that are true only part of the time.
For instance, consider the absolute value procedure.  Its postcondition is
</p><div class="example">
<pre class="example">if arg &lt; 0
  then return == -arg
  else return == arg
</pre></div>

<p>The invariant <code>return == -arg</code> is a conditional invariant because
it depends on the predicate <code>arg &lt; 0</code> being true.  An
<em>implication</em> is a compound invariant that includes both the
predicate and the conditional invariant (also called the consequent);
an example of an implication is <code>arg &lt; 0 ==&gt; return == -arg</code>.
</p>
<a name="index-context_002dsensitive-invariant"></a>
<a name="index-call_002dsite_002ddependent-invariant"></a>

<p>Another type of implication is a <i>context-sensitive</i> invariant &mdash; a
fact about method A that is true only when A is called by method B, but
not true in general about A.
You can use the configuration option
<code>daikon.split.ContextSplitterFactory.granularity</code> to control creation
of context-sensitive invariants.
Alternately, you can use implications to construct
context-sensitive invariants:  set a variable that depends on the call
site, then compute an implication whose predicate tests that variable.
For an example, see the paper <cite>Selecting, refining, and evaluating
predicates for program analysis</cite>
(<a href="http://plse.cs.washington.edu/daikon/pubs/predicates-tr914-abstract.html">http://plse.cs.washington.edu/daikon/pubs/predicates-tr914-abstract.html</a>).
</p>
<p>Daikon must be supplied with the predicate for an implication.  Daikon has
certain built-in predicates that it uses for finding conditional invariants;
examples are which return statement was executed in a procedure and whether a
boolean procedure returns true or false.  Additionally, Daikon can read
predicates from a file called a splitter info (<samp>.spinfo</samp>) file and find
implications based on those predicates.  The splitter info file can be produced
automatically, such as by static analysis of the program using the <code>CreateSpinfo</code>
and <code>CreateSpinfoC</code> programs (see <a href="#Static-analysis-for-splitters">Static analysis for splitters</a>)
or by cluster analysis of the
traced values in the data trace file.  Details of these techniques and usage
guides can be found in <a href="#Enhancing-conditional-invariant-detection">Enhancing conditional invariant detection</a>.  Users
can also create splitter info files themselves or can augment
automatically-created ones.
</p>
<p>To detect conditional invariants and implications:
</p><ol>
<li> Create the splitter info file, either automatically or by hand.
</li><li> Run Daikon with the <samp>.spinfo</samp> file as one of its arguments.
(The order of arguments does not matter.)
For example,
<div class="example">
<pre class="example">java daikon.Daikon Foo.decls Foo.spinfo Foo.dtrace
</pre></div>
</li></ol>

<p>The term <em>splitter</em> comes from Daikon&rsquo;s technique for detecting
implications and conditional invariants.  For each predicate, Daikon
creates two conditional program points &mdash; one for program executions
that satisfy the condition and one for those that don&rsquo;t &mdash; and splits
the data trace into two parts.  Invariant detection is then performed
on the conditional program points (that is, the parts of the data
trace) separately and any invariants detected are reported as
conditional invariants (as implications).
</p>
<p>To be precise, we say that an invariant holds exclusively if it is
discovered on one side of a split, and its negation is discovered on
the opposite side.  Daikon creates conditional invariants whose
predicates are invariants that hold exclusively on one side of a
split, and whose consequents are invariants that hold on that side of
the split but not on the unsplit program point.  If Daikon finds
multiple exclusive conditions, it will create biconditional (&ldquo;if and
only if&rdquo;) invariants between the equivalent conditions.  Within the
context of the program, each of the exclusive conditions is equivalent
to the splitting condition.  In particular, if both the splitting
condition and its negation are within the grammar of invariants that
Daikon detects, the splitting condition may appear as the predicate of
the generated conditional invariants.  On the other hand, if other
equivalent conditions are found, or if the splitting condition is not
expressible in Daikon&rsquo;s grammar, it might not appear in the generated
implications.
</p>
<a name="index-dummy-invariant"></a>
<a name="index-invariant_002c-dummy"></a>

<p>In some cases, the default policy of selecting predicates from
Daikon&rsquo;s output may be insufficient.  For instance, Daikon might not
detect any invariant equivalent to the splitting condition, if the
splitting condition is
sufficiently complex or application-specific.  In such situations,
Daikon can also use the splitting condition itself, as what is called a
<em>dummy invariant</em>.
To use dummy invariants, set the configuration option
<samp>daikon.split.PptSplitter.dummy_invariant_level</samp> to a
non-zero value (see <a href="#List-of-configuration-options">List of configuration options</a>).
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Splitter-info-file-format" accesskey="1">Splitter info file format</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Indiscriminate-splitting" accesskey="2">Indiscriminate splitting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Example-splitter-info-file" accesskey="3">Example splitter info file</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Splitter-info-file-format"></a>
<div class="header">
<p>
Next: <a href="#Indiscriminate-splitting" accesskey="n" rel="next">Indiscriminate splitting</a>, Up: <a href="#Conditional-invariants" accesskey="u" rel="up">Conditional invariants</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Splitter-info-file-format-1"></a>
<h4 class="subsection">6.2.1 Splitter info file format</h4>
<a name="index-splitter-info-file"></a>
<a name="index-_002espinfo-file"></a>
<a name="index-spinfo-file"></a>

<p>A splitter info file contains the conditions that Daikon should use to
create conditional invariants.  Each section in the <samp>.spinfo</samp>
file consists of a sequence of non-blank lines; sections are separated
by blank lines.  There are two types of sections:  program point
sections and replacement sections.
See <a href="#Example-splitter-info-file">Example splitter info file</a>, for an example splitter info file.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Program-point-sections" accesskey="1">Program point sections</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Replacement-sections" accesskey="2">Replacement sections</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Program-point-sections"></a>
<div class="header">
<p>
Next: <a href="#Replacement-sections" accesskey="n" rel="next">Replacement sections</a>, Up: <a href="#Splitter-info-file-format" accesskey="u" rel="up">Splitter info file format</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Program-point-sections-1"></a>
<h4 class="subsubsection">6.2.1.1 Program point sections</h4>

<p>Program point sections have a line specifying a program point name
followed by lines specifying the condition(s) associated with that
program point, each condition on its own line.  Additional information
about a condition may be specified on indented lines.  For example, a
typical entry is
</p>
<div class="example">
<pre class="example">PPT_NAME <var>pptname</var>
<var>condition1</var>
<var>condition2</var>
    DAIKON_FORMAT <var>string</var>
    ESC_FORMAT <var>string</var>
<var>condition3</var>
...
</pre></div>

<p><var>pptname</var> can be any string that matches a part of the desired
program point name as printed in the <samp>.decls</samp> file.  In finding matching
program points, Daikon uses the first program point that matches
<var>pptname</var>.  Caution is necessary when dealing with method names
that are prefixes of other method names.  For instance, if the class
<code>List</code> has methods <code>add</code> and <code>addAll</code>, specifying
&lsquo;<samp>PPT_NAME List.add</samp>&rsquo; might select either method, depending on
which was encountered first.  Instead writing &lsquo;<samp>PPT_NAME
List.add(</samp>&rsquo; will match only the <code>add</code> method.
</p>
<p>Each condition is a Java expression of boolean type.  All variables
that appear in the condition must also appear in the declaration of
the program point in the <samp>.decls</samp> file.  (In other words, all the
variables must be in scope at the program point(s) where the Splitter
is intended to operate.)  The automatically generated Splitter source
code fails to compile (but Daikon proceeds without it) if a variable
name in a condition is not found at the matching program point.
</p>
<p>An indented lines beginning with &lsquo;<samp>DAIKON_FORMAT</samp>&rsquo;,
&lsquo;<samp>JAVA_FORMAT</samp>&rsquo;, &lsquo;<samp>ESC_FORMAT</samp>&rsquo;, or &lsquo;<samp>SIMPLIFY_FORMAT</samp>&rsquo;
specifies how to print the condition.
These are optional; for any Daikon output format that is omitted,
the Java condition itself is used.
The alternate printed representation is used when the
splitting condition is used as a dummy
invariant; see configuration option
<samp>daikon.split.PptSplitter.dummy_invariant_level</samp>.
</p>

<hr>
<a name="Replacement-sections"></a>
<div class="header">
<p>
Previous: <a href="#Program-point-sections" accesskey="p" rel="previous">Program point sections</a>, Up: <a href="#Splitter-info-file-format" accesskey="u" rel="up">Splitter info file format</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Replacement-sections-1"></a>
<h4 class="subsubsection">6.2.1.2 Replacement sections</h4>

<p>Ordinarily, a splitting condition may not invoke user-defined methods,
because when Daikon reads data trace files, it does not have access to the
program source.  A replace section of the splitter info file can specify
the bodies of methods, permitting conditions to invoke those methods.  The
format is as follows:
</p><div class="example">
<pre class="example">REPLACE
<var>procedure1</var>
<var>replacement1</var>
<var>procedure2</var>
<var>replacement2</var>
...
</pre></div>

<p>where <var>replacementi</var> is a Java expression for the body
of <var>procedurei</var>.  In each condition, Daikon replaces procedure
calls by their replacements.  A replace section may appear anywhere in
the splitter info file.
</p>
<hr>
<a name="Indiscriminate-splitting"></a>
<div class="header">
<p>
Next: <a href="#Example-splitter-info-file" accesskey="n" rel="next">Example splitter info file</a>, Previous: <a href="#Splitter-info-file-format" accesskey="p" rel="previous">Splitter info file format</a>, Up: <a href="#Conditional-invariants" accesskey="u" rel="up">Conditional invariants</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Indiscriminate-splitting-1"></a>
<h4 class="subsection">6.2.2 Indiscriminate splitting</h4>

<p>Each condition in an <samp>.spinfo</samp> is associated with a program point.
The condition can be used at only that program point
by placing the following line in a file that is
passed to Daikon via the <samp>--config</samp> flag
(see <a href="Running-Daikon.html#Daikon-configuration-options">Daikon configuration options</a>):
</p><div class="example">
<pre class="example">daikon.split.SplitterList.all_splitters = false
</pre></div>

<p>The default, called <em>indiscriminate splitting</em>, is to use every
condition at every
program point, regardless of where in the <samp>.spinfo</samp> file the
condition appeared.
</p>
<p>The advantage of indiscriminate splitting is that a condition that is
useful at one program point may also be useful at another &mdash; if the
same variables are in scope or other variables of the same name are in
scope.
The disadvantage of indiscriminate splitting is that it slows Daikon down.
</p>
<p>Daikon uses a condition only where it can be used.  For example, the
condition <code>myArray.length == x</code> is applicable only at program points
that have variables named <code>myArray</code> and <code>x</code>.  To see
warnings about places a splitting condition cannot be used (reported as
failure to compile splitters at those locations), place the following line
in a file that is passed to Daikon via the <samp>--config</samp> flag
(see <a href="Running-Daikon.html#Daikon-configuration-options">Daikon configuration options</a>):
</p><div class="example">
<pre class="example">daikon.split.SplitterList.all_splitters_errors = true
</pre></div>


<hr>
<a name="Example-splitter-info-file"></a>
<div class="header">
<p>
Previous: <a href="#Indiscriminate-splitting" accesskey="p" rel="previous">Indiscriminate splitting</a>, Up: <a href="#Conditional-invariants" accesskey="u" rel="up">Conditional invariants</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Example-splitter-info-file-1"></a>
<h4 class="subsection">6.2.3 Example splitter info file</h4>

<p>Below is an implementation of a simple Queue for positive integers and
a corresponding <samp>.spinfo</samp> file.  The splitter info file is like
the one that <code>CreateSpinfo</code> would create for that class, but
also demonstrates some other features.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Example-class" accesskey="1">Example class</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Resulting-_002espinfo-file" accesskey="2">Resulting .spinfo file</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Example-class"></a>
<div class="header">
<p>
Next: <a href="#Resulting-_002espinfo-file" accesskey="n" rel="next">Resulting .spinfo file</a>, Up: <a href="#Example-splitter-info-file" accesskey="u" rel="up">Example splitter info file</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Example-class-1"></a>
<h4 class="subsubsection">6.2.3.1 Example class</h4>

<div class="smallexample">
<pre class="smallexample">class simpleStack {

  private int[] myArray;
  private int currentSize;

  public simpleStack(int capacity) {
    myArray = new int[capacity];
    currentSize = 0;
  }

  /** Adds an element to the back of the stack, if the stack is
    * not full.
    * Returns true if this succeeds, false otherwise.  */
  public String push(int x) {
    if ( !isFull() &amp;&amp; x &gt;= 0) {
      myArray[currentSize] = x;
      currentSize++;
      return true;
    } else {
      return false;
    }
  }

  /** Returns the most recently inserted stack element.
    * Returns -1 if the stack is empty. */
  public int pop() {
    if ( !isEmpty() ) {
      currentSize--;
      return myArray[currentSize];
    } else {
      return -1;
    }
  }

 /** Returns true if the stack is empty, false otherwise. */
  private boolean isEmpty() {
    return (currentSize == 0);
  }

  /** Returns true if the stack is full, false otherwise. */
  private boolean isFull() {
    return (currentSize == myArray.length);
  }
}
</pre></div>

<hr>
<a name="Resulting-_002espinfo-file"></a>
<div class="header">
<p>
Previous: <a href="#Example-class" accesskey="p" rel="previous">Example class</a>, Up: <a href="#Example-splitter-info-file" accesskey="u" rel="up">Example splitter info file</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Resulting-_002espinfo-file-1"></a>
<h4 class="subsubsection">6.2.3.2 Resulting .spinfo file</h4>

<div class="smallexample">
<pre class="smallexample">REPLACE
isFull()
currentSize == myArray.length
isEmpty()
currentSize == 0

PPT_NAME  simpleStack.push
!isFull() &amp;&amp; x &gt;= 0
    DAIKON_FORMAT !isFull() and x &gt;= 0
    SIMPLIFY_FORMAT (AND (NOT (isFull this)) (&gt;= x 0))

PPT_NAME  simpleStack.pop
!isEmpty()

PPT_NAME  simpleStack.isFull
currentSize == myArray.length - 1

PPT_NAME  simpleStack.isEmpty
currentSize == 0
</pre></div>

<hr>
<a name="Enhancing-conditional-invariant-detection"></a>
<div class="header">
<p>
Next: <a href="#Dynamic-abstract-type-inference-_0028DynComp_0029" accesskey="n" rel="next">Dynamic abstract type inference (DynComp)</a>, Previous: <a href="#Conditional-invariants" accesskey="p" rel="previous">Conditional invariants</a>, Up: <a href="#Enhancing-Daikon-output" accesskey="u" rel="up">Enhancing Daikon output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Enhancing-conditional-invariant-detection-1"></a>
<h3 class="section">6.3 Enhancing conditional invariant detection</h3>

<p>The built-in mechanisms (see <a href="#Conditional-invariants">Conditional invariants</a>) have
limitations in the invariants they can find.  By supplying splitting
conditions to Daikon via a splitter info file, the user can infer more
conditional invariants.  To ease this task, there are methods to
automatically create splitter info files for use by Daikon.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Static-analysis-for-splitters" accesskey="1">Static analysis for splitters</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Cluster-analysis-for-splitters" accesskey="2">Cluster analysis for splitters</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Random-selection-for-splitters" accesskey="3">Random selection for splitters</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="Static-analysis-for-splitters"></a>
<div class="header">
<p>
Next: <a href="#Cluster-analysis-for-splitters" accesskey="n" rel="next">Cluster analysis for splitters</a>, Up: <a href="#Enhancing-conditional-invariant-detection" accesskey="u" rel="up">Enhancing conditional invariant detection</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Static-analysis-for-splitters-1"></a>
<h4 class="subsection">6.3.1 Static analysis for splitters</h4>

<a name="index-splitting-conditions_002c-static-analysis"></a>
<a name="index-static-analysis-for-splitters"></a>
<a name="index-CreateSpinfo"></a>
<a name="index-CreateSpinfoC"></a>

<p>In static analysis, all boolean statements in the program
source are extracted and used as splitting conditions.  The assumption is that
conditions that are explicitly tested in the program are likely to affect the
program&rsquo;s behavior and could lead to useful conditional invariants.
The simple heuristic of using
these conditional statements as predicates for conditional invariant
detection is often quite effective.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Static-analysis-of-Java-for-splitters" accesskey="1">Static analysis of Java for splitters</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Static-analysis-of-C-for-splitters" accesskey="2">Static analysis of C for splitters</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="Static-analysis-of-Java-for-splitters"></a>
<div class="header">
<p>
Next: <a href="#Static-analysis-of-C-for-splitters" accesskey="n" rel="next">Static analysis of C for splitters</a>, Up: <a href="#Static-analysis-for-splitters" accesskey="u" rel="up">Static analysis for splitters</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Static-analysis-of-Java-for-splitters-1"></a>
<h4 class="subsubsection">6.3.1.1 Static analysis of Java for splitters</h4>

<p>The <code>CreateSpinfo</code> program takes Java source code as input and creates a
splitter info file for each Java file; for instance,
</p><div class="example">
<pre class="example">java daikon.tools.jtb.CreateSpinfo Foo.java Bar.java
</pre></div>

<p>creates the splitter info files <samp>Foo.spinfo</samp> and
<samp>Bar.spinfo</samp>.
Given an <samp>-o <var>filename</var></samp> argument, <code>CreateSpinfo</code> puts all the
splitters in the specified file instead.
The resulting splitter info file(s) contains each
boolean expression that appears in the source code.
</p>
<p>If you get an error such as
</p><div class="example">
<pre class="example">jtb.ParseException: Encountered &quot;;&quot; at line 253, column 8.
Was expecting one of: &quot;abstract&quot; ...
</pre></div>

<p>then you may have encountered a bug in the JTB library on which
<code>CreateSpinfo</code> is built.  It does not permit empty declarations in a
class body.  Remove the extra semicolon in your Java file (at the
indicated position) and re-rerun <code>CreateSpinfo</code>.
</p>

<hr>
<a name="Static-analysis-of-C-for-splitters"></a>
<div class="header">
<p>
Previous: <a href="#Static-analysis-of-Java-for-splitters" accesskey="p" rel="previous">Static analysis of Java for splitters</a>, Up: <a href="#Static-analysis-for-splitters" accesskey="u" rel="up">Static analysis for splitters</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Static-analysis-of-C-for-splitters-1"></a>
<h4 class="subsubsection">6.3.1.2 Static analysis of C for splitters</h4>

<p>The <code>CreateSpinfoC</code> program performs the same function for
C source code as <code>CreateSpinfoC</code> does for Java.
<code>CreateSpinfoC</code> can only be run on postprocessed source
files&mdash;that is, source files contain no <code>CPP</code> commands.  <code>CPP</code> commands
are lines starting with &lsquo;<samp>#</samp>&rsquo;, such as &lsquo;<samp>#include</samp>&rsquo;.  To
expand <code>CPP</code> commands into legal C, run either <code>cpp -P</code> or
<code>gcc -P -E</code>.  For instance, here is how you could use <code>CreateSpinfoC</code>:
</p><div class="example">
<pre class="example">cpp -P foo.c foo.c-expanded
cpp -P bar.c bar.c-expanded
java daikon.tools.jtb.CreateSpinfoC \
     foo.c-expanded bar.c-expanded
</pre></div>

<p>WARNING:  The names produced by <code>CreateSpinfoC</code> sometimes differ
from the names produced by Kvasir.  For example, suppose you have a C
file that contains a function &lsquo;<samp>foo</samp>&rsquo;.  Then <code>CreateSpinfoC</code>
may create a <samp>.spinfo</samp> file that mentions a program point named
&lsquo;<samp>std.foo</samp>&rsquo;, whereas Kvasir creates a <samp>.dtrace</samp> file that
mentions a program point named &lsquo;<samp>..foo</samp>&rsquo;.  Such a mismatch will cause
Daikon to produce no conditional invariants for the given program point.
This is a bug that needs to be fixed!  (Patches are welcome.)  In the
meanwhile, you can edit the generated <samp>.spinfo</samp> file to conform to the
<samp>.dtrace</samp> file&rsquo;s naming conventions.
</p>
<p>If you get an error such as
</p><div class="example">
<pre class="example">... Lexical error at line 5, column 1.
Encountered: &quot;#&quot; (35), after : &quot;&quot;
</pre></div>

<p>then you forgot to run <code>CPP</code> before running <code>CreateSpinfoC</code>.
</p>
<p>If you get an error such as
</p><div class="example">
<pre class="example">CreateSpinfoC encountered errors during parse.
Encountered &quot;__extension__ typedef struct {  ...
</pre></div>

<p>then your program uses non-standard C syntax.  The &lsquo;<samp>__extension__</samp>&rsquo;
keyword is supported only by the <code>GCC</code> compiler, and isn&rsquo;t handled by
the <code>CreateSpinfoC</code> program.  You could extend the <code>CreateSpinfoC</code> program
to handle non-standard <code>GCC</code> extensions, or you could remove non-standard
<code>GCC</code> extensions from your program.  The extensions might also result from
standard libraries rather than your own program &mdash; removing a
directives such as &lsquo;<samp>#include &lt;stdio.h&gt;</samp>&rsquo; when preprocessing may also
resolve the problem.
</p>

<hr>
<a name="Cluster-analysis-for-splitters"></a>
<div class="header">
<p>
Next: <a href="#Random-selection-for-splitters" accesskey="n" rel="next">Random selection for splitters</a>, Previous: <a href="#Static-analysis-for-splitters" accesskey="p" rel="previous">Static analysis for splitters</a>, Up: <a href="#Enhancing-conditional-invariant-detection" accesskey="u" rel="up">Enhancing conditional invariant detection</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Cluster-analysis-for-splitters-1"></a>
<h4 class="subsection">6.3.2 Cluster analysis for splitters</h4>

<a name="index-splitting-conditions_002c-cluster-analysis"></a>
<a name="index-cluster-analysis-for-splitters"></a>
<a name="index-runcluster_002epl-program"></a>

<p>Cluster analysis is a statistical method that finds groups or clusters
in data.  The clusters may indicate conditional properties in the
program.  The
cluster analysis mechanism finds clusters in the data trace file,
infers invariants over any clusters that it finds, and writes these
invariants into a splitter info file.
Then, you supply the splitter info file to Daikon in order to
infer conditional invariants.
</p>
<p>To find splitting conditions using cluster analysis, run the
<code>runcluster.pl</code> program (found in the <samp>$DAIKONDIR/scripts</samp>
directory) in the following way:
</p><div class="example">
<pre class="example">runcluster.pl [<var>options</var>] <var>dtrace_file ...</var> <var>decls_files ...</var>
</pre></div>

<p>The <var>options</var> are:
</p><dl compact="compact">
<dd>
<a name="index-kmeans-cluster-analysis"></a>
<a name="index-hierarchical-cluster-analysis"></a>
<a name="index-xm-cluster-analysis"></a>
</dd>
<dt><samp>-a <var>ALG</var></samp></dt>
<dt><samp>--algorithm <var>ALG</var></samp></dt>
<dd><p><var>ALG</var> specifies a clustering algorithm.
Current options are &lsquo;<samp>km</samp>&rsquo; (for kmeans), &lsquo;<samp>hierarchical</samp>&rsquo;,
and &lsquo;<samp>xm</samp>&rsquo; (for xmeans).  The default is &lsquo;<samp>xm</samp>&rsquo;.
</p>
</dd>
<dt><samp>-k</samp></dt>
<dd><p>The number of clusters to use (for algorithms which require
this input, which is everything except xmeans).  The default is 4.
</p>
</dd>
<dt><samp>--keep</samp></dt>
<dd><p>Don&rsquo;t delete the temporary files created by the clustering
process.  This is a debugging flag.
</p></dd>
</dl>

<p>The <code>runcluster.pl</code> script currently supports three clustering
programs.  They are implementations of the kmeans algorithm,
hierarchical clustering, and the xmeans algorithm (kmeans algorithm
with efficient discovery of the number of clusters).  The kmeans and
hierarchical clustering tools are provided in the Daikon
distribution.  The xmeans code and executable are publicly available at
<a href="http://www.cs.cmu.edu/~dpelleg/kmeans.html">http://www.cs.cmu.edu/~dpelleg/kmeans.html</a> (fill in the license
form and mail it in).
</p>
<hr>
<a name="Random-selection-for-splitters"></a>
<div class="header">
<p>
Previous: <a href="#Cluster-analysis-for-splitters" accesskey="p" rel="previous">Cluster analysis for splitters</a>, Up: <a href="#Enhancing-conditional-invariant-detection" accesskey="u" rel="up">Enhancing conditional invariant detection</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Random-selection-for-splitters-1"></a>
<h4 class="subsection">6.3.3 Random selection for splitters</h4>

<a name="index-splitting-conditions_002c-random-selection"></a>
<a name="index-random-selection-for-splitters"></a>
<a name="index-TraceSelect-tool"></a>

<p>Random selection can create representative samples of a data set with
the added benefit of finding conditional properties and eliminating
outliers.  Given trace data, the <code>TraceSelect</code> tool creates several
small subsets of the data by randomly selecting parts of the original
trace file.  Any invariant that is discovered in the smaller samples but
not found over the entire data is a conditional invariant.
</p>
<p>To find splitting conditions using random selection, run the
<code>daikon.tools.TraceSelect</code> program in the following way:
</p><div class="example">
<pre class="example">java daikon.tools.TraceSelect <var>num_reps</var> <var>sample_size</var> [<var>options</var>] \
    <var>dtrace_file</var> <var>decls_files ...</var> [<var>daikon_options</var>]
</pre></div>

<p><var>num_reps</var> is the number of subsets to create, and <var>sample_size</var> is the
number of invocations to collect for each method.
</p>
<p>The <var>daikon_options</var> are the same options that can be provided to the
<code>daikon.Daikon</code> program.
</p>
<p>The <var>options</var> for <code>TraceSelect</code> are:
</p><dl compact="compact">
<dt><samp>-NOCLEAN</samp></dt>
<dd><p>Don&rsquo;t delete the temporary trace samples created by the random
selection process.  This can help for debugging or for using the tool
solely to create trace samples instead of calculating invariants over
the samples.
</p>
</dd>
<dt><samp>-INCLUDE_UNRETURNED</samp></dt>
<dd><p>Allows random selection to choose method invocations that entered the
method successfully but did not exit normally; either from a thrown
Exception or abnormal termination.
</p>
</dd>
<dt><samp>-DO_DIFFS</samp></dt>
<dd><p>Creates an <samp>.spinfo</samp> file for generating conditional invariants and
implications by reporting the invariants that appear in at least one
of the samples but not over the entire data set.
</p>
</dd>
</dl>

<hr>
<a name="Dynamic-abstract-type-inference-_0028DynComp_0029"></a>
<div class="header">
<p>
Next: <a href="#Loop-invariants" accesskey="n" rel="next">Loop invariants</a>, Previous: <a href="#Enhancing-conditional-invariant-detection" accesskey="p" rel="previous">Enhancing conditional invariant detection</a>, Up: <a href="#Enhancing-Daikon-output" accesskey="u" rel="up">Enhancing Daikon output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Dynamic-abstract-type-inference-_0028DynComp_0029-1"></a>
<h3 class="section">6.4 Dynamic abstract type inference (DynComp)</h3>

<p>Abstract types group variables that are used for related purposes in a
program.
For example, suppose that some <code>int</code> variables in your program
are array indices, and other <code>int</code> variables
represent time.  Even though these variables have the same type
(<code>int</code>) in the programming language, they have different abstract
types.
</p>
<p>Abstract types can be provided as input to Daikon, so that it
only infers invariants between values of the same abstract type.
This has two benefits.
First, it improves Daikon&rsquo;s performance, often by over an order of magnitude,
because it reduces
the number of potential invariants that must be checked.
Second, it reduces spurious output caused by invariants over unrelated variables.
You are strongly recommended to supply abstract types when running Daikon;
Daikon does not produce satisfactory output without abstract type information.
</p>
<p>Abstract type inference is performed by the front-ends, before Daikon runs.
The Daikon distribution includes three tools that
infer abstract types (also called comparability types) from program
executions.
</p>
<ul>
<li> The Java DynComp tool produces a comparability file that must then be
supplied to the Chicory Java front-end.  For examples of using DynComp
with Java programs, see <a href="Example-usage.html#Detecting-invariants-in-Java-programs">Detecting invariants in Java programs</a>.  For
full details about the DynComp tool for Java, see <a href="Front-ends-_0028instrumentation_0029.html#DynComp-for-Java">DynComp for Java</a>.

</li><li> The Kvasir front-end for C/C++ binaries by default uses a DynComp mode in which it
produces a separate <samp>.decls</samp> file containing comparability
information, which must be supplied to Daikon along with the
<samp>.dtrace</samp> file.  For examples of using DynComp with C programs, see
<a href="Example-usage.html#C-examples">C examples</a>.  For full details about the DynComp
tool for C/C++, see <a href="Front-ends-_0028instrumentation_0029.html#DynComp-for-C_002fC_002b_002b">DynComp for C/C++</a>.

</li><li> The Celeriac front-end for .NET programs can compute variable
comparability.  It does so statically by examining the program text, rather
than dynamically by running the program as DynComp does.
For full details about variable comparability in Celeriac, see
<a href="https://github.com/codespecs/daikon-dot-net-front-end">https://github.com/codespecs/daikon-dot-net-front-end</a>.

</li></ul>

<hr>
<a name="Loop-invariants"></a>
<div class="header">
<p>
Previous: <a href="#Dynamic-abstract-type-inference-_0028DynComp_0029" accesskey="p" rel="previous">Dynamic abstract type inference (DynComp)</a>, Up: <a href="#Enhancing-Daikon-output" accesskey="u" rel="up">Enhancing Daikon output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Loop-invariants-1"></a>
<h3 class="section">6.5 Loop invariants</h3>

<a name="index-loop-invariants"></a>
<a name="index-local-variables-1"></a>

<p>Daikon does not by default output loop invariants.  Daikon can detect
invariants at any location where it is provided with variable values,
but currently Daikon&rsquo;s front ends do not supply Daikon with variable values
at loop heads.
</p>
<p>You could extend a front end to output more variable values, or you
could write a new front end.
</p>
<p>Alternately, here is a way to use the current front ends to produce loop
invariants.  This workaround requires you to change your program, but it
requires no change to Daikon or its front ends.
</p>
<p>At the top of a loop (or at any other location in the program at which
you would like to obtain invariants), insert a call to a dummy procedure
that does no work but returns immediately.  Pass, as arguments to the
dummy procedure, all variables of interest (including local variables).
Daikon will produce (identical) preconditions and postconditions for the
dummy procedure; these are properties that held at the call site.
</p>
<p>For instance, you might change the original code
</p><div class="example">
<pre class="example">  public void calculate(int x) {
    int tmp = 0;
    while (x &gt; 0) {
      // you desire to compute an invariant here
      tmp=tmp+x;
      x=x-1;
    }
  }
</pre></div>

<p>into
</p><div class="example">
<pre class="example">  public void calculate(int x) {
    int tmp = 0;
    while (x &gt; 0) {
      calculate_loophead(x, tmp);
      tmp=tmp+x;
      x=x-1;
    }
  }

  // dummy procedure
  public void calculate_loophead(int x, int tmp) {
  }
</pre></div>


<hr>
<div class="header">
<p>
Previous: <a href="#Dynamic-abstract-type-inference-_0028DynComp_0029" accesskey="p" rel="previous">Dynamic abstract type inference (DynComp)</a>, Up: <a href="#Enhancing-Daikon-output" accesskey="u" rel="up">Enhancing Daikon output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
