<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head><link rel="icon" href="../daikon-favicon.png" type="image/png"/>
<title>The Daikon Invariant Detector User Manual: Example usage</title>

<meta name="description" content="The Daikon Invariant Detector User Manual: Example usage">
<meta name="keywords" content="The Daikon Invariant Detector User Manual: Example usage">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="General-Index.html#General-Index" rel="index" title="General Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="index.html#Top" rel="up" title="Top">
<link href="Running-Daikon.html#Running-Daikon" rel="next" title="Running Daikon">
<link href="Installing-Daikon.html#Cygwin-shell" rel="previous" title="Cygwin shell">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Example-usage"></a>
<div class="header">
<p>
Next: <a href="Running-Daikon.html#Running-Daikon" accesskey="n" rel="next">Running Daikon</a>, Previous: <a href="Installing-Daikon.html#Installing-Daikon" accesskey="p" rel="previous">Installing Daikon</a>, Up: <a href="index.html#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Example-usage-for-Java_002c-C_002fC_002b_002b_002c-C_0023_002fF_0023_002fVisual-Basic_002c-Perl_002c-and-Eiffel"></a>
<h2 class="chapter">3 Example usage for Java, C/C++, C#/F#/Visual Basic, Perl, and Eiffel</h2>

<p>Detecting invariants involves two steps:
</p><ol>
<li> Obtain one or more data trace files by running your program under the control of a
front end (also known as an instrumenter or tracer) that records information about
variable values.  You can run your program over one or more inputs of your own
choosing, such as regression tests or a typical user input session.
You may choose to obtain trace data for only part of
your program; this can avoid inundating you with
output, and can also improve performance.

</li><li> Run the Daikon invariant detector over the data trace files
(see <a href="Running-Daikon.html#Running-Daikon">Running Daikon</a>).  This detects invariants in the recorded
information.  You can view the invariants textually, or process them
with a variety of tools.
</li></ol>

<p>This section briefly describes how to obtain data traces for Java, C,
C#, Perl, and Eiffel programs, and how to run Daikon.  For detailed
information about these and other front ends that are available for
Daikon, see <a href="Front-ends-_0028instrumentation_0029.html#Front-ends-_0028instrumentation_0029">Front ends (instrumentation)</a>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Detecting-invariants-in-Java-programs" accesskey="1">Detecting invariants in Java programs</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Detecting-invariants-in-C_002fC_002b_002b-programs" accesskey="2">Detecting invariants in C/C++ programs</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Detecting-invariants-in-C_0023-programs" accesskey="3">Detecting invariants in C# programs</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Detecting-invariants-in-Perl-programs" accesskey="4">Detecting invariants in Perl programs</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Detecting-invariants-in-Eiffel-programs" accesskey="5">Detecting invariants in Eiffel programs</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Detecting-invariants-in-Simulink_002fStateflow-programs" accesskey="6">Detecting invariants in Simulink/Stateflow programs</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Detecting-invariants-in-Java-programs"></a>
<div class="header">
<p>
Next: <a href="#Detecting-invariants-in-C_002fC_002b_002b-programs" accesskey="n" rel="next">Detecting invariants in C/C++ programs</a>, Up: <a href="#Example-usage" accesskey="u" rel="up">Example usage</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Detecting-invariants-in-Java-programs-1"></a>
<h3 class="section">3.1 Detecting invariants in Java programs</h3>

<p>In order to detect invariants in a Java program, you will run the program
twice &mdash; once using DynComp (see <a href="Front-ends-_0028instrumentation_0029.html#DynComp-for-Java">DynComp for Java</a>) to create a
<samp>.decls</samp> file and once using Chicory (see <a href="Front-ends-_0028instrumentation_0029.html#Chicory">Chicory</a>) to create a
data trace file.
Then, run Daikon on the data trace file to detect invariants.
With the <samp>--daikon</samp> option to Chicory, a single command performs
the last two steps.
</p>
<p>For example, if you usually run
</p><div class="example">
<pre class="example">java mypackage.MyClass arg1 arg2 arg3
</pre></div>

<p>then instead you would run
</p><div class="example">
<pre class="example">java daikon.DynComp mypackage.MyClass arg1 arg2 arg3
java daikon.Chicory --daikon \
                    --comparability-file=MyClass.decls-DynComp \
                    mypackage.MyClass arg1 arg2 arg3
</pre></div>

<p>and the Daikon output is written to the terminal.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#StackAr-example" accesskey="1">StackAr example</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Detecting-invariants-when-running-a-Java-program-from-a-jar-file" accesskey="2">Detecting invariants when running a Java program from a jar file</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Understanding-the-invariants" accesskey="3">Understanding the invariants</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Second-Java-example" accesskey="4">Second Java example</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>



<hr>
<a name="StackAr-example"></a>
<div class="header">
<p>
Next: <a href="#Detecting-invariants-when-running-a-Java-program-from-a-jar-file" accesskey="n" rel="next">Detecting invariants when running a Java program from a jar file</a>, Up: <a href="#Detecting-invariants-in-Java-programs" accesskey="u" rel="up">Detecting invariants in Java programs</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="StackAr-example-1"></a>
<h4 class="subsection">3.1.1 StackAr example</h4>

<p>The Daikon distribution contains some sample programs that will help
you get practice in running Daikon.
</p>
<p>To detect invariants in the <samp>StackAr</samp> sample program, perform the
following steps after installing Daikon (see <a href="Installing-Daikon.html#Installing-Daikon">Installing Daikon</a>).
</p>
<ol>
<li> Compile the program with the <samp>-g</samp> switch to enable debugging
symbols.  (The program and test suite appear in the
<samp>DataStructures</samp> subdirectory.)
<div class="example">
<pre class="example">cd examples/java-examples/StackAr
javac -g DataStructures/*.java
</pre></div>

</li><li> Run the program under the control of DynComp to generate comparability
information in the file <samp>StackArTester.decls-DynComp</samp>.

<div class="example">
<pre class="example">java -cp .:$CLASSPATH daikon.DynComp DataStructures.StackArTester
</pre></div>

<p>If you have not yet set the CLASSPATH, you may add it to the command
line for now &mdash; but don&rsquo;t forget to set it later.
</p>
<div class="smallexample">
<pre class="smallexample">java -cp &quot;../../../daikon.jar:.&quot; daikon.DynComp DataStructures.StackArTester
</pre></div>

</li><li> Run the program a second time, under the control of the Chicory front end.
Chicory observes the variable values and passes the information to Daikon.
Daikon infers invariants, prints them, and writes a binary representation
of them to file <samp>StackArTester.inv.gz</samp>.

<div class="example">
<pre class="example">java -cp .:$CLASSPATH daikon.Chicory --daikon \
     --comparability-file=StackArTester.decls-DynComp \
     DataStructures.StackArTester
</pre></div>


<p>Alternately, replacing the <samp>--daikon</samp> argument by
<samp>--daikon-online</samp> has the same effect, but does not write a data
trace file to disk.
</p>
</li></ol>

<p>If you wish to have more control over the invariant detection process,
you can split the third step above into multiple steps.  Then, step 3
would become:
</p>
<ol>
<li> Run the program under the control of the Chicory front end
in order to create a trace file named
<samp>StackArTester.dtrace.gz</samp>.

<div class="example">
<pre class="example">java -cp .:$CLASSPATH daikon.Chicory \
     --comparability-file=StackArTester.decls-DynComp \
     DataStructures.StackArTester
</pre></div>

</li><li> Run Daikon on the trace file.

<div class="example">
<pre class="example">java daikon.Daikon StackArTester.dtrace.gz
</pre></div>
<p>(Note the classpath (<samp>-cp</samp>) argument is not needed as we are not
running the <code>StackArTester</code> program.)
</p>
<p>Daikon can analyze multiple runs (executions) of the program.  You can
supply Daikon with multiple trace files:
</p>
<div class="smallexample">
<pre class="smallexample">java daikon.Chicory --dtrace-file=StackArTester1.dtrace.gz \
     --comparability-file=StackArTester.decls-DynComp DataStructures.StackArTester
java daikon.Chicory --dtrace-file=StackArTester2.dtrace.gz \
     --comparability-file=StackArTester.decls-DynComp DataStructures.StackArTester
java daikon.Chicory --dtrace-file=StackArTester3.dtrace.gz \
     --comparability-file=StackArTester.decls-DynComp DataStructures.StackArTester
java daikon.Daikon StackArTester*.dtrace.gz
</pre></div>


<p>(In this example, all the runs are identical, so multiple runs yield the
same invariants as one run.)
</p>
</li><li> Examine the invariants.  (They were also printed to standard out
by the previous step.)

<p>There are various ways to do this.
</p><ul>
<li> Examine the output from running Daikon.  (You may find it
convenient to capture the output in a file; add &lsquo;<samp>&gt; StackAr.txt</samp>&rsquo;
to the end of the command that runs Daikon.)

</li><li> Use the <code>PrintInvariants</code> program to display the invariants.

<div class="example">
<pre class="example">java daikon.PrintInvariants StackArTester.inv.gz
</pre></div>

<p>For more options to the <code>PrintInvariants</code> program, see <a href="Tools.html#Printing-invariants">Printing invariants</a>.
</p>
</li><li> Use the Annotate program to insert the invariants as comments
into the Java source program.

<div class="example">
<pre class="example">cd ..
java daikon.tools.jtb.Annotate StackArTester.inv.gz \
     DataStructures/StackAr.java
</pre></div>

<p>(Here and elsewhere in the manual, the continuation character &lsquo;<samp>\</samp>&rsquo; is
used to split a long command across lines.  Windows uses the &lsquo;<samp>^</samp>&rsquo;
character instead.)
</p>
<p>Now examine file <samp>DataStructures/StackAr.java-escannotated</samp>.
For more information about the Annotate program, see <a href="Tools.html#Annotate">Annotate</a>.
</p>

</li></ul>
</li></ol>


<hr>
<a name="Detecting-invariants-when-running-a-Java-program-from-a-jar-file"></a>
<div class="header">
<p>
Next: <a href="#Understanding-the-invariants" accesskey="n" rel="next">Understanding the invariants</a>, Previous: <a href="#StackAr-example" accesskey="p" rel="previous">StackAr example</a>, Up: <a href="#Detecting-invariants-in-Java-programs" accesskey="u" rel="up">Detecting invariants in Java programs</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Detecting-invariants-when-running-a-Java-program-from-a-jar-file-1"></a>
<h4 class="subsection">3.1.2 Detecting invariants when running a Java program from a jar file</h4>

<p>If your Java program is run directly from a <samp>jar</samp> file,
such as either of:
</p>
<div class="example">
<pre class="example">java mypackage.jar arguments
java -cp &lt;originalclasspath&gt; mypackage.jar arguments
</pre></div>

<p>then to detect invariants in that Java program,
run these commands:
</p>
<div class="example">
<pre class="example">java -cp mypackage.jar:&lt;original classpath&gt; daikon.DynComp &lt;MyMain&gt; arguments
java -cp mypackage.jar:&lt;original classpath&gt; daikon.Chicory --daikon \
     --comparability-file=&lt;MyMain&gt;.decls-DynComp &lt;MyMain&gt; arguments
</pre></div>

<p>where <code>&lt;MyMain&gt;</code> is the Main-class of the <samp>jar</samp> file, which you
can determine by running the command:
</p>
<div class="example">
<pre class="example">unzip -p mypackage.jar META-INF/MANIFEST.MF | grep '^Main-Class:'
</pre></div>


<hr>
<a name="Understanding-the-invariants"></a>
<div class="header">
<p>
Next: <a href="#Second-Java-example" accesskey="n" rel="next">Second Java example</a>, Previous: <a href="#Detecting-invariants-when-running-a-Java-program-from-a-jar-file" accesskey="p" rel="previous">Detecting invariants when running a Java program from a jar file</a>, Up: <a href="#Detecting-invariants-in-Java-programs" accesskey="u" rel="up">Detecting invariants in Java programs</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Understanding-the-invariants-1"></a>
<h4 class="subsection">3.1.3 Understanding the invariants</h4>

<p>This section examines some of the invariants for the <samp>StackAr</samp> example.
For more help interpreting invariants, see <a href="Daikon-output.html#Interpreting-output">Interpreting output</a>.
</p>
<p>The <samp>StackAr</samp> example is an array-based stack implementation.  Take a
look at <samp>DataStructures/StackAr.java</samp> to get a sense of the
implementation.  Now, look at the sixth section of Daikon output.
</p>
<div class="example">
<pre class="example">======================================================================
StackAr:::OBJECT
this.theArray != null
this.theArray.getClass().getName() == java.lang.Object[].class
this.topOfStack &gt;= -1
this.topOfStack &lt;= size(this.theArray[])-1
======================================================================
</pre></div>

<p>These four annotations describe the representation invariant.  The
array is never null, and its runtime type is <code>Object[]</code>.  The
<code>topOfStack</code> index is at least -1 and is less than the length
of the array.
</p>
<p>Next, look at the invariants for the <code>top()</code> method.
<code>top()</code> has two different exit points, at lines 74 and 75
in the original source.  There is a set of invariants for each exit
point, as well as a set of invariants that hold for all exit points.
Look at the invariants when <code>top()</code> returns at line 75.
</p>
<div class="example">
<pre class="example">======================================================================
StackAr.top():::EXIT75
return == this.theArray[this.topOfStack]
return == this.theArray[orig(this.topOfStack)]
return == orig(this.theArray[post(this.topOfStack)])
return == orig(this.theArray[this.topOfStack])
this.topOfStack &gt;= 0
return != null
======================================================================
</pre></div>

<p>The return value is never null, and is equal to the array element at
index <code>topOfStack</code>.  The top of the stack is at least 0.
</p>
<hr>
<a name="Second-Java-example"></a>
<div class="header">
<p>
Previous: <a href="#Understanding-the-invariants" accesskey="p" rel="previous">Understanding the invariants</a>, Up: <a href="#Detecting-invariants-in-Java-programs" accesskey="u" rel="up">Detecting invariants in Java programs</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="A-second-Java-example"></a>
<h4 class="subsection">3.1.4 A second Java example</h4>

<p>A second example is located in the <samp>examples/java-examples/QueueAr</samp> subdirectory.
Run this sample using the following steps:
</p>
<ul>
<li> Compile
<div class="example">
<pre class="example">cd examples/java-examples/QueueAr
javac -g DataStructures/*.java
</pre></div>

</li><li> Trace file generation and invariant detection
<div class="example">
<pre class="example">java -cp .:$CLASSPATH daikon.DynComp DataStructures.QueueArTester
java -cp .:$CLASSPATH daikon.Chicory --daikon \
     --comparability-file=QueueArTester.decls-DynComp \
     DataStructures.QueueArTester
</pre></div>

</li></ul>

<p>Alternately, you can split the very last command into two parts:
</p>
<ul>
<li> Trace file generation
<div class="example">
<pre class="example">java -cp .:$CLASSPATH daikon.Chicory \
     --comparability-file=QueueArTester.decls-DynComp \
     DataStructures.QueueArTester
</pre></div>

</li><li> Invariant detection
<div class="example">
<pre class="example">java daikon.Daikon QueueArTester.dtrace.gz
</pre></div>

</li></ul>



<hr>
<a name="Detecting-invariants-in-C_002fC_002b_002b-programs"></a>
<div class="header">
<p>
Next: <a href="#Detecting-invariants-in-C_0023-programs" accesskey="n" rel="next">Detecting invariants in C# programs</a>, Previous: <a href="#Detecting-invariants-in-Java-programs" accesskey="p" rel="previous">Detecting invariants in Java programs</a>, Up: <a href="#Example-usage" accesskey="u" rel="up">Example usage</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Detecting-invariants-in-C_002fC_002b_002b-programs-1"></a>
<h3 class="section">3.2 Detecting invariants in C/C++ programs</h3>

<p>In order to detect invariants over C or C++ programs, you must first install
a C/C++ front end (instrumenter).  We recommend that you use Kvasir (see <a href="Front-ends-_0028instrumentation_0029.html#Kvasir">Kvasir</a>),
and this section gives examples using Kvasir.
By default, Kvasir also runs the DynComp tool
to improve Daikon&rsquo;s performance and Daikon&rsquo;s output by filtering out invariants
involving unrelated variables (see <a href="Front-ends-_0028instrumentation_0029.html#DynComp-for-C_002fC_002b_002b">DynComp for C/C++</a>).
</p>
<p>To use the C/C++ front end Kvasir with your program, first make sure that
your program has been compiled with DWARF-2 format debugging
information, such as by giving the <samp>-gdwarf-2</samp> flag to <code>GCC</code> when
compiling.  Then, run your program as usual, but prepend
<code>kvasir-dtrace</code> to the command line.
</p>
<p>Kvasir will produce two output files:
a <samp>.dtrace</samp> file containing a trace of a particular execution,
and a <samp>.decls</samp> file that contains
information about what variables and functions exist in a program, along
with information grouping the variables into abstract types.
You will supply both of these files to Daikon.
</p>
<p>For more information about Kvasir, including more detailed
documentation on its command-line options, see <a href="Front-ends-_0028instrumentation_0029.html#Kvasir">Kvasir</a>.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#C-examples" accesskey="1">C examples</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Dealing-with-large-examples" accesskey="2">Dealing with large examples</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="C-examples"></a>
<div class="header">
<p>
Next: <a href="#Dealing-with-large-examples" accesskey="n" rel="next">Dealing with large examples</a>, Up: <a href="#Detecting-invariants-in-C_002fC_002b_002b-programs" accesskey="u" rel="up">Detecting invariants in C/C++ programs</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="C-examples-1"></a>
<h4 class="subsection">3.2.1 C examples</h4>

<p>The Daikon distribution comes with several example C programs
to enable users to become familiar with running Daikon on C programs.
These examples are located in the <samp>examples/c-examples</samp> directory.
</p>


<p>To detect invariants for a program with Kvasir, you need to perform
two basic tasks:  run the program under Kvasir to create a trace
and declaration files (steps 1&ndash;3), and run
Daikon over these files to produce invariants (step 4).
The following instructions are for the wordplay example, which is a
program for finding anagrams.
</p>
<ol>
<li> Change to the directory containing the program.
<div class="example">
<pre class="example">cd $DAIKONDIR/examples/c-examples/wordplay
</pre></div>

</li><li> Compile the program with DWARF-2 debugging information enabled
(and all optimizations disabled).
<div class="example">
<pre class="example">gcc -gdwarf-2 wordplay.c -o wordplay
</pre></div>

<p>Kvasir can also be used for programs constructed by compiling a number
of <samp>.c</samp> files separately, and then linking them together; in such
a program, specify <samp>-gdwarf-2</samp> when compiling each source file
containing code you wish to see invariants about.
</p>
</li><li> Run the program just as you normally would, but prepend
<code>kvasir-dtrace</code> to the command line.

<div class="example">
<pre class="example">kvasir-dtrace ./wordplay -f words.txt 'Daikon Dynamic Invariant Detector'
</pre></div>

<p>Any options to the program can be specified as usual; here, for
instance, we give commands to look for anagrams of the phrase &ldquo;Daikon
Dynamic Invariant Detector&rdquo; using words from the file <samp>words.txt</samp>.
</p>
<p>Executing under Kvasir, the program runs normally, but Kvasir
executes additional checks and collects trace information (for this
reason, the program will run more slowly than usual).  Kvasir creates a
directory named <samp>daikon-output</samp> under the current directory, and
creates the <samp>wordplay.dtrace</samp> file, which lists variable
values, and the <samp>wordplay.decls</samp> file that contains
information about what variables and functions exist in a program, along
with information grouping the variables into abstract types.
</p>
<p>Kvasir will also print messages if it observes your program doing
something with undefined effects; these may indicate bugs in your
program, or they may be spurious.  (If they are bugs, they can also be
tracked down by using Valgrind (<a href="http://www.valgrind.org/">http://www.valgrind.org/</a>)
with its regular memory checking
tool; if they do not appear with that tool, they are probably
spurious).
</p>
</li><li> Run Daikon on the trace and declaration files.
<div class="smallexample">
<pre class="smallexample">java daikon.Daikon \
     --config_option daikon.derive.Derivation.disable_derived_variables=true \
     daikon-output/wordplay.decls daikon-output/wordplay.dtrace
</pre></div>

<p>The invariants are printed to standard output, and a binary representation
of the invariants is written to <samp>wordplay.inv.gz</samp>.  Note that the
example uses a configuration option to disable the use of derived
variables; it can also run without that option, but takes significantly
longer.
</p>
<p>Daikon can analyze multiple runs (executions) of the program.  You can
supply Daikon with multiple trace files:
</p>
<div class="smallexample">
<pre class="smallexample">kvasir-dtrace --dtrace-file=daikon-output/wordplay1.dtrace \
    ./wordplay -f words.txt 'daikon dynamic invariant detector'
kvasir-dtrace --no-dyncomp --dtrace-file=daikon-output/wordplay2.dtrace \
    ./wordplay -f words.txt 'better results from multiple runs'
kvasir-dtrace --no-dyncomp --dtrace-file=daikon-output/wordplay3.dtrace \
    ./wordplay -f words.txt 'more testing equals better testing'
java -Xmx256m daikon.Daikon daikon-output/wordplay*.dtrace daikon-output/wordplay.decls
</pre></div>

<p>Note that this example makes the assumption that the DynComp <samp>.decls</samp> information
for <code>wordplay</code> does not vary from run to run.
Thus it specifies <samp>--no-dyncomp</samp> on subsequent runs to improve performance.
(This assumption may not be true for other programs.)
</p>
<p>Alternatively, you can append information from multiple runs in a single trace file:
</p>
<div class="smallexample">
<pre class="smallexample">kvasir-dtrace --dtrace-file=daikon-output/wordplay-all.dtrace \
    ./wordplay -f words.txt 'daikon dynamic invariant detector'
kvasir-dtrace --no-dyncomp --dtrace-append \
    --dtrace-file=daikon-output/wordplay-all.dtrace \
    ./wordplay -f words.txt 'better results from multiple runs'
kvasir-dtrace --no-dyncomp --dtrace-append \
    --dtrace-file=daikon-output/wordplay-all.dtrace \
    ./wordplay -f words.txt 'more testing equals better testing'
java -Xmx256m daikon.Daikon daikon-output/wordplay-all.dtrace daikon-output/wordplay.decls
</pre></div>

</li><li> Examine the invariants.  As described in <a href="#StackAr-example">StackAr example</a>,
there are several ways to do this:
<ul>
<li> Examine the output from running Daikon.
</li><li> Use the <code>PrintInvariants</code> program to display the invariants.
</li></ul>

<p>For help understanding the invariants, see <a href="Daikon-output.html#Interpreting-output">Interpreting output</a>.
</p>
</li></ol>

<p>There is a second example C program in the <samp>bzip2</samp> directory.
It may be run in a similar fashion as the <samp>wordplay</samp> example,
but it is a more complex program and the <code>kvasir-dtrace</code>
step may take several minutes.
</p>


<hr>
<a name="Dealing-with-large-examples"></a>
<div class="header">
<p>
Previous: <a href="#C-examples" accesskey="p" rel="previous">C examples</a>, Up: <a href="#Detecting-invariants-in-C_002fC_002b_002b-programs" accesskey="u" rel="up">Detecting invariants in C/C++ programs</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Dealing-with-large-examples-1"></a>
<h4 class="subsection">3.2.2 Dealing with large examples</h4>

<p>Since the default memory size used by a Java virtual machine varies, we
suggest that Daikon be run with at least 256 megabytes of
memory (and perhaps much more), specified for many JVMs by the option <samp>-Xmx256m</samp>.
For more information about specifying the memory usage for Daikon, see
<a href="Troubleshooting.html#Out-of-memory">Out of memory</a>.
</p>
<p>Disk usage can be reduced by specifying that the front end should
compress its output <samp>.dtrace</samp> files.
</p>
<p>In some cases, the time and space requirements of the examples can be
reduced by reducing the length of the program run.
However, Daikon&rsquo;s running time
depends on both the length of the test run and the size of the program
data (such as its use of global variables and nested data
structures).
The examples also demonstrate disabling derived variables, which
significantly improves Daikon&rsquo;s performance at the cost of producing
fewer invariants.
For more techniques for using Daikon with large programs
and long program runs, see <a href="Troubleshooting.html#Large-dtrace-files">Large dtrace files</a>.
</p>


<hr>
<a name="Detecting-invariants-in-C_0023-programs"></a>
<div class="header">
<p>
Next: <a href="#Detecting-invariants-in-Perl-programs" accesskey="n" rel="next">Detecting invariants in Perl programs</a>, Previous: <a href="#Detecting-invariants-in-C_002fC_002b_002b-programs" accesskey="p" rel="previous">Detecting invariants in C/C++ programs</a>, Up: <a href="#Example-usage" accesskey="u" rel="up">Example usage</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Detecting-invariants-in-C_0023_002c-F_0023_002c-and-Visual-Basic-programs"></a>
<h3 class="section">3.3 Detecting invariants in C#, F#, and Visual Basic programs</h3>

<p>The Daikon front end for .NET languages (C#, F#, and Visual Basic) is
called Celeriac.
</p>
<p>Please see its documentation at
<a href="https://github.com/codespecs/daikon-dot-net-front-end">https://github.com/codespecs/daikon-dot-net-front-end</a>.
</p>

<hr>
<a name="Detecting-invariants-in-Perl-programs"></a>
<div class="header">
<p>
Next: <a href="#Detecting-invariants-in-Eiffel-programs" accesskey="n" rel="next">Detecting invariants in Eiffel programs</a>, Previous: <a href="#Detecting-invariants-in-C_0023-programs" accesskey="p" rel="previous">Detecting invariants in C# programs</a>, Up: <a href="#Example-usage" accesskey="u" rel="up">Example usage</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Detecting-invariants-in-Perl-programs-1"></a>
<h3 class="section">3.4 Detecting invariants in Perl programs</h3>

<p>The Daikon front end for Perl is called <code>dfepl</code>.
</p>
<p>Using the Perl front end is a two-pass
process: first you must run the annotated program so that the runtime
system can dynamically infer the kind of data stored in each variable,
and then you must re-annotate and re-run the program with the added
type information.
This is necessary because Perl programs do not contain type declarations.
</p>
<p><code>dfepl</code> requires version 5.8 or later of Perl.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Instrumenting-Perl-programs" accesskey="1">Instrumenting Perl programs</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Perl-examples" accesskey="2">Perl examples</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="Instrumenting-Perl-programs"></a>
<div class="header">
<p>
Next: <a href="#Perl-examples" accesskey="n" rel="next">Perl examples</a>, Up: <a href="#Detecting-invariants-in-Perl-programs" accesskey="u" rel="up">Detecting invariants in Perl programs</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Instrumenting-Perl-programs-1"></a>
<h4 class="subsection">3.4.1 Instrumenting Perl programs</h4>

<p>Perl programs must be instrumented twice.  First they must be
instrumented without type information.  Then, once the first
instrumented version has been run to produce type information, they
must be instrumented again taking the type information into account.
</p>
<p>To instrument a stand-alone Perl program, invoke <code>dfepl</code> with
the name of the program as an argument.
</p>
<div class="example">
<pre class="example">dfepl program.pl
</pre></div>

<p>To instrument a Perl module or a collection of modules, invoke
<code>dfepl</code> either with the name of each module, or with the name
of a directory containing the modules.  To instrument all the modules
in the current directory, give <code>dfepl</code> the argument <samp>.</samp>.
For instance, if the current directory contains a module
<code>Acme::Trampoline</code> in <samp>Acme/Trampoline.pm</samp> and another
module <code>Acme::Date</code> in <samp>Acme/Date.pm</samp>, they can be annotated
by either of the following two commands:
</p>
<div class="example">
<pre class="example">dfepl Acme/Trampoline.pm Acme/Date.pm
dfepl .
</pre></div>

<p>Once type information is available, run the instrumentation command
again with the <samp>-T</samp> or <samp>-t</samp> options added to use the
produced type information.
</p>
<p>For more information about <code>dfepl</code>, see <a href="Front-ends-_0028instrumentation_0029.html#dfepl">dfepl</a>.
</p>

<hr>
<a name="Perl-examples"></a>
<div class="header">
<p>
Previous: <a href="#Instrumenting-Perl-programs" accesskey="p" rel="previous">Instrumenting Perl programs</a>, Up: <a href="#Detecting-invariants-in-Perl-programs" accesskey="u" rel="up">Detecting invariants in Perl programs</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Perl-examples-1"></a>
<h4 class="subsection">3.4.2 Perl examples</h4>

<p>The Daikon distribution includes sample Perl programs suitable for use
with Daikon in the <samp>examples/perl-examples</samp> directory.
</p>
<p>Here are step-by-step instructions for examining a simple module,
<samp>Birthday.pm</samp>, as used by a test script <samp>test-bday.pl</samp>.
</p>
<ol>
<li> Change to the directory containing the <samp>Birthday.pm</samp>
module.
<div class="example">
<pre class="example">cd examples/perl-examples
</pre></div>

</li><li> Instrument the <samp>Birthday.pm</samp> file.
<div class="example">
<pre class="example">dfepl Birthday.pm
</pre></div>

<p>This command creates a directory <samp>daikon-untyped</samp>, and puts
the instrumented version of <samp>Birthday.pm</samp> into
<samp>daikon-untyped/Birthday.pm</samp>.  As the directory name implies, this
instrumented version doesn&rsquo;t contain type information.
</p>
</li><li> Run a test suite using the instrumented <samp>Birthday.pm</samp>
file.
<div class="example">
<pre class="example">dtype-perl test_bday.pl 10
</pre></div>

<p>The <samp>dtype-perl</samp> is a script that runs Perl with the appropriate
command line options to find the modules used by the Daikon Perl
runtime tracing modules, and to use the instrumented versions of
modules in <samp>daikon-untyped</samp> in preference to their original
ones.  The number 10 is an argument to the <samp>test_bday.pl</samp> script
telling it to run a relatively short test.
</p>
<p>This will also generate a file
<samp>daikon-instrumented/Birthday.types</samp> recording the type of each
variable seen during the execution of the instrumented program.
</p>
</li><li> Re-annotate the module using the type information.
<div class="example">
<pre class="example">dfepl -T Birthday.pm
</pre></div>

<p>This step repeats step 2, except that the <samp>-T</samp> flag to
<code>dfepl</code> tells it to use the type information generated in the
previous step, and to put the output in the directory
<samp>daikon-instrumented</samp>.  <code>dfepl</code> also converts the
type information into a file <samp>daikon-output/Birthday.decls</samp>
containing subroutine declarations suitable for Daikon.
</p>
</li><li> Run the full test suite with the type-instrumented
<samp>Birthday.pm</samp>.
<div class="example">
<pre class="example">dtrace-perl test_bday.pl 30
</pre></div>

<p>Here we run another test suite, which happens to be the same
<samp>test_bday.pl</samp>, but running for longer. (The example will also
work with a smaller number).  The script <code>dtrace-perl</code> is
similar to <code>dtype-perl</code> mentioned earlier, but looks for
instrumented source files in <samp>daikon-instrumented</samp>.
</p>
<p>This creates <samp>daikon-output/test_bday-combined.dtrace</samp>, a trace
file containing the values of variables at each invocation. (The
filename is formed from the name of the test program, with
<samp>-combined</samp> appended because it contains the trace information
from all the instrumented modules invoked from the program).
</p>
</li><li> Change to the <samp>daikon-output</samp> directory to analyze the
output.
<div class="example">
<pre class="example">cd daikon-output
</pre></div>

</li><li> Run Daikon on the trace file
<div class="example">
<pre class="example">java daikon.Daikon Birthday.decls test_bday-combined.dtrace
</pre></div>

</li><li> Examine the invariants.  They are printed to standard output, and
they are also saved to file <samp>Birthday.inv.gz</samp>, which you can
manipulate with the <code>PrintInvariants</code> program and other Daikon tools.
For example:
<div class="example">
<pre class="example">java daikon.PrintInvariants Birthday.inv.gz
</pre></div>

<p>Invariants produced from Perl programs can be examined using the same
tools as other Daikon invariants.
</p></li></ol>

<p>In the example above, the script <samp>test_bday.pl</samp> was not itself
instrumented; it was only used to test the instrumented code.  The
Perl front end can also be used to instrument stand-alone Perl
programs.  The following sequence of commands, similar to those above,
show how Daikon can be used with the stand-alone program
<samp>standalone.pl</samp>, also in the <samp>examples/perl-examples</samp>
directory.
</p>
<div class="example">
<pre class="example">dfepl standalone.pl
dtype-perl daikon-untyped/standalone.pl
dfepl -T standalone.pl
dtrace-perl daikon-instrumented/standalone.pl
cd daikon-output
java daikon.Daikon -o standalone.inv standalone-main.decls \
     standalone-combined.dtrace
</pre></div>

<p>Note two differences when running a stand-alone program.  First, the
instrumented versions of the program, in the <samp>daikon-untyped</samp> or
<samp>daikon-instrumented</samp> directory, are run directly.  Second, the
declarations file is named after the package in which the subroutines
were declared, but since every stand-alone program uses the
<code>main</code> package, the name of the program is prepended to the
<samp>.decls</samp> file name to avoid collisions.
</p>

<hr>
<a name="Detecting-invariants-in-Eiffel-programs"></a>
<div class="header">
<p>
Next: <a href="#Detecting-invariants-in-Simulink_002fStateflow-programs" accesskey="n" rel="next">Detecting invariants in Simulink/Stateflow programs</a>, Previous: <a href="#Detecting-invariants-in-Perl-programs" accesskey="p" rel="previous">Detecting invariants in Perl programs</a>, Up: <a href="#Example-usage" accesskey="u" rel="up">Example usage</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Detecting-invariants-in-Eiffel-programs-1"></a>
<h3 class="section">3.5 Detecting invariants in Eiffel programs</h3>

<p>CITADEL is an Eiffel front-end to the Daikon invariant detector.
You can obtain Citadel from
<a href="http://se.inf.ethz.ch/people/polikarpova/citadel/">http://se.inf.ethz.ch/people/polikarpova/citadel/</a>.
</p>

<hr>
<a name="Detecting-invariants-in-Simulink_002fStateflow-programs"></a>
<div class="header">
<p>
Previous: <a href="#Detecting-invariants-in-Eiffel-programs" accesskey="p" rel="previous">Detecting invariants in Eiffel programs</a>, Up: <a href="#Example-usage" accesskey="u" rel="up">Example usage</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Detecting-invariants-in-Simulink_002fStateflow-programs-1"></a>
<h3 class="section">3.6 Detecting invariants in Simulink/Stateflow programs</h3>

<p>Hynger (HYbrid iNvariant GEneratoR) instruments Simulink/Stateflow (SLSF)
block diagrams to generate Daikon input (<samp>.dtrace</samp> files).  Hynger was created
by Taylor Johnson, Stanley Bak, and Steven Drager.  You can obtain Hynger
from <a href="https://bitbucket.org/verivital/hynger">https://bitbucket.org/verivital/hynger</a>.
</p>

<hr>
<div class="header">
<p>
Previous: <a href="#Detecting-invariants-in-Eiffel-programs" accesskey="p" rel="previous">Detecting invariants in Eiffel programs</a>, Up: <a href="#Example-usage" accesskey="u" rel="up">Example usage</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
