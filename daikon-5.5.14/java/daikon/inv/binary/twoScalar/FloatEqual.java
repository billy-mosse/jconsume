// ***** This file is automatically generated from IntComparisons.java.jpp

package daikon.inv.binary.twoScalar;

import daikon.*;
import daikon.derive.binary.*;
import daikon.derive.unary.*;
import daikon.inv.*;
import daikon.inv.binary.twoScalar.*;
import daikon.inv.binary.twoSequence.*;
import daikon.inv.unary.scalar.*;
import daikon.inv.unary.sequence.*;
import daikon.inv.unary.string.*;
import daikon.suppress.*;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import plume.*;

/*>>>
import org.checkerframework.checker.interning.qual.*;
import org.checkerframework.checker.lock.qual.*;
import org.checkerframework.checker.nullness.qual.*;
import org.checkerframework.dataflow.qual.*;
import typequals.*;
*/

/**
 * Represents an invariant of == between two double scalars. Prints as {@code x == y}.
 */
public final class FloatEqual extends TwoFloat implements Comparison {

  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /** Boolean. True iff FloatEqual invariants should be considered. */
  public static boolean dkconfig_enabled = Invariant.invariantEnabledDefault;

  public static final Logger debug = Logger.getLogger("daikon.inv.binary.twoScalar.FloatEqual");

  protected FloatEqual(PptSlice ppt) {
   super(ppt);
  }

  protected /*@Prototype*/ FloatEqual() {
   super();
  }

  private static /*@Prototype*/ FloatEqual proto = new /*@Prototype*/ FloatEqual();

  /** Returns the prototype invariant for FloatEqual */
  public static /*@Prototype*/ FloatEqual get_proto() {
    return proto;
  }

  /** Returns whether or not this invariant is enabled */
  public boolean enabled() {
    return dkconfig_enabled;
  }

  /** Returns whether or not the specified var types are valid for FloatEqual */
  public boolean instantiate_ok(VarInfo[] vis) {

    if (!valid_types(vis)) {
      return false;
    }

      return true;
  }

  /** Instantiate an invariant on the specified slice */
  protected FloatEqual instantiate_dyn(/*>>> @Prototype FloatEqual this,*/ PptSlice slice) {

    return new FloatEqual(slice);
  }

  /*@Pure*/
  public boolean is_equality_inv() {
    return true;
  }

  protected Invariant resurrect_done_swapped() {

      // we don't care if things swap; we have symmetry
      return this;
  }

  /*@Pure*/
  public boolean is_symmetric() {
    return true;
  }

  // JHP: this should be removed in favor of checks in PptTopLevel
  // such as is_equal, is_lessequal, etc.
  // Look up a previously instantiated FloatEqual relationship.
  // Should this implementation be made more efficient?
  public static /*@Nullable*/ FloatEqual find(PptSlice ppt) {
    assert ppt.arity() == 2;
    for (Invariant inv : ppt.invs) {
      if (inv instanceof FloatEqual) {
        return (FloatEqual) inv;
      }
    }

    // If the invariant is suppressed, create it
    if ((suppressions != null) && suppressions.suppressed(ppt)) {
      FloatEqual inv = proto.instantiate_dyn(ppt);
      // System.out.printf ("%s is suppressed in ppt %s%n", inv.format(), ppt.name());
      return inv;
    }

    return null;
  }

  public String repr(/*>>>@GuardSatisfied FloatEqual this*/) {
    return "FloatEqual" + varNames();
  }

  /*@SideEffectFree*/
  public String format_using(/*>>>@GuardSatisfied FloatEqual this,*/ OutputFormat format) {

    String var1name = var1().name_using(format);
    String var2name = var2().name_using(format);

    if ((format == OutputFormat.DAIKON) || (format == OutputFormat.ESCJAVA)) {
      String comparator = "==";
      return var1name + " " + comparator + " " + var2name;
    }

    if (format == OutputFormat.CSHARPCONTRACT) {

        String comparator = "==";
        return var1name + " " + comparator + " " + var2name;
    }

    if (format.isJavaFamily()) {

        return Invariant.formatFuzzy("eq", var1(), var2(), format);

    }

    if (format == OutputFormat.SIMPLIFY) {

        String comparator = "EQ";

      return "("
          + comparator
          + " "
          + var1().simplifyFixup(var1name)
          + " "
          + var2().simplifyFixup(var2name)
          + ")";
    }

    return format_unimplemented(format);
  }

  public InvariantStatus check_modified(double v1, double v2, int count) {
    if (!((Global.fuzzy.eq(v1, v2)))) {
      return InvariantStatus.FALSIFIED;
    }
    return InvariantStatus.NO_CHANGE;
  }

  public InvariantStatus add_modified(double v1, double v2, int count) {
    if (logDetail() || debug.isLoggable(Level.FINE)) {
      log(
          debug,
          "add_modified (" + v1 + ", " + v2 + ",  ppt.num_values = " + ppt.num_values() + ")");
    }
    if ((logOn() || debug.isLoggable(Level.FINE))
        && check_modified(v1, v2, count) == InvariantStatus.FALSIFIED)
      log(debug, "destroy in add_modified (" + v1 + ", " + v2 + ",  " + count + ")");

    return check_modified(v1, v2, count);
  }

  // This is very tricky, because whether two variables are equal should
  // presumably be transitive, but it's not guaranteed to be so when using
  // this method and not dropping out all variables whose values are ever
  // missing.
  protected double computeConfidence() {
    // Should perhaps check number of samples and be unjustified if too few
    // samples.

      // We MUST check if we have seen samples; otherwise we get
      // undesired transitivity with missing values.
      if (ppt.num_samples() == 0) {
        return Invariant.CONFIDENCE_UNJUSTIFIED;
      }

      // It's an equality invariant.  I ought to use the actual ranges somehow.
      // Actually, I can't even use this .5 test because it can make
      // equality non-transitive.
      // return Math.pow(.5, num_values());
      return Invariant.CONFIDENCE_JUSTIFIED;

  }

  public boolean enoughSamples(/*>>>@GuardSatisfied FloatEqual this*/) {
    return (ppt.num_samples() > 0);
  }

  // For Comparison interface
  public double eq_confidence() {
    if (isExact()) {
      return getConfidence();
    } else {
      return Invariant.CONFIDENCE_NEVER;
    }
  }

  /*@Pure*/
  public boolean isExact() {

      return true;
  }

  // // Temporary, for debugging
  // public void destroy() {
  //   if (debug.isLoggable(Level.FINE)) {
  //     System.out.println("FloatEqual.destroy(" + ppt.name() + ")");
  //     System.out.println(repr());
  //     (new Error()).printStackTrace();
  //   }
  //   super.destroy();
  // }

  public InvariantStatus add(
      /*@Interned*/ Object v1, /*@Interned*/ Object v2, int mod_index, int count) {
    if (debug.isLoggable(Level.FINE)) {
      debug.fine(
          "FloatEqual"
          + ppt.varNames()
          + ".add("
          + v1
          + ","
          + v2
          + ", mod_index="
          + mod_index
          + "), count="
          + count
          + ")");
    }
    return super.add(v1, v2, mod_index, count);
  }

  /*@Pure*/
  public boolean isSameFormula(Invariant other) {
    return true;
  }

  /*@Pure*/
  public boolean isExclusiveFormula(Invariant other) {

    // Also ought to check against LinearBinary, etc.

      if ((other instanceof FloatLessThan)
          || (other instanceof FloatGreaterThan)
          || (other instanceof FloatNonEqual)) {
        return true;
      }

    return false;
  }

  @Override
  public /*@Nullable*/ DiscardInfo isObviousStatically(VarInfo[] vis) {
    final VarInfo var1 = vis[0];
    final VarInfo var2 = vis[1];

    // If A.minvalue==A.maxvalue==B.minvalue==B.maxvalue, then
    // there's nothing to see here.
    if (var1.aux.hasValue(VarInfoAux.MINIMUM_VALUE)
        && var1.aux.hasValue(VarInfoAux.MAXIMUM_VALUE)
        && var2.aux.hasValue(VarInfoAux.MINIMUM_VALUE)
        && var2.aux.hasValue(VarInfoAux.MAXIMUM_VALUE)) {
      @SuppressWarnings("keyfor")   // needs EnsuresQualifier
      int minA = var1.aux.getInt(VarInfoAux.MINIMUM_VALUE),
          maxA = var1.aux.getInt(VarInfoAux.MAXIMUM_VALUE),
          minB = var2.aux.getInt(VarInfoAux.MINIMUM_VALUE),
          maxB = var2.aux.getInt(VarInfoAux.MAXIMUM_VALUE);

      if (minA == maxA && maxA == minB && minB == maxB) {
        return new DiscardInfo(
            this, DiscardCode.obvious, var1.name() + " == " + var2.name() + " is already known");
      }
    }

    return super.isObviousStatically(vis);
  }

  /**
   * Since this invariant can be a postProcessed equality, we have to handle isObvious especially to
   * avoid circular isObvious relations. We only check if this.ppt.var_infos imply obviousness
   * rather than the cartesian product on the equality set.
   */
  /*@Pure*/
  public /*@Nullable*/ DiscardInfo isObviousStatically_SomeInEquality() {
    if (var1().equalitySet == var2().equalitySet) {
      return isObviousStatically(this.ppt.var_infos);
    } else {
      return super.isObviousStatically_SomeInEquality();
    }
  }

  /**
   * Since this invariant can be a postProcessed equality, we have to handle isObvious especially to
   * avoid circular isObvious relations. We only check if this.ppt.var_infos imply obviousness
   * rather than the cartesian product on the equality set.
   */
  /*@Pure*/
  public /*@Nullable*/ DiscardInfo isObviousDynamically_SomeInEquality() {
    if (var1().equalitySet == var2().equalitySet) {
      return isObviousDynamically(this.ppt.var_infos);
    } else {
      return super.isObviousDynamically_SomeInEquality();
    }
  }

  /*@Pure*/
  public /*@Nullable*/ DiscardInfo isObviousDynamically(VarInfo[] vis) {

    // JHP: We might consider adding a check over bounds.   If
    // x < c and y > c then we know that x < y.  Similarly for
    // x > c and y < c.  We could also substitute oneof for
    // one or both of the bound checks.

    DiscardInfo super_result = super.isObviousDynamically(vis);
    if (super_result != null) {
      return super_result;
    }

    VarInfo var1 = vis[0];
    VarInfo var2 = vis[1];

      // a+c=b+c is implied, because a=b must have also been reported.
      if (var1.is_add() && var2.is_add() && (var1.get_add_amount() == var2.get_add_amount()))
        return new DiscardInfo(
            this, DiscardCode.obvious,
            "Invariants of the form a+c==b+c are implied since a==b is reported.");

    DiscardInfo di = null;

      // Check for the same invariant over enclosing arrays
      di = pairwise_implies(vis);
      if (di != null) {
        return di;
      }

      // Check for size(A[]) == Size(B[]) where A[] == B[]
      di = array_eq_implies(vis);
      if (di != null) {
        return di;
      }

    { // Sequence length tests
      SequenceLength sl1 = null;
      if (var1.isDerived() && (var1.derived instanceof SequenceLength)) {
        sl1 = (SequenceLength) var1.derived;
      }
      SequenceLength sl2 = null;
      if (var2.isDerived() && (var2.derived instanceof SequenceLength)) {
        sl2 = (SequenceLength) var2.derived;
      }

      // "size(a)-1 cmp size(b)-1" is never even instantiated;
      // use "size(a) cmp size(b)" instead.

      // This might never get invoked, as equality is printed out specially.
      VarInfo s1 = (sl1 == null) ? null : sl1.base;
      VarInfo s2 = (sl2 == null) ? null : sl2.base;
      if ((s1 != null) && (s2 != null) && (s1.equalitySet == s2.equalitySet)) {
        // lengths of equal arrays being compared
        String n1 = var1.name();
        String n2 = var2.name();
        return new DiscardInfo(
            this,
            DiscardCode.obvious,
            n1 + " and " + n2 + " are equal arrays, so equal size is implied");
      }

    }

    return null;
  } // isObviousDynamically

  /**
   * If both variables are subscripts and the underlying arrays have the same invariant, then this
   * invariant is implied:
   *
   * <pre>(x[] op y[]) ^ (i == j) &rArr; (x[i] op y[j])</pre>
   */
  private /*@Nullable*/ DiscardInfo pairwise_implies(VarInfo[] vis) {

    VarInfo v1 = vis[0];
    VarInfo v2 = vis[1];

    // Make sure v1 and v2 are SequenceFloatSubscript with the same shift
    if (!v1.isDerived() || !(v1.derived instanceof SequenceFloatSubscript)) {
      return null;
    }
    if (!v2.isDerived() || !(v2.derived instanceof SequenceFloatSubscript)) {
      return null;
    }
    @SuppressWarnings("nullness") // checker bug in flow
    /*@NonNull*/ SequenceFloatSubscript der1 = (SequenceFloatSubscript) v1.derived;
    @SuppressWarnings("nullness") // checker bug in flow
    /*@NonNull*/ SequenceFloatSubscript der2 = (SequenceFloatSubscript) v2.derived;
    if (der1.index_shift != der2.index_shift) {
      return null;
    }

    // Make sure that the indices are equal
    if (!ppt.parent.is_equal(der1.sclvar().canonicalRep(), der2.sclvar().canonicalRep())) {
      return null;
    }

    // See if the same relationship holds over the arrays
    Invariant proto = PairwiseFloatEqual.get_proto();
    DiscardInfo di = ppt.parent.check_implied_canonical(this, der1.seqvar(), der2.seqvar(), proto);
    return di;
  }

  /**
   * If the equality is between two array size variables, check to see if the underlying arrays are
   * equal:
   *
   * <pre>(x[] = y[]) &rArr; size(x[]) = size(y[])</pre>
   */
  private /*@Nullable*/ DiscardInfo array_eq_implies(VarInfo[] vis) {

    // Make sure v1 and v2 are size(array) with the same shift
    VarInfo v1 = vis[0];
    if (!v1.isDerived() || !(v1.derived instanceof SequenceLength)) {
      return null;
    }
    VarInfo v2 = vis[1];
    if (!v2.isDerived() || !(v2.derived instanceof SequenceLength)) {
      return null;
    }
    assert v1.derived != null : "@AssumeAssertion(nullness): checker bug: flow";
    assert v2.derived != null : "@AssumeAssertion(nullness): checker bug: flow";
    if (!v1.derived.isSameFormula(v2.derived)) {
      return null;
    }

    VarInfo seqvar1 = v1.derived.getBase(0);
    VarInfo seqvar2 = v2.derived.getBase(0);
    if (ppt.parent.is_equal(seqvar1, seqvar2)) {
      return new DiscardInfo(
          this,
          DiscardCode.obvious,
          "Implied by "
              + seqvar1
              + " == "
              + seqvar2
              + " and "
              + var1()
              + " == "
              + v1
              + " and "
              + var2()
              + " == "
              + v2);
    }

    return null;
  }

  /** NI suppressions, initialized in get_ni_suppressions() */
  private static /*@Nullable*/ NISuppressionSet suppressions = null;

  /** Returns the non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    return null;
  }

}
