// ***** This file is automatically generated from FunctionBinary.java.jpp
// ***** (and files it recursively includes).

package daikon.inv.ternary.threeScalar;

import daikon.*;
import daikon.derive.unary.*;
import daikon.inv.*;
import daikon.inv.binary.twoScalar.*;
import daikon.inv.unary.scalar.*;
import daikon.suppress.*;
import java.lang.reflect.*;
import java.util.*;
import java.util.logging.Logger;
import plume.*;

/*>>>
import org.checkerframework.checker.lock.qual.*;
import org.checkerframework.checker.nullness.qual.*;
import org.checkerframework.dataflow.qual.*;
import typequals.*;
*/

/**
 * Base class for each of the FunctionBinary functions and permutatons. Most of the work is done
 * here. The subclasses basically define the function and return information describing the function
 * and permutation to these methods.
 */
public abstract class FunctionBinary extends ThreeScalar {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  /** Boolean. True if FunctionBinary invariants should be considered. */
  public static boolean dkconfig_enabled = false;

  public static Logger debug =
    Logger.getLogger("daikon.inv.ternary.threeScalar.#CLASSNAME");

  static final int[][] var_indices;
  static {
    var_indices = new int[7][];
    var_indices[1] = new int[] { 0, 1, 2 };
    var_indices[2] = new int[] { 1, 0, 2 };
    var_indices[3] = new int[] { 2, 0, 1 };
    var_indices[4] = new int[] { 0, 2, 1 };
    var_indices[5] = new int[] { 1, 2, 0 };
    var_indices[6] = new int[] { 2, 1, 0 };
  }

  protected FunctionBinary(PptSlice ppt) {
    super(ppt);
  }

  protected /*@Prototype*/ FunctionBinary() {
    super();
  }

  /** returns whether or not this invariant is enabled */
  public boolean enabled() {
    return dkconfig_enabled;
  }

  /** FunctionBinary is only valid on isIntegral() types */
  public boolean instantiate_ok(VarInfo[] vis) {

    if (!valid_types(vis)) {
      return false;
    }

    // Make sure that each variable is integral (not boolean or hashcode)
    if (!vis[0].file_rep_type.isIntegral()
        || !vis[1].file_rep_type.isIntegral()
        || !vis[2].file_rep_type.isIntegral())
      return false;

    return true;
  }

  // check_modified relies on func having no side effects.
  abstract long func(long arg1, long arg2);
  /*@Pure*/
  abstract boolean is_symmetric();
  abstract String[] get_method_name(/*>>>@GuardSatisfied FunctionBinary this*/);
  abstract int get_var_order(/*>>>@GuardSatisfied FunctionBinary this*/);
  abstract void set_function_id(int function_id);
  abstract int get_function_id();

  /**
   * Map from function name (eg, MultiplyLong, MinimumFloat) to an array of instances (one for each
   * valid permutation) for that function.
   */
  private static Map<String,/*@Prototype*/ FunctionBinary[]> functions = new LinkedHashMap<String,/*@Prototype*/ FunctionBinary[]>();

  /**
   * A list indexed by function number to an array of instances (one for each valid permutation) for
   * that function. The array is the same one as is stored in the functions Map. This provides a
   * faster access mechanism once we have the function id (which are calculated the first time
   * through).
   */
  private static List</*@Prototype*/ FunctionBinary[]> func_list = new ArrayList</*@Prototype*/ FunctionBinary[]>();

  private static void build_func_list() {

    // Reflection seems to confuse clover
    ///CLOVER:OFF

    // Build the map of functions to array of instances for that function
    debug.fine("Processing FunctionBinary");
    functions = new LinkedHashMap<String,/*@Prototype*/ FunctionBinary[]>();
    @SuppressWarnings("unchecked")
    Class</*@Prototype*/ FunctionBinary>[] subclasses = (Class</*@Prototype*/ FunctionBinary>[]) FunctionBinary.class.getDeclaredClasses();
    for (int ii = 0; ii < subclasses.length; ii++) {
      Class</*@Prototype*/ FunctionBinary> subc = subclasses[ii];
      String function = subc.getName();
      if (function.indexOf("CLOVER") >= 0) {
        continue;
      }
      function = function.replaceFirst(".*FunctionBinary\\$", "");
      function = function.replaceFirst("_.*", "");
      if (function.equals("SubClass")) {
        continue;
      }
      /*@Prototype*/ FunctionBinary[] fb_arr = functions.get(function);
      if (fb_arr == null) {
        fb_arr = new /*@Prototype*/ FunctionBinary[7];
        functions.put(function, fb_arr);
        func_list.add(fb_arr);
      }
      int func_id = func_list.indexOf(fb_arr);
      @SuppressWarnings({"nonprototype"})
      /*@Prototype*/ FunctionBinary fb;
      try {
        Constructor</*@Prototype*/ FunctionBinary> con = subc.getDeclaredConstructor(new Class<?>[] {});
        fb = con.newInstance(new Object[] {});
      }  catch (Exception e) {
        throw new Error(" can't create instance for " + subc.getName()
                        + ": '" + e + "' ii = " + ii);
      }
      assert fb_arr[fb.get_var_order()] == null;
      fb_arr[fb.get_var_order()] = fb;
      fb.set_function_id(func_id);
      debug.fine("Adding " + function + " " + fb.getClass().getName()
                  + " " + fb.get_var_order() + " " + fb.get_function_id());
    }
    ///CLOVER:ON
  }

  /** Returns a list of all of the FunctionBinary prototype invariants. */
  public static List</*@Prototype*/ Invariant> get_proto_all() {

    List</*@Prototype*/ Invariant> result = new ArrayList</*@Prototype*/ Invariant>();

    // If this is the first call
    if (functions.isEmpty()) {
      build_func_list();
    }

    // Get the proto invariant for all of the subclasses and return them
    for (/*@Prototype*/ FunctionBinary[] fb_arr : func_list) {
      for (int jj = 1; jj < fb_arr.length; jj++) {
        /*@Prototype*/ FunctionBinary fb = fb_arr[jj];
        if (fb != null) {
          result.add(fb);
        }
      }
    }
    return result;
  }

  /** Permuted result var. */
  public VarInfo resultVar() {
    return ppt.var_infos[var_indices[get_var_order()][0]];
  }

  /** Permuted arg1 var. */
  public VarInfo argVar1() {
    return ppt.var_infos[var_indices[get_var_order()][1]];
  }

  /** Permuted arg2 var. */
  public VarInfo argVar2() {
    return ppt.var_infos[var_indices[get_var_order()][2]];
  }

  /**
   * Apply the specified sample to the function, returning the result. The caller is responsible
   * for permuting the arguments.
   */
  public InvariantStatus check_ordered(long result, long arg1,
                                      long arg2, int count) {
    // This implementation relies on func having no side effects.
    try {
      if (!((result) == ( func(arg1, arg2)))) {
        return InvariantStatus.FALSIFIED;
      }
    } catch (Exception e) {
        return InvariantStatus.FALSIFIED;
    }
    return InvariantStatus.NO_CHANGE;
  }

  /**
   * Apply the specified sample to the function, returning the result. The caller is responsible
   * for permuting the arguments.
   */
  public InvariantStatus add_ordered(long result, long arg1,
                                      long arg2, int count) {
    return check_ordered(result, arg1, arg2, count);
  }

  /**
   * Reorganize our already-seen state as if the variables had shifted order underneath us
   * (re-arrangement given by the permutation). We accomplish this by returning the class that
   * corresponds to the the new permutation.
   */
  protected Invariant resurrect_done(int[] permutation) {

    assert permutation.length == 3;
    assert ArraysMDE.fn_is_permutation(permutation);

    int[] new_order = new int[3];
    int[] old_order = var_indices[get_var_order()];

    // "permutation" is a permutation on the var_info array. old_order
    // was the permutation that took the formatted invariant to the
    // var_info array, so old_order^-1 is the permutation from the
    // var_info array to the old formatted invariant. We want to find
    // a new_order so that when we first do "permutation", then
    // apply the new permutation from the var_info array to the
    // formatted invariant, we get the same formatted invariant.
    // What we want, then. is:
    //    new_order^-1 o permutation = old_order^-1
    // rearranging, this is equivalent to
    //    new_order = permutation o old_order
    new_order[0] = permutation[old_order[0]];
    new_order[1] = permutation[old_order[1]];
    new_order[2] = permutation[old_order[2]];

    // Force symmetric functions into a canonical form so that
    // we can match them when necessary and they always print the same.
    // For example, order of 0, 1, 2 and 0, 2, 1 represent the same
    // invariant for a symmetric function.  This forces them to always
    // be represented as 0, 1, 2
    if (is_symmetric()) {
      if (new_order[2] < new_order[1]) {
        int tmp = new_order[2];
        new_order[2] = new_order[1];
        new_order[1] = tmp;
      }
    }

    // Look for the new order in the list of possible orders
    int var_order = -1;
    for (int i = 0; i < var_indices.length; i++) {
      if (Arrays.equals(new_order, var_indices[i])) {
        var_order = i;
        break;
      }
    }
    assert var_order != -1;

    // If the var order hasn't changed, we don't need to do anything
    if (var_order == get_var_order()) {
      return this;
    }

    // Find the class that corresponds to the new order
    if (functions.isEmpty()) {
      build_func_list();
    }
    int func_id = get_function_id();
    /*@Prototype*/ FunctionBinary[] fb_arr = func_list.get(func_id);
    assert fb_arr != null;
    for (int ii = 0; ii < fb_arr.length; ii++)
      if ((fb_arr[ii] != null) && (fb_arr[ii].get_var_order() == var_order)) {
        return (fb_arr[ii].instantiate_dyn(ppt));
      }

    throw new Error("Could not find new ordering");
  }

  public String repr(/*>>>@GuardSatisfied FunctionBinary this*/) {
    return format();
  }

  /*@SideEffectFree*/
  public String format_using(/*>>>@GuardSatisfied FunctionBinary this,*/ OutputFormat format) {
    if (format == OutputFormat.SIMPLIFY) {
      return format_simplify();
    }
    if (format == OutputFormat.CSHARPCONTRACT) {
      return format_csharp_contract();
    }

    int var_order = get_var_order();
    String[] methodname = get_method_name();

    VarInfo argresultvi = ppt.var_infos[var_indices[var_order][0]];
    VarInfo arg1vi = ppt.var_infos[var_indices[var_order][1]];
    VarInfo arg2vi = ppt.var_infos[var_indices[var_order][2]];

    String argresult_name = argresultvi.name_using(format);
    String arg1_name = arg1vi.name_using(format);
    String arg2_name = arg2vi.name_using(format);

    if (format == OutputFormat.DAIKON) {
      return argresult_name + " == (" + methodname[0] + arg1_name
        + methodname[1] + arg2_name + methodname[2] + ")";
    }

    if (format.isJavaFamily()) {
      if (methodname[1].equals(" || ") || methodname[1].equals(" && ")) {
        return "(" +  argresult_name + " != 0) == ((" + methodname[0] + arg1_name + " != 0)"
          + methodname[1] + "(" + arg2_name + methodname[2] + " != 0))";
      } else {
        return argresult_name + " == (" + methodname[0] + arg1_name
          + methodname[1] + arg2_name + methodname[2] + ")";
      }
    }

    return format_unimplemented(format);
  }

  public String format_simplify(/*>>>@GuardSatisfied FunctionBinary this*/) {
    int var_order = get_var_order();
    String[] methodname = get_method_name();
    VarInfo[] vis = ppt.var_infos;

    String result = vis[var_indices[var_order][0]].simplifyFixedupName();
    String arg1 = vis[var_indices[var_order][1]].simplifyFixedupName();
    String arg2 = vis[var_indices[var_order][2]].simplifyFixedupName();
    String func = null;
    if (methodname[1].equals(" * ")) {
      func = "*";
    } else if (methodname[1].equals(" | ")) {
      func = "|java-bitwise-or|";
    } else if (methodname[1].equals(" || ")) {
      func = "|java-logical-or|";
    } else if (methodname[1].equals(", ")) {
      if (methodname[0].equals("java.lang.Math.min("))
        func = "min";
      else if (methodname[0].equals("java.lang.Math.max("))
        func = "max";
      else if (methodname[0].equals("plume.MathMDE.gcd("))
        func = "gcd";
      else if (methodname[0].equals("java.lang.Math.pow("))
        func = "pow";
      else if (methodname[0].equals("plume.MathMDE.logicalXor("))
        func = "|java-logical-xor|";
    } else {
      assert methodname[0].equals("");
      assert methodname[2].equals("");
      func = "|java-" + methodname[1].trim() + "|";
    }
    if (func == null) {
      return "format_simplify_contract() doesn't know function " + methodname[0] + "-"
        + methodname[1] + "-" + methodname[2];
    }
    return "(EQ " + result + " (" + func + " " + arg1 + " " + arg2 + "))";
  }

  public String format_csharp_contract(/*>>>@GuardSatisfied FunctionBinary this*/) {
    int var_order = get_var_order();
    String[] methodname = get_method_name();

    VarInfo argresultvi = ppt.var_infos[var_indices[var_order][0]];
    VarInfo arg1vi = ppt.var_infos[var_indices[var_order][1]];
    VarInfo arg2vi = ppt.var_infos[var_indices[var_order][2]];
    String result = argresultvi.csharp_name();
    String arg1 = arg1vi.csharp_name();
    String arg2 = arg2vi.csharp_name();
    String operator = null;

    if (methodname[1].equals(" * ")) {
      operator = "*";
    } else if (methodname[1].equals(" | ")) {
      operator = "|";
    } else if (methodname[1].equals(" & ")) {
      operator = "&";
    } else if (methodname[1].equals(" / ")) {
      operator = "/";
    } else if (methodname[1].equals(" ^ ")) {
      operator = "^";
    } else if (methodname[1].equals(" % ")) {
      operator = "%";
    } else if (methodname[1].equals(" && ")) {
      operator = "&&";
    } else if (methodname[1].equals(" || ")) {
      operator = "||";
    } else if (methodname[1].equals(" >> ")) {
      operator = ">>";
    } else if (methodname[1].equals(" >>> ")) {
      return result + " == " + arg1 + ".UnsignedRightShift(" + arg2 + ")";
      //return result + " == CSharpDaikonLib.Extensions.UnsignedRightShift(" + arg1 + ", " + arg2 + ")";
    } else if (methodname[1].equals(" << ")) {
      operator = "<<";
    }

    if (operator != null) {
      return result + " == (" + arg1 + " " + operator + " " + arg2 + ")";
    }

    String func = null;
    if (methodname[1].equals(", ")) {
      if (methodname[0].equals("java.lang.Math.min("))
        func = "Math.Min";
      else if (methodname[0].equals("java.lang.Math.max("))
        func = "Math.Max";
      else if (methodname[0].equals("plume.MathMDE.gcd("))
        return result + " == CSharpDaikonLib.Extensions.GCD(" + arg1 + ", " + arg2 + ")";
      else if (methodname[0].equals("java.lang.Math.pow("))
        return result + " == " + arg1 + ".Pow(" + arg2 + ")";
      else if (methodname[0].equals("plume.MathMDE.logicalXor("))
        return result + " == (" + arg1 + " ^ " + arg2 + ")";
    } else {
      assert methodname[0].equals("");
      assert methodname[2].equals("");
      func = "|" + methodname[1].trim() + "|";
    }

    if (func == null) {
      return "format_csharp_contract() doesn't know function " + methodname[0] + "-" + methodname[1] + "-" + methodname[2];
    }
    return result + " == " + func + "(" + arg1 + ", " + arg2 + ")";
  }

  // If our classes match, we must match
  /*@Pure*/
  public boolean isSameFormula(Invariant other) {
    return true;
  }
  public double computeConfidence() {
    if (logOn()) {
      VarInfo v1 = ppt.var_infos[0];
      VarInfo v2 = ppt.var_infos[1];
      VarInfo v3 = ppt.var_infos[2];
      log("computeConfidence(%s: num_values = %s, num_values(%s)=%s, num_values(%s)=%s, num_values(%s)=%s",
          format(), ppt.num_values(),
          v1.name(), ppt.parent.num_values(v1),
          v2.name(), ppt.parent.num_values(v2),
          v3.name(), ppt.parent.num_values(v3));
    }
    return Invariant.conf_is_ge(ppt.num_values(), 5);
  }

  /** If the arg is a sequence size, return the sequence; otherwise return null. */
  private /*@Nullable*/ VarInfo sized_sequence(VarInfo size) {
    if (size.derived instanceof SequenceLength) {
      return ((SequenceLength)size.derived).base;
    }
    return null;
  }

  /*@Pure*/
  public /*@Nullable*/ DiscardInfo isObviousDynamically(VarInfo[] vis) {

    DiscardInfo super_result = super.isObviousDynamically(vis);
    if (super_result != null) {
      return super_result;
    }

    // Discard if any two of the three variables are the sizes of the
    // same arrays.
    VarInfo arr1 = sized_sequence(vis[0]);
    VarInfo arr2 = sized_sequence(vis[1]);
    VarInfo arr3 = sized_sequence(vis[2]);
    if (((arr1 != null) && (arr1 == arr2))
        || ((arr1 != null) && (arr1 == arr3))
        || ((arr2 != null) && (arr2 == arr3))) {
      return new DiscardInfo(this, DiscardCode.obvious,
                    "two are sizes of same array:  "
                    + vis[0].name() + " "
                    + vis[1].name() + " "
                    + vis[2].name());
    }

    return null;
  }

  // default is that it is not this function, overriden in the subclass
  /*@Pure*/
  public boolean isMultiply() {
    return false;
  }

/**
 * Represents the invariant {@code x = Multiply(y, z)} over three long
 * scalars. 
 */
public static class MultiplyLong_xyz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ MultiplyLong_xyz proto = new /*@Prototype*/ MultiplyLong_xyz ();

  /** Returns the prototype invariant for MultiplyLong_xyz */
  public static /*@Prototype*/ MultiplyLong_xyz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected MultiplyLong_xyz instantiate_dyn(/*>>> @Prototype MultiplyLong_xyz this,*/ PptSlice slice) {
    return new MultiplyLong_xyz (slice);
  }

  private MultiplyLong_xyz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ MultiplyLong_xyz () {
    super();
  }

  private static String[] method_name = new String[] {"", " * ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied MultiplyLong_xyz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert MultiplyLong_xyz.function_id == -1;
    MultiplyLong_xyz.function_id = function_id;
  }

  private static int var_order = 1;

  public int get_var_order(/*>>>@GuardSatisfied MultiplyLong_xyz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long y, long z) {

    return (y * z);
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, y, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, y, z);
    }
    return (add_ordered(x, y, z, count));
  }

  /*@Pure*/
  public boolean isMultiply() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(MultiplyLong_xyz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == 0) && (y == 0) ==> r = y * z
            new NISuppression(result_eq_0, arg1_eq_0, suppressee),

            // (r == 0) && (z == 0) ==> r = y * z
            new NISuppression(result_eq_0, arg2_eq_0, suppressee),

            // (r == y) && (z == 1) ==> r = y * z
            new NISuppression(result_eq_arg1, arg2_eq_1, suppressee),

            // (r == z) && (y == 1) ==> r = y * z
            new NISuppression(result_eq_arg2, arg1_eq_1, suppressee),

            // (r == y) && (z boolean) && (z==0 ==> y==0)
            // x = x * 0 is true if x == 0
            // x = x * 1 is true for all x
            new NISuppression(arg2_boolean, arg2_track0_arg1, result_eq_arg1,
                               suppressee),

            // (r == z) && (y boolean) && (y==0 ==> z=0)
            new NISuppression(result_eq_arg2, arg1_track0_arg2, arg1_boolean,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = Multiply(x, z)} over three long
 * scalars. 
 */
public static class MultiplyLong_yxz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ MultiplyLong_yxz proto = new /*@Prototype*/ MultiplyLong_yxz ();

  /** Returns the prototype invariant for MultiplyLong_yxz */
  public static /*@Prototype*/ MultiplyLong_yxz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected MultiplyLong_yxz instantiate_dyn(/*>>> @Prototype MultiplyLong_yxz this,*/ PptSlice slice) {
    return new MultiplyLong_yxz (slice);
  }

  private MultiplyLong_yxz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ MultiplyLong_yxz () {
    super();
  }

  private static String[] method_name = new String[] {"", " * ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied MultiplyLong_yxz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert MultiplyLong_yxz.function_id == -1;
    MultiplyLong_yxz.function_id = function_id;
  }

  private static int var_order = 2;

  public int get_var_order(/*>>>@GuardSatisfied MultiplyLong_yxz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long z) {

    return (x * z);
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, x, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, x, z);
    }
    return (add_ordered(y, x, z, count));
  }

  /*@Pure*/
  public boolean isMultiply() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(MultiplyLong_yxz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == 0) && (x == 0) ==> r = x * z
            new NISuppression(result_eq_0, arg1_eq_0, suppressee),

            // (r == 0) && (z == 0) ==> r = x * z
            new NISuppression(result_eq_0, arg2_eq_0, suppressee),

            // (r == x) && (z == 1) ==> r = x * z
            new NISuppression(result_eq_arg1, arg2_eq_1, suppressee),

            // (r == z) && (x == 1) ==> r = x * z
            new NISuppression(result_eq_arg2, arg1_eq_1, suppressee),

            // (r == x) && (z boolean) && (z==0 ==> x==0)
            // x = x * 0 is true if x == 0
            // x = x * 1 is true for all x
            new NISuppression(arg2_boolean, arg2_track0_arg1, result_eq_arg1,
                               suppressee),

            // (r == z) && (x boolean) && (x==0 ==> z=0)
            new NISuppression(result_eq_arg2, arg1_track0_arg2, arg1_boolean,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = Multiply(x, y)} over three long
 * scalars. 
 */
public static class MultiplyLong_zxy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ MultiplyLong_zxy proto = new /*@Prototype*/ MultiplyLong_zxy ();

  /** Returns the prototype invariant for MultiplyLong_zxy */
  public static /*@Prototype*/ MultiplyLong_zxy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected MultiplyLong_zxy instantiate_dyn(/*>>> @Prototype MultiplyLong_zxy this,*/ PptSlice slice) {
    return new MultiplyLong_zxy (slice);
  }

  private MultiplyLong_zxy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ MultiplyLong_zxy () {
    super();
  }

  private static String[] method_name = new String[] {"", " * ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied MultiplyLong_zxy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert MultiplyLong_zxy.function_id == -1;
    MultiplyLong_zxy.function_id = function_id;
  }

  private static int var_order = 3;

  public int get_var_order(/*>>>@GuardSatisfied MultiplyLong_zxy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long y) {

    return (x * y);
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, x, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, x, y);
    }
    return (add_ordered(z, x, y, count));
  }

  /*@Pure*/
  public boolean isMultiply() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(MultiplyLong_zxy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == 0) && (x == 0) ==> r = x * y
            new NISuppression(result_eq_0, arg1_eq_0, suppressee),

            // (r == 0) && (y == 0) ==> r = x * y
            new NISuppression(result_eq_0, arg2_eq_0, suppressee),

            // (r == x) && (y == 1) ==> r = x * y
            new NISuppression(result_eq_arg1, arg2_eq_1, suppressee),

            // (r == y) && (x == 1) ==> r = x * y
            new NISuppression(result_eq_arg2, arg1_eq_1, suppressee),

            // (r == x) && (y boolean) && (y==0 ==> x==0)
            // x = x * 0 is true if x == 0
            // x = x * 1 is true for all x
            new NISuppression(arg2_boolean, arg2_track0_arg1, result_eq_arg1,
                               suppressee),

            // (r == y) && (x boolean) && (x==0 ==> y=0)
            new NISuppression(result_eq_arg2, arg1_track0_arg2, arg1_boolean,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

  // #define EQUALITY_MIN_MAX_SUPPRESS

  // default is that it is not this function, overriden in the subclass
  /*@Pure*/
  public boolean isMinimum() {
    return false;
  }

/**
 * Represents the invariant {@code x = Minimum(y, z)} over three long
 * scalars. 
 */
public static class MinimumLong_xyz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ MinimumLong_xyz proto = new /*@Prototype*/ MinimumLong_xyz ();

  /** Returns the prototype invariant for MinimumLong_xyz */
  public static /*@Prototype*/ MinimumLong_xyz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected MinimumLong_xyz instantiate_dyn(/*>>> @Prototype MinimumLong_xyz this,*/ PptSlice slice) {
    return new MinimumLong_xyz (slice);
  }

  private MinimumLong_xyz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ MinimumLong_xyz () {
    super();
  }

  private static String[] method_name = new String[] {"java.lang.Math.min(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied MinimumLong_xyz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert MinimumLong_xyz.function_id == -1;
    MinimumLong_xyz.function_id = function_id;
  }

  private static int var_order = 1;

  public int get_var_order(/*>>>@GuardSatisfied MinimumLong_xyz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long y, long z) {

    return (Math.min(y, z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, y, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, y, z);
    }
    return (add_ordered(x, y, z, count));
  }

  /*@Pure*/
  public boolean isMinimum() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(MinimumLong_xyz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (x == y) && (y <= z) ==> r = min(y, z)
            new NISuppression(result_eq_arg1, arg1_le_arg2, suppressee),

            // (x == z) && (z <= y) ==> r = min(y, z)
            new NISuppression(result_eq_arg2, arg2_le_arg1, suppressee),

            // (x boolean) && (y=0 <==> r=0) && (z == 1)
            // 0 = min (y, 1), true when (y == 0)
            // 1 = min (y, 1), true when (y > 0)
            new NISuppression(result_track0_arg1, arg1_track0_result,
                               result_boolean, arg1_ge_0, arg2_eq_1, suppressee),

            // (x boolean) && (z=0 <==> r=0) && (y == 1)
            new NISuppression(result_track0_arg2, arg2_track0_result,
                               result_boolean, arg2_ge_0, arg1_eq_1, suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = Minimum(x, z)} over three long
 * scalars. 
 */
public static class MinimumLong_yxz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ MinimumLong_yxz proto = new /*@Prototype*/ MinimumLong_yxz ();

  /** Returns the prototype invariant for MinimumLong_yxz */
  public static /*@Prototype*/ MinimumLong_yxz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected MinimumLong_yxz instantiate_dyn(/*>>> @Prototype MinimumLong_yxz this,*/ PptSlice slice) {
    return new MinimumLong_yxz (slice);
  }

  private MinimumLong_yxz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ MinimumLong_yxz () {
    super();
  }

  private static String[] method_name = new String[] {"java.lang.Math.min(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied MinimumLong_yxz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert MinimumLong_yxz.function_id == -1;
    MinimumLong_yxz.function_id = function_id;
  }

  private static int var_order = 2;

  public int get_var_order(/*>>>@GuardSatisfied MinimumLong_yxz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long z) {

    return (Math.min(x, z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, x, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, x, z);
    }
    return (add_ordered(y, x, z, count));
  }

  /*@Pure*/
  public boolean isMinimum() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(MinimumLong_yxz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (y == x) && (x <= z) ==> r = min(x, z)
            new NISuppression(result_eq_arg1, arg1_le_arg2, suppressee),

            // (y == z) && (z <= x) ==> r = min(x, z)
            new NISuppression(result_eq_arg2, arg2_le_arg1, suppressee),

            // (y boolean) && (x=0 <==> r=0) && (z == 1)
            // 0 = min (x, 1), true when (x == 0)
            // 1 = min (x, 1), true when (x > 0)
            new NISuppression(result_track0_arg1, arg1_track0_result,
                               result_boolean, arg1_ge_0, arg2_eq_1, suppressee),

            // (y boolean) && (z=0 <==> r=0) && (x == 1)
            new NISuppression(result_track0_arg2, arg2_track0_result,
                               result_boolean, arg2_ge_0, arg1_eq_1, suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = Minimum(x, y)} over three long
 * scalars. 
 */
public static class MinimumLong_zxy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ MinimumLong_zxy proto = new /*@Prototype*/ MinimumLong_zxy ();

  /** Returns the prototype invariant for MinimumLong_zxy */
  public static /*@Prototype*/ MinimumLong_zxy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected MinimumLong_zxy instantiate_dyn(/*>>> @Prototype MinimumLong_zxy this,*/ PptSlice slice) {
    return new MinimumLong_zxy (slice);
  }

  private MinimumLong_zxy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ MinimumLong_zxy () {
    super();
  }

  private static String[] method_name = new String[] {"java.lang.Math.min(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied MinimumLong_zxy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert MinimumLong_zxy.function_id == -1;
    MinimumLong_zxy.function_id = function_id;
  }

  private static int var_order = 3;

  public int get_var_order(/*>>>@GuardSatisfied MinimumLong_zxy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long y) {

    return (Math.min(x, y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, x, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, x, y);
    }
    return (add_ordered(z, x, y, count));
  }

  /*@Pure*/
  public boolean isMinimum() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(MinimumLong_zxy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (z == x) && (x <= y) ==> r = min(x, y)
            new NISuppression(result_eq_arg1, arg1_le_arg2, suppressee),

            // (z == y) && (y <= x) ==> r = min(x, y)
            new NISuppression(result_eq_arg2, arg2_le_arg1, suppressee),

            // (z boolean) && (x=0 <==> r=0) && (y == 1)
            // 0 = min (x, 1), true when (x == 0)
            // 1 = min (x, 1), true when (x > 0)
            new NISuppression(result_track0_arg1, arg1_track0_result,
                               result_boolean, arg1_ge_0, arg2_eq_1, suppressee),

            // (z boolean) && (y=0 <==> r=0) && (x == 1)
            new NISuppression(result_track0_arg2, arg2_track0_result,
                               result_boolean, arg2_ge_0, arg1_eq_1, suppressee),

          });

  // Create a suppression factory for functionBinary

}

  // #define EQUALITY_MIN_MAX_SUPPRESS

  // default is that it is not this function, overriden in the subclass
  /*@Pure*/
  public boolean isMaximum() {
    return false;
  }

/**
 * Represents the invariant {@code x = Maximum(y, z)} over three long
 * scalars. 
 */
public static class MaximumLong_xyz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ MaximumLong_xyz proto = new /*@Prototype*/ MaximumLong_xyz ();

  /** Returns the prototype invariant for MaximumLong_xyz */
  public static /*@Prototype*/ MaximumLong_xyz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected MaximumLong_xyz instantiate_dyn(/*>>> @Prototype MaximumLong_xyz this,*/ PptSlice slice) {
    return new MaximumLong_xyz (slice);
  }

  private MaximumLong_xyz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ MaximumLong_xyz () {
    super();
  }

  private static String[] method_name = new String[] {"java.lang.Math.max(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied MaximumLong_xyz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert MaximumLong_xyz.function_id == -1;
    MaximumLong_xyz.function_id = function_id;
  }

  private static int var_order = 1;

  public int get_var_order(/*>>>@GuardSatisfied MaximumLong_xyz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long y, long z) {

    return (Math.max(y, z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, y, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, y, z);
    }
    return (add_ordered(x, y, z, count));
  }

  /*@Pure*/
  public boolean isMaximum() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(MaximumLong_xyz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == y) && (z <= y) ==> r = max(y, z)
            new NISuppression(result_eq_arg1, arg2_le_arg1, suppressee),

            // (r == z) && (y <= z) ==> r = max(y, z)
            new NISuppression(result_eq_arg2, arg1_le_arg2, suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = Maximum(x, z)} over three long
 * scalars. 
 */
public static class MaximumLong_yxz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ MaximumLong_yxz proto = new /*@Prototype*/ MaximumLong_yxz ();

  /** Returns the prototype invariant for MaximumLong_yxz */
  public static /*@Prototype*/ MaximumLong_yxz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected MaximumLong_yxz instantiate_dyn(/*>>> @Prototype MaximumLong_yxz this,*/ PptSlice slice) {
    return new MaximumLong_yxz (slice);
  }

  private MaximumLong_yxz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ MaximumLong_yxz () {
    super();
  }

  private static String[] method_name = new String[] {"java.lang.Math.max(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied MaximumLong_yxz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert MaximumLong_yxz.function_id == -1;
    MaximumLong_yxz.function_id = function_id;
  }

  private static int var_order = 2;

  public int get_var_order(/*>>>@GuardSatisfied MaximumLong_yxz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long z) {

    return (Math.max(x, z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, x, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, x, z);
    }
    return (add_ordered(y, x, z, count));
  }

  /*@Pure*/
  public boolean isMaximum() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(MaximumLong_yxz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == x) && (z <= x) ==> r = max(x, z)
            new NISuppression(result_eq_arg1, arg2_le_arg1, suppressee),

            // (r == z) && (x <= z) ==> r = max(x, z)
            new NISuppression(result_eq_arg2, arg1_le_arg2, suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = Maximum(x, y)} over three long
 * scalars. 
 */
public static class MaximumLong_zxy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ MaximumLong_zxy proto = new /*@Prototype*/ MaximumLong_zxy ();

  /** Returns the prototype invariant for MaximumLong_zxy */
  public static /*@Prototype*/ MaximumLong_zxy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected MaximumLong_zxy instantiate_dyn(/*>>> @Prototype MaximumLong_zxy this,*/ PptSlice slice) {
    return new MaximumLong_zxy (slice);
  }

  private MaximumLong_zxy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ MaximumLong_zxy () {
    super();
  }

  private static String[] method_name = new String[] {"java.lang.Math.max(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied MaximumLong_zxy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert MaximumLong_zxy.function_id == -1;
    MaximumLong_zxy.function_id = function_id;
  }

  private static int var_order = 3;

  public int get_var_order(/*>>>@GuardSatisfied MaximumLong_zxy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long y) {

    return (Math.max(x, y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, x, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, x, y);
    }
    return (add_ordered(z, x, y, count));
  }

  /*@Pure*/
  public boolean isMaximum() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(MaximumLong_zxy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == x) && (y <= x) ==> r = max(x, y)
            new NISuppression(result_eq_arg1, arg2_le_arg1, suppressee),

            // (r == y) && (x <= y) ==> r = max(x, y)
            new NISuppression(result_eq_arg2, arg1_le_arg2, suppressee),

          });

  // Create a suppression factory for functionBinary

}

  // default is that it is not this function, overriden in the subclass
  /*@Pure*/
  public boolean isDivision() {
    return false;
  }

/**
 * Represents the invariant {@code x = Division(y, z)} over three long
 * scalars. 
 */
public static class DivisionLong_xyz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ DivisionLong_xyz proto = new /*@Prototype*/ DivisionLong_xyz ();

  /** Returns the prototype invariant for DivisionLong_xyz */
  public static /*@Prototype*/ DivisionLong_xyz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected DivisionLong_xyz instantiate_dyn(/*>>> @Prototype DivisionLong_xyz this,*/ PptSlice slice) {
    return new DivisionLong_xyz (slice);
  }

  private DivisionLong_xyz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ DivisionLong_xyz () {
    super();
  }

  private static String[] method_name = new String[] {"", " / ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied DivisionLong_xyz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert DivisionLong_xyz.function_id == -1;
    DivisionLong_xyz.function_id = function_id;
  }

  private static int var_order = 1;

  public int get_var_order(/*>>>@GuardSatisfied DivisionLong_xyz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long y, long z) {

    return ((y / z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, y, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, y, z);
    }
    return (add_ordered(x, y, z, count));
  }

  /*@Pure*/
  public boolean isDivision() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(DivisionLong_xyz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == 0) && (y < z) && (y >= 0) && (z != 0) ==> r = y / z
            new NISuppression(result_eq_0, arg1_lt_arg2, arg1_ge_0, arg2_ne_0, suppressee),

            // (y == z) && (z != 0) && (r == 1)
            new NISuppression(arg1_eq_arg2, arg2_ne_0, result_eq_1, suppressee),

            // (r == y) && (z == 1) ==> r = y / z
            new NISuppression(result_eq_arg1, arg2_eq_1, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = Division(x, z)} over three long
 * scalars. 
 */
public static class DivisionLong_yxz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ DivisionLong_yxz proto = new /*@Prototype*/ DivisionLong_yxz ();

  /** Returns the prototype invariant for DivisionLong_yxz */
  public static /*@Prototype*/ DivisionLong_yxz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected DivisionLong_yxz instantiate_dyn(/*>>> @Prototype DivisionLong_yxz this,*/ PptSlice slice) {
    return new DivisionLong_yxz (slice);
  }

  private DivisionLong_yxz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ DivisionLong_yxz () {
    super();
  }

  private static String[] method_name = new String[] {"", " / ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied DivisionLong_yxz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert DivisionLong_yxz.function_id == -1;
    DivisionLong_yxz.function_id = function_id;
  }

  private static int var_order = 2;

  public int get_var_order(/*>>>@GuardSatisfied DivisionLong_yxz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long x, long z) {

    return ((x / z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, x, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, x, z);
    }
    return (add_ordered(y, x, z, count));
  }

  /*@Pure*/
  public boolean isDivision() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(DivisionLong_yxz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == 0) && (x < z) && (x >= 0) && (z != 0) ==> r = x / z
            new NISuppression(result_eq_0, arg1_lt_arg2, arg1_ge_0, arg2_ne_0, suppressee),

            // (x == z) && (z != 0) && (r == 1)
            new NISuppression(arg1_eq_arg2, arg2_ne_0, result_eq_1, suppressee),

            // (r == x) && (z == 1) ==> r = x / z
            new NISuppression(result_eq_arg1, arg2_eq_1, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = Division(x, y)} over three long
 * scalars. 
 */
public static class DivisionLong_zxy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ DivisionLong_zxy proto = new /*@Prototype*/ DivisionLong_zxy ();

  /** Returns the prototype invariant for DivisionLong_zxy */
  public static /*@Prototype*/ DivisionLong_zxy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected DivisionLong_zxy instantiate_dyn(/*>>> @Prototype DivisionLong_zxy this,*/ PptSlice slice) {
    return new DivisionLong_zxy (slice);
  }

  private DivisionLong_zxy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ DivisionLong_zxy () {
    super();
  }

  private static String[] method_name = new String[] {"", " / ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied DivisionLong_zxy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert DivisionLong_zxy.function_id == -1;
    DivisionLong_zxy.function_id = function_id;
  }

  private static int var_order = 3;

  public int get_var_order(/*>>>@GuardSatisfied DivisionLong_zxy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long x, long y) {

    return ((x / y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, x, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, x, y);
    }
    return (add_ordered(z, x, y, count));
  }

  /*@Pure*/
  public boolean isDivision() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(DivisionLong_zxy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == 0) && (x < y) && (x >= 0) && (y != 0) ==> r = x / y
            new NISuppression(result_eq_0, arg1_lt_arg2, arg1_ge_0, arg2_ne_0, suppressee),

            // (x == y) && (y != 0) && (r == 1)
            new NISuppression(arg1_eq_arg2, arg2_ne_0, result_eq_1, suppressee),

            // (r == x) && (y == 1) ==> r = x / y
            new NISuppression(result_eq_arg1, arg2_eq_1, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code x = Division(z, y)} over three long
 * scalars. 
 */
public static class DivisionLong_xzy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ DivisionLong_xzy proto = new /*@Prototype*/ DivisionLong_xzy ();

  /** Returns the prototype invariant for DivisionLong_xzy */
  public static /*@Prototype*/ DivisionLong_xzy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected DivisionLong_xzy instantiate_dyn(/*>>> @Prototype DivisionLong_xzy this,*/ PptSlice slice) {
    return new DivisionLong_xzy (slice);
  }

  private DivisionLong_xzy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ DivisionLong_xzy () {
    super();
  }

  private static String[] method_name = new String[] {"", " / ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied DivisionLong_xzy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert DivisionLong_xzy.function_id == -1;
    DivisionLong_xzy.function_id = function_id;
  }

  private static int var_order = 4;

  public int get_var_order(/*>>>@GuardSatisfied DivisionLong_xzy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long z, long y) {

    return ((z / y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, z, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, z, y);
    }
    return (add_ordered(x, z, y, count));
  }

  /*@Pure*/
  public boolean isDivision() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(DivisionLong_xzy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 2, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 2, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(2, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 2, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == 0) && (z < y) && (z >= 0) && (y != 0) ==> r = z / y
            new NISuppression(result_eq_0, arg1_lt_arg2, arg1_ge_0, arg2_ne_0, suppressee),

            // (z == y) && (y != 0) && (r == 1)
            new NISuppression(arg1_eq_arg2, arg2_ne_0, result_eq_1, suppressee),

            // (r == z) && (y == 1) ==> r = z / y
            new NISuppression(result_eq_arg1, arg2_eq_1, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = Division(z, x)} over three long
 * scalars. 
 */
public static class DivisionLong_yzx extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ DivisionLong_yzx proto = new /*@Prototype*/ DivisionLong_yzx ();

  /** Returns the prototype invariant for DivisionLong_yzx */
  public static /*@Prototype*/ DivisionLong_yzx get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected DivisionLong_yzx instantiate_dyn(/*>>> @Prototype DivisionLong_yzx this,*/ PptSlice slice) {
    return new DivisionLong_yzx (slice);
  }

  private DivisionLong_yzx (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ DivisionLong_yzx () {
    super();
  }

  private static String[] method_name = new String[] {"", " / ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied DivisionLong_yzx this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert DivisionLong_yzx.function_id == -1;
    DivisionLong_yzx.function_id = function_id;
  }

  private static int var_order = 5;

  public int get_var_order(/*>>>@GuardSatisfied DivisionLong_yzx this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long z, long x) {

    return ((z / x));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, z, x, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, z, x);
    }
    return (add_ordered(y, z, x, count));
  }

  /*@Pure*/
  public boolean isDivision() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(DivisionLong_yzx.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(2, 0, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(0, 2, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(0, 2, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(0, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(0, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(2, 0, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(0, 2, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(0, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == 0) && (z < x) && (z >= 0) && (x != 0) ==> r = z / x
            new NISuppression(result_eq_0, arg1_lt_arg2, arg1_ge_0, arg2_ne_0, suppressee),

            // (z == x) && (x != 0) && (r == 1)
            new NISuppression(arg1_eq_arg2, arg2_ne_0, result_eq_1, suppressee),

            // (r == z) && (x == 1) ==> r = z / x
            new NISuppression(result_eq_arg1, arg2_eq_1, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = Division(y, x)} over three long
 * scalars. 
 */
public static class DivisionLong_zyx extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ DivisionLong_zyx proto = new /*@Prototype*/ DivisionLong_zyx ();

  /** Returns the prototype invariant for DivisionLong_zyx */
  public static /*@Prototype*/ DivisionLong_zyx get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected DivisionLong_zyx instantiate_dyn(/*>>> @Prototype DivisionLong_zyx this,*/ PptSlice slice) {
    return new DivisionLong_zyx (slice);
  }

  private DivisionLong_zyx (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ DivisionLong_zyx () {
    super();
  }

  private static String[] method_name = new String[] {"", " / ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied DivisionLong_zyx this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert DivisionLong_zyx.function_id == -1;
    DivisionLong_zyx.function_id = function_id;
  }

  private static int var_order = 6;

  public int get_var_order(/*>>>@GuardSatisfied DivisionLong_zyx this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long y, long x) {

    return ((y / x));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, y, x, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, y, x);
    }
    return (add_ordered(z, y, x, count));
  }

  /*@Pure*/
  public boolean isDivision() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(DivisionLong_zyx.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 0, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(0, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(0, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 0, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(0, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(0, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == 0) && (y < x) && (y >= 0) && (x != 0) ==> r = y / x
            new NISuppression(result_eq_0, arg1_lt_arg2, arg1_ge_0, arg2_ne_0, suppressee),

            // (y == x) && (x != 0) && (r == 1)
            new NISuppression(arg1_eq_arg2, arg2_ne_0, result_eq_1, suppressee),

            // (r == y) && (x == 1) ==> r = y / x
            new NISuppression(result_eq_arg1, arg2_eq_1, suppressee),
          });

  // Create a suppression factory for functionBinary

}

  // default is that it is not this function, overriden in the subclass
  /*@Pure*/
  public boolean isPower() {
    return false;
  }

/**
 * Represents the invariant {@code x = Power(y, z)} over three long
 * scalars. 
 */
public static class PowerLong_xyz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ PowerLong_xyz proto = new /*@Prototype*/ PowerLong_xyz ();

  /** Returns the prototype invariant for PowerLong_xyz */
  public static /*@Prototype*/ PowerLong_xyz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected PowerLong_xyz instantiate_dyn(/*>>> @Prototype PowerLong_xyz this,*/ PptSlice slice) {
    return new PowerLong_xyz (slice);
  }

  private PowerLong_xyz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ PowerLong_xyz () {
    super();
  }

  private static String[] method_name = new String[] {"java.lang.Math.pow(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied PowerLong_xyz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert PowerLong_xyz.function_id == -1;
    PowerLong_xyz.function_id = function_id;
  }

  private static int var_order = 1;

  public int get_var_order(/*>>>@GuardSatisfied PowerLong_xyz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long y, long z) {

    return (MathMDE.pow(y, z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, y, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, y, z);
    }
    return (add_ordered(x, y, z, count));
  }

  /*@Pure*/
  public boolean isPower() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(PowerLong_xyz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    // Note that any suppression that doesn't limit z to valid exponents
    // (>= 0), must check for valid exponents as well (so that the invariant
    // is correctly destroyed on invalid exponents)
    //
    // Note also that pow(0,0) == 1 and pow(0,x), where (x > 0), == 0
    // Another interesting artificat of pow is that for any even base, any
    // exponent >= 64 will yield a result of 0.  For example, pow(10,256) == 0
    // (at least for integers)

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == 1) && (z == 0) ==> r = pow (y, z)
            new NISuppression(result_eq_1, arg2_eq_0, suppressee),

            // (r == 1) && (y == 1) && (z >= 0)   ==> r = pow (y, z)
            new NISuppression(result_eq_1, arg1_eq_1, arg2_ge_0, suppressee),

            // (r == 0) && (y == 0) && (z > 0)
            new NISuppression(result_eq_0, arg1_eq_0, arg2_ne_0, arg2_ge_0,
                              suppressee),

            // (r == y) && (z == 1)    ==> r = pow (y, z)
            new NISuppression(result_eq_arg1, arg2_eq_1, suppressee),

            // (r == 0) && (y even) && (z >= 64)
            // with each multiply there is one more zero in the result and since
            // a long has 64 bits in it, it becomes zero at that point
            new NISuppression(result_eq_0, arg1_even, arg2_ge_64, suppressee),

            // (r == 1) && (y boolean) && (y==0 <==> z==0) && (z >= 0)
            // 1 = pow (0, z) true iff (z == 0)
            // 1 = pow (1, z) true when z valid exponent
            new NISuppression(arg1_track0_arg2, arg2_ge_0, arg1_boolean,
                               result_eq_1, suppressee),

            // (r == y) && (r boolean) && (z > 0)
            // 0 = pow (0, z) true when z != 0
            // 1 = pow (1, z) true when z valid exponent
            new NISuppression(result_eq_arg1, result_boolean, arg2_ne_0,
                               arg2_ge_0, suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = Power(x, z)} over three long
 * scalars. 
 */
public static class PowerLong_yxz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ PowerLong_yxz proto = new /*@Prototype*/ PowerLong_yxz ();

  /** Returns the prototype invariant for PowerLong_yxz */
  public static /*@Prototype*/ PowerLong_yxz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected PowerLong_yxz instantiate_dyn(/*>>> @Prototype PowerLong_yxz this,*/ PptSlice slice) {
    return new PowerLong_yxz (slice);
  }

  private PowerLong_yxz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ PowerLong_yxz () {
    super();
  }

  private static String[] method_name = new String[] {"java.lang.Math.pow(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied PowerLong_yxz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert PowerLong_yxz.function_id == -1;
    PowerLong_yxz.function_id = function_id;
  }

  private static int var_order = 2;

  public int get_var_order(/*>>>@GuardSatisfied PowerLong_yxz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long x, long z) {

    return (MathMDE.pow(x, z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, x, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, x, z);
    }
    return (add_ordered(y, x, z, count));
  }

  /*@Pure*/
  public boolean isPower() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(PowerLong_yxz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    // Note that any suppression that doesn't limit z to valid exponents
    // (>= 0), must check for valid exponents as well (so that the invariant
    // is correctly destroyed on invalid exponents)
    //
    // Note also that pow(0,0) == 1 and pow(0,x), where (x > 0), == 0
    // Another interesting artificat of pow is that for any even base, any
    // exponent >= 64 will yield a result of 0.  For example, pow(10,256) == 0
    // (at least for integers)

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == 1) && (z == 0) ==> r = pow (x, z)
            new NISuppression(result_eq_1, arg2_eq_0, suppressee),

            // (r == 1) && (x == 1) && (z >= 0)   ==> r = pow (x, z)
            new NISuppression(result_eq_1, arg1_eq_1, arg2_ge_0, suppressee),

            // (r == 0) && (x == 0) && (z > 0)
            new NISuppression(result_eq_0, arg1_eq_0, arg2_ne_0, arg2_ge_0,
                              suppressee),

            // (r == x) && (z == 1)    ==> r = pow (x, z)
            new NISuppression(result_eq_arg1, arg2_eq_1, suppressee),

            // (r == 0) && (x even) && (z >= 64)
            // with each multiply there is one more zero in the result and since
            // a long has 64 bits in it, it becomes zero at that point
            new NISuppression(result_eq_0, arg1_even, arg2_ge_64, suppressee),

            // (r == 1) && (x boolean) && (x==0 <==> z==0) && (z >= 0)
            // 1 = pow (0, z) true iff (z == 0)
            // 1 = pow (1, z) true when z valid exponent
            new NISuppression(arg1_track0_arg2, arg2_ge_0, arg1_boolean,
                               result_eq_1, suppressee),

            // (r == x) && (r boolean) && (z > 0)
            // 0 = pow (0, z) true when z != 0
            // 1 = pow (1, z) true when z valid exponent
            new NISuppression(result_eq_arg1, result_boolean, arg2_ne_0,
                               arg2_ge_0, suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = Power(x, y)} over three long
 * scalars. 
 */
public static class PowerLong_zxy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ PowerLong_zxy proto = new /*@Prototype*/ PowerLong_zxy ();

  /** Returns the prototype invariant for PowerLong_zxy */
  public static /*@Prototype*/ PowerLong_zxy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected PowerLong_zxy instantiate_dyn(/*>>> @Prototype PowerLong_zxy this,*/ PptSlice slice) {
    return new PowerLong_zxy (slice);
  }

  private PowerLong_zxy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ PowerLong_zxy () {
    super();
  }

  private static String[] method_name = new String[] {"java.lang.Math.pow(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied PowerLong_zxy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert PowerLong_zxy.function_id == -1;
    PowerLong_zxy.function_id = function_id;
  }

  private static int var_order = 3;

  public int get_var_order(/*>>>@GuardSatisfied PowerLong_zxy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long x, long y) {

    return (MathMDE.pow(x, y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, x, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, x, y);
    }
    return (add_ordered(z, x, y, count));
  }

  /*@Pure*/
  public boolean isPower() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(PowerLong_zxy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    // Note that any suppression that doesn't limit y to valid exponents
    // (>= 0), must check for valid exponents as well (so that the invariant
    // is correctly destroyed on invalid exponents)
    //
    // Note also that pow(0,0) == 1 and pow(0,x), where (x > 0), == 0
    // Another interesting artificat of pow is that for any even base, any
    // exponent >= 64 will yield a result of 0.  For example, pow(10,256) == 0
    // (at least for integers)

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == 1) && (y == 0) ==> r = pow (x, y)
            new NISuppression(result_eq_1, arg2_eq_0, suppressee),

            // (r == 1) && (x == 1) && (y >= 0)   ==> r = pow (x, y)
            new NISuppression(result_eq_1, arg1_eq_1, arg2_ge_0, suppressee),

            // (r == 0) && (x == 0) && (y > 0)
            new NISuppression(result_eq_0, arg1_eq_0, arg2_ne_0, arg2_ge_0,
                              suppressee),

            // (r == x) && (y == 1)    ==> r = pow (x, y)
            new NISuppression(result_eq_arg1, arg2_eq_1, suppressee),

            // (r == 0) && (x even) && (y >= 64)
            // with each multiply there is one more zero in the result and since
            // a long has 64 bits in it, it becomes zero at that point
            new NISuppression(result_eq_0, arg1_even, arg2_ge_64, suppressee),

            // (r == 1) && (x boolean) && (x==0 <==> y==0) && (y >= 0)
            // 1 = pow (0, y) true iff (y == 0)
            // 1 = pow (1, y) true when y valid exponent
            new NISuppression(arg1_track0_arg2, arg2_ge_0, arg1_boolean,
                               result_eq_1, suppressee),

            // (r == x) && (r boolean) && (y > 0)
            // 0 = pow (0, y) true when y != 0
            // 1 = pow (1, y) true when y valid exponent
            new NISuppression(result_eq_arg1, result_boolean, arg2_ne_0,
                               arg2_ge_0, suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code x = Power(z, y)} over three long
 * scalars. 
 */
public static class PowerLong_xzy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ PowerLong_xzy proto = new /*@Prototype*/ PowerLong_xzy ();

  /** Returns the prototype invariant for PowerLong_xzy */
  public static /*@Prototype*/ PowerLong_xzy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected PowerLong_xzy instantiate_dyn(/*>>> @Prototype PowerLong_xzy this,*/ PptSlice slice) {
    return new PowerLong_xzy (slice);
  }

  private PowerLong_xzy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ PowerLong_xzy () {
    super();
  }

  private static String[] method_name = new String[] {"java.lang.Math.pow(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied PowerLong_xzy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert PowerLong_xzy.function_id == -1;
    PowerLong_xzy.function_id = function_id;
  }

  private static int var_order = 4;

  public int get_var_order(/*>>>@GuardSatisfied PowerLong_xzy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long z, long y) {

    return (MathMDE.pow(z, y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, z, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, z, y);
    }
    return (add_ordered(x, z, y, count));
  }

  /*@Pure*/
  public boolean isPower() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(PowerLong_xzy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 2, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 2, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(2, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 2, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    // Note that any suppression that doesn't limit y to valid exponents
    // (>= 0), must check for valid exponents as well (so that the invariant
    // is correctly destroyed on invalid exponents)
    //
    // Note also that pow(0,0) == 1 and pow(0,x), where (x > 0), == 0
    // Another interesting artificat of pow is that for any even base, any
    // exponent >= 64 will yield a result of 0.  For example, pow(10,256) == 0
    // (at least for integers)

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == 1) && (y == 0) ==> r = pow (z, y)
            new NISuppression(result_eq_1, arg2_eq_0, suppressee),

            // (r == 1) && (z == 1) && (y >= 0)   ==> r = pow (z, y)
            new NISuppression(result_eq_1, arg1_eq_1, arg2_ge_0, suppressee),

            // (r == 0) && (z == 0) && (y > 0)
            new NISuppression(result_eq_0, arg1_eq_0, arg2_ne_0, arg2_ge_0,
                              suppressee),

            // (r == z) && (y == 1)    ==> r = pow (z, y)
            new NISuppression(result_eq_arg1, arg2_eq_1, suppressee),

            // (r == 0) && (z even) && (y >= 64)
            // with each multiply there is one more zero in the result and since
            // a long has 64 bits in it, it becomes zero at that point
            new NISuppression(result_eq_0, arg1_even, arg2_ge_64, suppressee),

            // (r == 1) && (z boolean) && (z==0 <==> y==0) && (y >= 0)
            // 1 = pow (0, y) true iff (y == 0)
            // 1 = pow (1, y) true when y valid exponent
            new NISuppression(arg1_track0_arg2, arg2_ge_0, arg1_boolean,
                               result_eq_1, suppressee),

            // (r == z) && (r boolean) && (y > 0)
            // 0 = pow (0, y) true when y != 0
            // 1 = pow (1, y) true when y valid exponent
            new NISuppression(result_eq_arg1, result_boolean, arg2_ne_0,
                               arg2_ge_0, suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = Power(z, x)} over three long
 * scalars. 
 */
public static class PowerLong_yzx extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ PowerLong_yzx proto = new /*@Prototype*/ PowerLong_yzx ();

  /** Returns the prototype invariant for PowerLong_yzx */
  public static /*@Prototype*/ PowerLong_yzx get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected PowerLong_yzx instantiate_dyn(/*>>> @Prototype PowerLong_yzx this,*/ PptSlice slice) {
    return new PowerLong_yzx (slice);
  }

  private PowerLong_yzx (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ PowerLong_yzx () {
    super();
  }

  private static String[] method_name = new String[] {"java.lang.Math.pow(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied PowerLong_yzx this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert PowerLong_yzx.function_id == -1;
    PowerLong_yzx.function_id = function_id;
  }

  private static int var_order = 5;

  public int get_var_order(/*>>>@GuardSatisfied PowerLong_yzx this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long z, long x) {

    return (MathMDE.pow(z, x));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, z, x, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, z, x);
    }
    return (add_ordered(y, z, x, count));
  }

  /*@Pure*/
  public boolean isPower() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(PowerLong_yzx.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(2, 0, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(0, 2, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(0, 2, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(0, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(0, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(2, 0, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(0, 2, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(0, RangeInt.Bound0_63.class);

    // Note that any suppression that doesn't limit x to valid exponents
    // (>= 0), must check for valid exponents as well (so that the invariant
    // is correctly destroyed on invalid exponents)
    //
    // Note also that pow(0,0) == 1 and pow(0,x), where (x > 0), == 0
    // Another interesting artificat of pow is that for any even base, any
    // exponent >= 64 will yield a result of 0.  For example, pow(10,256) == 0
    // (at least for integers)

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == 1) && (x == 0) ==> r = pow (z, x)
            new NISuppression(result_eq_1, arg2_eq_0, suppressee),

            // (r == 1) && (z == 1) && (x >= 0)   ==> r = pow (z, x)
            new NISuppression(result_eq_1, arg1_eq_1, arg2_ge_0, suppressee),

            // (r == 0) && (z == 0) && (x > 0)
            new NISuppression(result_eq_0, arg1_eq_0, arg2_ne_0, arg2_ge_0,
                              suppressee),

            // (r == z) && (x == 1)    ==> r = pow (z, x)
            new NISuppression(result_eq_arg1, arg2_eq_1, suppressee),

            // (r == 0) && (z even) && (x >= 64)
            // with each multiply there is one more zero in the result and since
            // a long has 64 bits in it, it becomes zero at that point
            new NISuppression(result_eq_0, arg1_even, arg2_ge_64, suppressee),

            // (r == 1) && (z boolean) && (z==0 <==> x==0) && (x >= 0)
            // 1 = pow (0, x) true iff (x == 0)
            // 1 = pow (1, x) true when x valid exponent
            new NISuppression(arg1_track0_arg2, arg2_ge_0, arg1_boolean,
                               result_eq_1, suppressee),

            // (r == z) && (r boolean) && (x > 0)
            // 0 = pow (0, x) true when x != 0
            // 1 = pow (1, x) true when x valid exponent
            new NISuppression(result_eq_arg1, result_boolean, arg2_ne_0,
                               arg2_ge_0, suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = Power(y, x)} over three long
 * scalars. 
 */
public static class PowerLong_zyx extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ PowerLong_zyx proto = new /*@Prototype*/ PowerLong_zyx ();

  /** Returns the prototype invariant for PowerLong_zyx */
  public static /*@Prototype*/ PowerLong_zyx get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected PowerLong_zyx instantiate_dyn(/*>>> @Prototype PowerLong_zyx this,*/ PptSlice slice) {
    return new PowerLong_zyx (slice);
  }

  private PowerLong_zyx (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ PowerLong_zyx () {
    super();
  }

  private static String[] method_name = new String[] {"java.lang.Math.pow(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied PowerLong_zyx this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert PowerLong_zyx.function_id == -1;
    PowerLong_zyx.function_id = function_id;
  }

  private static int var_order = 6;

  public int get_var_order(/*>>>@GuardSatisfied PowerLong_zyx this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long y, long x) {

    return (MathMDE.pow(y, x));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, y, x, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, y, x);
    }
    return (add_ordered(z, y, x, count));
  }

  /*@Pure*/
  public boolean isPower() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(PowerLong_zyx.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 0, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(0, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(0, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 0, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(0, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(0, RangeInt.Bound0_63.class);

    // Note that any suppression that doesn't limit x to valid exponents
    // (>= 0), must check for valid exponents as well (so that the invariant
    // is correctly destroyed on invalid exponents)
    //
    // Note also that pow(0,0) == 1 and pow(0,x), where (x > 0), == 0
    // Another interesting artificat of pow is that for any even base, any
    // exponent >= 64 will yield a result of 0.  For example, pow(10,256) == 0
    // (at least for integers)

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {

            // (r == 1) && (x == 0) ==> r = pow (y, x)
            new NISuppression(result_eq_1, arg2_eq_0, suppressee),

            // (r == 1) && (y == 1) && (x >= 0)   ==> r = pow (y, x)
            new NISuppression(result_eq_1, arg1_eq_1, arg2_ge_0, suppressee),

            // (r == 0) && (y == 0) && (x > 0)
            new NISuppression(result_eq_0, arg1_eq_0, arg2_ne_0, arg2_ge_0,
                              suppressee),

            // (r == y) && (x == 1)    ==> r = pow (y, x)
            new NISuppression(result_eq_arg1, arg2_eq_1, suppressee),

            // (r == 0) && (y even) && (x >= 64)
            // with each multiply there is one more zero in the result and since
            // a long has 64 bits in it, it becomes zero at that point
            new NISuppression(result_eq_0, arg1_even, arg2_ge_64, suppressee),

            // (r == 1) && (y boolean) && (y==0 <==> x==0) && (x >= 0)
            // 1 = pow (0, x) true iff (x == 0)
            // 1 = pow (1, x) true when x valid exponent
            new NISuppression(arg1_track0_arg2, arg2_ge_0, arg1_boolean,
                               result_eq_1, suppressee),

            // (r == y) && (r boolean) && (x > 0)
            // 0 = pow (0, x) true when x != 0
            // 1 = pow (1, x) true when x valid exponent
            new NISuppression(result_eq_arg1, result_boolean, arg2_ne_0,
                               arg2_ge_0, suppressee),

          });

  // Create a suppression factory for functionBinary

}

  // #define EQUALITY_SUPPRESS 1

  // default is that it is not this function, overriden in the subclass
  /*@Pure*/
  public boolean isBitwiseAnd() {
    return false;
  }

/**
 * Represents the invariant {@code x = BitwiseAnd(y, z)} over three long
 * scalars. 
 */
public static class BitwiseAndLong_xyz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ BitwiseAndLong_xyz proto = new /*@Prototype*/ BitwiseAndLong_xyz ();

  /** Returns the prototype invariant for BitwiseAndLong_xyz */
  public static /*@Prototype*/ BitwiseAndLong_xyz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected BitwiseAndLong_xyz instantiate_dyn(/*>>> @Prototype BitwiseAndLong_xyz this,*/ PptSlice slice) {
    return new BitwiseAndLong_xyz (slice);
  }

  private BitwiseAndLong_xyz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ BitwiseAndLong_xyz () {
    super();
  }

  private static String[] method_name = new String[] {"", " & ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied BitwiseAndLong_xyz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert BitwiseAndLong_xyz.function_id == -1;
    BitwiseAndLong_xyz.function_id = function_id;
  }

  private static int var_order = 1;

  public int get_var_order(/*>>>@GuardSatisfied BitwiseAndLong_xyz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long y, long z) {

    return ((y & z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, y, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, y, z);
    }
    return (add_ordered(x, y, z, count));
  }

  /*@Pure*/
  public boolean isBitwiseAnd() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(BitwiseAndLong_xyz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == y) && (y == z) && (r == z) ==> r = y &  z
            new NISuppression(result_eq_arg1, arg1_eq_arg2, result_eq_arg2,
                               suppressee),

            // (r == y) && (y bitwise subset z)
            new NISuppression(result_eq_arg1, arg1_bw_subset_arg2, suppressee),

            // (r == z) && (z bitwise subset y)
            new NISuppression(result_eq_arg2, arg2_bw_subset_arg1, suppressee),

            // (r == 0) && (y & z == 0) ==> r = y & z
            new NISuppression(result_eq_0, arg1_and0_arg2, suppressee),

            // All of these are subsummed by the prior one
            // (r == 0) && (y == 0) ==> r = y & z
            // new NISuppression (result_eq_0, arg1_eq_0, suppressee),

            // (r == 0) && (z == 0) ==> r = y & z
            // new NISuppression (result_eq_0, arg2_eq_0, suppressee),

            // (r == 0) && (y boolean) && (z is even)
            // new NISuppression (result_eq_0, arg1_boolean, arg2_even,suppressee),

            // (r == 0) && (z boolean) && (y is even)
            // new NISuppression (result_eq_0, arg2_boolean, arg1_even,suppressee),

            // (r == 0) && (z > y) && (z power2) && (y >= 0)
            // new NISuppression (result_eq_0, arg1_lt_arg2, arg2_power2,arg1_ge_0,
            //                   suppressee),

            // (r == 0) && (y > z) && (y power2) && (z >= 0)
            // new NISuppression (result_eq_0, arg2_lt_arg1, arg1_power2,arg2_ge_0,
            //                   suppressee),

            // (r == y) && (r boolean) && (z == 1)
            new NISuppression(result_eq_arg1, result_boolean, arg2_eq_1,
                               suppressee),

            // (r == z) && (r boolean) && (y == 1)
            new NISuppression(result_eq_arg2, result_boolean, arg1_eq_1,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = BitwiseAnd(x, z)} over three long
 * scalars. 
 */
public static class BitwiseAndLong_yxz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ BitwiseAndLong_yxz proto = new /*@Prototype*/ BitwiseAndLong_yxz ();

  /** Returns the prototype invariant for BitwiseAndLong_yxz */
  public static /*@Prototype*/ BitwiseAndLong_yxz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected BitwiseAndLong_yxz instantiate_dyn(/*>>> @Prototype BitwiseAndLong_yxz this,*/ PptSlice slice) {
    return new BitwiseAndLong_yxz (slice);
  }

  private BitwiseAndLong_yxz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ BitwiseAndLong_yxz () {
    super();
  }

  private static String[] method_name = new String[] {"", " & ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied BitwiseAndLong_yxz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert BitwiseAndLong_yxz.function_id == -1;
    BitwiseAndLong_yxz.function_id = function_id;
  }

  private static int var_order = 2;

  public int get_var_order(/*>>>@GuardSatisfied BitwiseAndLong_yxz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long z) {

    return ((x & z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, x, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, x, z);
    }
    return (add_ordered(y, x, z, count));
  }

  /*@Pure*/
  public boolean isBitwiseAnd() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(BitwiseAndLong_yxz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == x) && (x == z) && (r == z) ==> r = x &  z
            new NISuppression(result_eq_arg1, arg1_eq_arg2, result_eq_arg2,
                               suppressee),

            // (r == x) && (x bitwise subset z)
            new NISuppression(result_eq_arg1, arg1_bw_subset_arg2, suppressee),

            // (r == z) && (z bitwise subset x)
            new NISuppression(result_eq_arg2, arg2_bw_subset_arg1, suppressee),

            // (r == 0) && (x & z == 0) ==> r = x & z
            new NISuppression(result_eq_0, arg1_and0_arg2, suppressee),

            // All of these are subsummed by the prior one
            // (r == 0) && (x == 0) ==> r = x & z
            // new NISuppression (result_eq_0, arg1_eq_0, suppressee),

            // (r == 0) && (z == 0) ==> r = x & z
            // new NISuppression (result_eq_0, arg2_eq_0, suppressee),

            // (r == 0) && (x boolean) && (z is even)
            // new NISuppression (result_eq_0, arg1_boolean, arg2_even,suppressee),

            // (r == 0) && (z boolean) && (x is even)
            // new NISuppression (result_eq_0, arg2_boolean, arg1_even,suppressee),

            // (r == 0) && (z > x) && (z power2) && (x >= 0)
            // new NISuppression (result_eq_0, arg1_lt_arg2, arg2_power2,arg1_ge_0,
            //                   suppressee),

            // (r == 0) && (x > z) && (x power2) && (z >= 0)
            // new NISuppression (result_eq_0, arg2_lt_arg1, arg1_power2,arg2_ge_0,
            //                   suppressee),

            // (r == x) && (r boolean) && (z == 1)
            new NISuppression(result_eq_arg1, result_boolean, arg2_eq_1,
                               suppressee),

            // (r == z) && (r boolean) && (x == 1)
            new NISuppression(result_eq_arg2, result_boolean, arg1_eq_1,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = BitwiseAnd(x, y)} over three long
 * scalars. 
 */
public static class BitwiseAndLong_zxy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ BitwiseAndLong_zxy proto = new /*@Prototype*/ BitwiseAndLong_zxy ();

  /** Returns the prototype invariant for BitwiseAndLong_zxy */
  public static /*@Prototype*/ BitwiseAndLong_zxy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected BitwiseAndLong_zxy instantiate_dyn(/*>>> @Prototype BitwiseAndLong_zxy this,*/ PptSlice slice) {
    return new BitwiseAndLong_zxy (slice);
  }

  private BitwiseAndLong_zxy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ BitwiseAndLong_zxy () {
    super();
  }

  private static String[] method_name = new String[] {"", " & ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied BitwiseAndLong_zxy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert BitwiseAndLong_zxy.function_id == -1;
    BitwiseAndLong_zxy.function_id = function_id;
  }

  private static int var_order = 3;

  public int get_var_order(/*>>>@GuardSatisfied BitwiseAndLong_zxy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long y) {

    return ((x & y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, x, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, x, y);
    }
    return (add_ordered(z, x, y, count));
  }

  /*@Pure*/
  public boolean isBitwiseAnd() {
    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(BitwiseAndLong_zxy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == x) && (x == y) && (r == y) ==> r = x &  y
            new NISuppression(result_eq_arg1, arg1_eq_arg2, result_eq_arg2,
                               suppressee),

            // (r == x) && (x bitwise subset y)
            new NISuppression(result_eq_arg1, arg1_bw_subset_arg2, suppressee),

            // (r == y) && (y bitwise subset x)
            new NISuppression(result_eq_arg2, arg2_bw_subset_arg1, suppressee),

            // (r == 0) && (x & y == 0) ==> r = x & y
            new NISuppression(result_eq_0, arg1_and0_arg2, suppressee),

            // All of these are subsummed by the prior one
            // (r == 0) && (x == 0) ==> r = x & y
            // new NISuppression (result_eq_0, arg1_eq_0, suppressee),

            // (r == 0) && (y == 0) ==> r = x & y
            // new NISuppression (result_eq_0, arg2_eq_0, suppressee),

            // (r == 0) && (x boolean) && (y is even)
            // new NISuppression (result_eq_0, arg1_boolean, arg2_even,suppressee),

            // (r == 0) && (y boolean) && (x is even)
            // new NISuppression (result_eq_0, arg2_boolean, arg1_even,suppressee),

            // (r == 0) && (y > x) && (y power2) && (x >= 0)
            // new NISuppression (result_eq_0, arg1_lt_arg2, arg2_power2,arg1_ge_0,
            //                   suppressee),

            // (r == 0) && (x > y) && (x power2) && (y >= 0)
            // new NISuppression (result_eq_0, arg2_lt_arg1, arg1_power2,arg2_ge_0,
            //                   suppressee),

            // (r == x) && (r boolean) && (y == 1)
            new NISuppression(result_eq_arg1, result_boolean, arg2_eq_1,
                               suppressee),

            // (r == y) && (r boolean) && (x == 1)
            new NISuppression(result_eq_arg2, result_boolean, arg1_eq_1,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

  // default is that it is not this function, overriden in the subclass
  /*@Pure*/
  public boolean isLogicalAnd() {
    return false;
  }

/**
 * Represents the invariant {@code x = LogicalAnd(y, z)} over three long
 * scalars. For logical operations, Daikon treats 0 as false and all other values as true.
 */
public static class LogicalAndLong_xyz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ LogicalAndLong_xyz proto = new /*@Prototype*/ LogicalAndLong_xyz ();

  /** Returns the prototype invariant for LogicalAndLong_xyz */
  public static /*@Prototype*/ LogicalAndLong_xyz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected LogicalAndLong_xyz instantiate_dyn(/*>>> @Prototype LogicalAndLong_xyz this,*/ PptSlice slice) {
    return new LogicalAndLong_xyz (slice);
  }

  private LogicalAndLong_xyz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ LogicalAndLong_xyz () {
    super();
  }

  private static String[] method_name = new String[] {"", " && ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied LogicalAndLong_xyz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert LogicalAndLong_xyz.function_id == -1;
    LogicalAndLong_xyz.function_id = function_id;
  }

  private static int var_order = 1;

  public int get_var_order(/*>>>@GuardSatisfied LogicalAndLong_xyz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long y, long z) {

      if ((y < 0) || (y > 1)) {
        throw new ArithmeticException("arg1 (" + y + ") is not boolean ");
      }
      if ((z < 0) || (z > 1)) {
        throw new ArithmeticException("arg2 (" + z + ") is not boolean ");
      }

    return ((((y != 0) && ( z != 0)) ? 1 : 0));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, y, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, y, z);
    }
    return (add_ordered(x, y, z, count));
  }

  /*@Pure*/
  public boolean isLogicalAnd() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(LogicalAndLong_xyz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == y) && (y == z) && (r == z) && (r is boolean)
            //    ==> r = y && z
            new NISuppression(result_eq_arg1, arg1_eq_arg2, result_eq_arg2,
                               result_boolean, suppressee),

            // (r == 0) && (y == 0) && (z is boolean) ==> r = y && z
            new NISuppression(result_eq_0, arg1_eq_0, arg2_boolean, suppressee),

            // (r == 0) && (z == 0) && (y is boolean) ==> r = y && z
            new NISuppression(result_eq_0, arg2_eq_0, arg1_boolean, suppressee),

            // (r == 0) && (y == 0) && (z boolean) ==> r = y && z
            new NISuppression(result_eq_0, arg1_eq_0, arg2_boolean, suppressee),

            // (r == 0) && (z == 0) && (y boolean) ==> r = y && z
            new NISuppression(result_eq_0, arg2_eq_0, arg1_boolean, suppressee),

            // (r == y) && (r boolean) && (z == 1)
            new NISuppression(result_eq_arg1, result_boolean, arg2_eq_1,
                               suppressee),

            // (r == z) && (r boolean) && (y == 1)
            new NISuppression(result_eq_arg2, result_boolean, arg1_eq_1,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = LogicalAnd(x, z)} over three long
 * scalars. For logical operations, Daikon treats 0 as false and all other values as true.
 */
public static class LogicalAndLong_yxz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ LogicalAndLong_yxz proto = new /*@Prototype*/ LogicalAndLong_yxz ();

  /** Returns the prototype invariant for LogicalAndLong_yxz */
  public static /*@Prototype*/ LogicalAndLong_yxz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected LogicalAndLong_yxz instantiate_dyn(/*>>> @Prototype LogicalAndLong_yxz this,*/ PptSlice slice) {
    return new LogicalAndLong_yxz (slice);
  }

  private LogicalAndLong_yxz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ LogicalAndLong_yxz () {
    super();
  }

  private static String[] method_name = new String[] {"", " && ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied LogicalAndLong_yxz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert LogicalAndLong_yxz.function_id == -1;
    LogicalAndLong_yxz.function_id = function_id;
  }

  private static int var_order = 2;

  public int get_var_order(/*>>>@GuardSatisfied LogicalAndLong_yxz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long z) {

      if ((x < 0) || (x > 1)) {
        throw new ArithmeticException("arg1 (" + x + ") is not boolean ");
      }
      if ((z < 0) || (z > 1)) {
        throw new ArithmeticException("arg2 (" + z + ") is not boolean ");
      }

    return ((((x != 0) && ( z != 0)) ? 1 : 0));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, x, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, x, z);
    }
    return (add_ordered(y, x, z, count));
  }

  /*@Pure*/
  public boolean isLogicalAnd() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(LogicalAndLong_yxz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == x) && (x == z) && (r == z) && (r is boolean)
            //    ==> r = x && z
            new NISuppression(result_eq_arg1, arg1_eq_arg2, result_eq_arg2,
                               result_boolean, suppressee),

            // (r == 0) && (x == 0) && (z is boolean) ==> r = x && z
            new NISuppression(result_eq_0, arg1_eq_0, arg2_boolean, suppressee),

            // (r == 0) && (z == 0) && (x is boolean) ==> r = x && z
            new NISuppression(result_eq_0, arg2_eq_0, arg1_boolean, suppressee),

            // (r == 0) && (x == 0) && (z boolean) ==> r = x && z
            new NISuppression(result_eq_0, arg1_eq_0, arg2_boolean, suppressee),

            // (r == 0) && (z == 0) && (x boolean) ==> r = x && z
            new NISuppression(result_eq_0, arg2_eq_0, arg1_boolean, suppressee),

            // (r == x) && (r boolean) && (z == 1)
            new NISuppression(result_eq_arg1, result_boolean, arg2_eq_1,
                               suppressee),

            // (r == z) && (r boolean) && (x == 1)
            new NISuppression(result_eq_arg2, result_boolean, arg1_eq_1,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = LogicalAnd(x, y)} over three long
 * scalars. For logical operations, Daikon treats 0 as false and all other values as true.
 */
public static class LogicalAndLong_zxy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ LogicalAndLong_zxy proto = new /*@Prototype*/ LogicalAndLong_zxy ();

  /** Returns the prototype invariant for LogicalAndLong_zxy */
  public static /*@Prototype*/ LogicalAndLong_zxy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected LogicalAndLong_zxy instantiate_dyn(/*>>> @Prototype LogicalAndLong_zxy this,*/ PptSlice slice) {
    return new LogicalAndLong_zxy (slice);
  }

  private LogicalAndLong_zxy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ LogicalAndLong_zxy () {
    super();
  }

  private static String[] method_name = new String[] {"", " && ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied LogicalAndLong_zxy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert LogicalAndLong_zxy.function_id == -1;
    LogicalAndLong_zxy.function_id = function_id;
  }

  private static int var_order = 3;

  public int get_var_order(/*>>>@GuardSatisfied LogicalAndLong_zxy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long y) {

      if ((x < 0) || (x > 1)) {
        throw new ArithmeticException("arg1 (" + x + ") is not boolean ");
      }
      if ((y < 0) || (y > 1)) {
        throw new ArithmeticException("arg2 (" + y + ") is not boolean ");
      }

    return ((((x != 0) && ( y != 0)) ? 1 : 0));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, x, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, x, y);
    }
    return (add_ordered(z, x, y, count));
  }

  /*@Pure*/
  public boolean isLogicalAnd() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(LogicalAndLong_zxy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == x) && (x == y) && (r == y) && (r is boolean)
            //    ==> r = x && y
            new NISuppression(result_eq_arg1, arg1_eq_arg2, result_eq_arg2,
                               result_boolean, suppressee),

            // (r == 0) && (x == 0) && (y is boolean) ==> r = x && y
            new NISuppression(result_eq_0, arg1_eq_0, arg2_boolean, suppressee),

            // (r == 0) && (y == 0) && (x is boolean) ==> r = x && y
            new NISuppression(result_eq_0, arg2_eq_0, arg1_boolean, suppressee),

            // (r == 0) && (x == 0) && (y boolean) ==> r = x && y
            new NISuppression(result_eq_0, arg1_eq_0, arg2_boolean, suppressee),

            // (r == 0) && (y == 0) && (x boolean) ==> r = x && y
            new NISuppression(result_eq_0, arg2_eq_0, arg1_boolean, suppressee),

            // (r == x) && (r boolean) && (y == 1)
            new NISuppression(result_eq_arg1, result_boolean, arg2_eq_1,
                               suppressee),

            // (r == y) && (r boolean) && (x == 1)
            new NISuppression(result_eq_arg2, result_boolean, arg1_eq_1,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

  // default is that it is not this function, overriden in the subclass
  /*@Pure*/
  public boolean isBitwiseXor() {
    return false;
  }

/**
 * Represents the invariant {@code x = BitwiseXor(y, z)} over three long
 * scalars. 
 */
public static class BitwiseXorLong_xyz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ BitwiseXorLong_xyz proto = new /*@Prototype*/ BitwiseXorLong_xyz ();

  /** Returns the prototype invariant for BitwiseXorLong_xyz */
  public static /*@Prototype*/ BitwiseXorLong_xyz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected BitwiseXorLong_xyz instantiate_dyn(/*>>> @Prototype BitwiseXorLong_xyz this,*/ PptSlice slice) {
    return new BitwiseXorLong_xyz (slice);
  }

  private BitwiseXorLong_xyz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ BitwiseXorLong_xyz () {
    super();
  }

  private static String[] method_name = new String[] {"", " ^ ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied BitwiseXorLong_xyz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert BitwiseXorLong_xyz.function_id == -1;
    BitwiseXorLong_xyz.function_id = function_id;
  }

  private static int var_order = 1;

  public int get_var_order(/*>>>@GuardSatisfied BitwiseXorLong_xyz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long y, long z) {

    return ((y ^ z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, y, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, y, z);
    }
    return (add_ordered(x, y, z, count));
  }

  /*@Pure*/
  public boolean isBitwiseXor() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(BitwiseXorLong_xyz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == 0) && (y == z) ==> r = y ^ z
            new NISuppression(result_eq_0, arg1_eq_arg2, suppressee),

            // (r == y) && (z == 0) ==> r = y ^ z
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == z) && (y == 0) ==> r = y ^ z
            new NISuppression(result_eq_arg2, arg1_eq_0, suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = BitwiseXor(x, z)} over three long
 * scalars. 
 */
public static class BitwiseXorLong_yxz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ BitwiseXorLong_yxz proto = new /*@Prototype*/ BitwiseXorLong_yxz ();

  /** Returns the prototype invariant for BitwiseXorLong_yxz */
  public static /*@Prototype*/ BitwiseXorLong_yxz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected BitwiseXorLong_yxz instantiate_dyn(/*>>> @Prototype BitwiseXorLong_yxz this,*/ PptSlice slice) {
    return new BitwiseXorLong_yxz (slice);
  }

  private BitwiseXorLong_yxz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ BitwiseXorLong_yxz () {
    super();
  }

  private static String[] method_name = new String[] {"", " ^ ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied BitwiseXorLong_yxz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert BitwiseXorLong_yxz.function_id == -1;
    BitwiseXorLong_yxz.function_id = function_id;
  }

  private static int var_order = 2;

  public int get_var_order(/*>>>@GuardSatisfied BitwiseXorLong_yxz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long z) {

    return ((x ^ z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, x, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, x, z);
    }
    return (add_ordered(y, x, z, count));
  }

  /*@Pure*/
  public boolean isBitwiseXor() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(BitwiseXorLong_yxz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == 0) && (x == z) ==> r = x ^ z
            new NISuppression(result_eq_0, arg1_eq_arg2, suppressee),

            // (r == x) && (z == 0) ==> r = x ^ z
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == z) && (x == 0) ==> r = x ^ z
            new NISuppression(result_eq_arg2, arg1_eq_0, suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = BitwiseXor(x, y)} over three long
 * scalars. 
 */
public static class BitwiseXorLong_zxy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ BitwiseXorLong_zxy proto = new /*@Prototype*/ BitwiseXorLong_zxy ();

  /** Returns the prototype invariant for BitwiseXorLong_zxy */
  public static /*@Prototype*/ BitwiseXorLong_zxy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected BitwiseXorLong_zxy instantiate_dyn(/*>>> @Prototype BitwiseXorLong_zxy this,*/ PptSlice slice) {
    return new BitwiseXorLong_zxy (slice);
  }

  private BitwiseXorLong_zxy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ BitwiseXorLong_zxy () {
    super();
  }

  private static String[] method_name = new String[] {"", " ^ ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied BitwiseXorLong_zxy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert BitwiseXorLong_zxy.function_id == -1;
    BitwiseXorLong_zxy.function_id = function_id;
  }

  private static int var_order = 3;

  public int get_var_order(/*>>>@GuardSatisfied BitwiseXorLong_zxy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long y) {

    return ((x ^ y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, x, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, x, y);
    }
    return (add_ordered(z, x, y, count));
  }

  /*@Pure*/
  public boolean isBitwiseXor() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(BitwiseXorLong_zxy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == 0) && (x == y) ==> r = x ^ y
            new NISuppression(result_eq_0, arg1_eq_arg2, suppressee),

            // (r == x) && (y == 0) ==> r = x ^ y
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == y) && (x == 0) ==> r = x ^ y
            new NISuppression(result_eq_arg2, arg1_eq_0, suppressee),

          });

  // Create a suppression factory for functionBinary

}

  // #define METHOD_NAME {"", " ^ ", ""}

  // default is that it is not this function, overriden in the subclass
  /*@Pure*/
  public boolean isLogicalXor() {
    return false;
  }

/**
 * Represents the invariant {@code x = LogicalXor(y, z)} over three long
 * scalars. For logical operations, Daikon treats 0 as false and all other values as true.
 */
public static class LogicalXorLong_xyz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ LogicalXorLong_xyz proto = new /*@Prototype*/ LogicalXorLong_xyz ();

  /** Returns the prototype invariant for LogicalXorLong_xyz */
  public static /*@Prototype*/ LogicalXorLong_xyz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected LogicalXorLong_xyz instantiate_dyn(/*>>> @Prototype LogicalXorLong_xyz this,*/ PptSlice slice) {
    return new LogicalXorLong_xyz (slice);
  }

  private LogicalXorLong_xyz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ LogicalXorLong_xyz () {
    super();
  }

  private static String[] method_name = new String[] {"plume.MathMDE.logicalXor(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied LogicalXorLong_xyz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert LogicalXorLong_xyz.function_id == -1;
    LogicalXorLong_xyz.function_id = function_id;
  }

  private static int var_order = 1;

  public int get_var_order(/*>>>@GuardSatisfied LogicalXorLong_xyz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long y, long z) {

      if ((y < 0) || (y > 1)) {
        throw new ArithmeticException("arg1 (" + y + ") is not boolean ");
      }
      if ((z < 0) || (z > 1)) {
        throw new ArithmeticException("arg2 (" + z + ") is not boolean ");
      }

    return ((((y != 0) ^ ( z != 0)) ? 1 : 0));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, y, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, y, z);
    }
    return (add_ordered(x, y, z, count));
  }

  /*@Pure*/
  public boolean isLogicalXor() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(LogicalXorLong_xyz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == 0) && (y == z) && (y boolean) ==> r = y ^ z
            new NISuppression(arg1_eq_arg2, arg1_boolean, result_eq_0,
                               suppressee),

            // (r == y) && (z == 0) && (x boolean) ==> r = y ^ z
            new NISuppression(result_eq_arg1, result_boolean, arg2_eq_0,
                               suppressee),

            // (r == z) && (y == 0) && (x boolean)==> r = y ^ z
            new NISuppression(result_eq_arg2, result_boolean, arg1_eq_0,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = LogicalXor(x, z)} over three long
 * scalars. For logical operations, Daikon treats 0 as false and all other values as true.
 */
public static class LogicalXorLong_yxz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ LogicalXorLong_yxz proto = new /*@Prototype*/ LogicalXorLong_yxz ();

  /** Returns the prototype invariant for LogicalXorLong_yxz */
  public static /*@Prototype*/ LogicalXorLong_yxz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected LogicalXorLong_yxz instantiate_dyn(/*>>> @Prototype LogicalXorLong_yxz this,*/ PptSlice slice) {
    return new LogicalXorLong_yxz (slice);
  }

  private LogicalXorLong_yxz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ LogicalXorLong_yxz () {
    super();
  }

  private static String[] method_name = new String[] {"plume.MathMDE.logicalXor(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied LogicalXorLong_yxz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert LogicalXorLong_yxz.function_id == -1;
    LogicalXorLong_yxz.function_id = function_id;
  }

  private static int var_order = 2;

  public int get_var_order(/*>>>@GuardSatisfied LogicalXorLong_yxz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long z) {

      if ((x < 0) || (x > 1)) {
        throw new ArithmeticException("arg1 (" + x + ") is not boolean ");
      }
      if ((z < 0) || (z > 1)) {
        throw new ArithmeticException("arg2 (" + z + ") is not boolean ");
      }

    return ((((x != 0) ^ ( z != 0)) ? 1 : 0));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, x, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, x, z);
    }
    return (add_ordered(y, x, z, count));
  }

  /*@Pure*/
  public boolean isLogicalXor() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(LogicalXorLong_yxz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == 0) && (x == z) && (x boolean) ==> r = x ^ z
            new NISuppression(arg1_eq_arg2, arg1_boolean, result_eq_0,
                               suppressee),

            // (r == x) && (z == 0) && (y boolean) ==> r = x ^ z
            new NISuppression(result_eq_arg1, result_boolean, arg2_eq_0,
                               suppressee),

            // (r == z) && (x == 0) && (y boolean)==> r = x ^ z
            new NISuppression(result_eq_arg2, result_boolean, arg1_eq_0,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = LogicalXor(x, y)} over three long
 * scalars. For logical operations, Daikon treats 0 as false and all other values as true.
 */
public static class LogicalXorLong_zxy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ LogicalXorLong_zxy proto = new /*@Prototype*/ LogicalXorLong_zxy ();

  /** Returns the prototype invariant for LogicalXorLong_zxy */
  public static /*@Prototype*/ LogicalXorLong_zxy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected LogicalXorLong_zxy instantiate_dyn(/*>>> @Prototype LogicalXorLong_zxy this,*/ PptSlice slice) {
    return new LogicalXorLong_zxy (slice);
  }

  private LogicalXorLong_zxy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ LogicalXorLong_zxy () {
    super();
  }

  private static String[] method_name = new String[] {"plume.MathMDE.logicalXor(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied LogicalXorLong_zxy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert LogicalXorLong_zxy.function_id == -1;
    LogicalXorLong_zxy.function_id = function_id;
  }

  private static int var_order = 3;

  public int get_var_order(/*>>>@GuardSatisfied LogicalXorLong_zxy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long y) {

      if ((x < 0) || (x > 1)) {
        throw new ArithmeticException("arg1 (" + x + ") is not boolean ");
      }
      if ((y < 0) || (y > 1)) {
        throw new ArithmeticException("arg2 (" + y + ") is not boolean ");
      }

    return ((((x != 0) ^ ( y != 0)) ? 1 : 0));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, x, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, x, y);
    }
    return (add_ordered(z, x, y, count));
  }

  /*@Pure*/
  public boolean isLogicalXor() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(LogicalXorLong_zxy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == 0) && (x == y) && (x boolean) ==> r = x ^ y
            new NISuppression(arg1_eq_arg2, arg1_boolean, result_eq_0,
                               suppressee),

            // (r == x) && (y == 0) && (z boolean) ==> r = x ^ y
            new NISuppression(result_eq_arg1, result_boolean, arg2_eq_0,
                               suppressee),

            // (r == y) && (x == 0) && (z boolean)==> r = x ^ y
            new NISuppression(result_eq_arg2, result_boolean, arg1_eq_0,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

  // #define EQUALITY_SUPPRESS 1

  // default is that it is not this function, overriden in the subclass
  /*@Pure*/
  public boolean isBitwiseOr() {
    return false;
  }

/**
 * Represents the invariant {@code x = BitwiseOr(y, z)} over three long
 * scalars. 
 */
public static class BitwiseOrLong_xyz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ BitwiseOrLong_xyz proto = new /*@Prototype*/ BitwiseOrLong_xyz ();

  /** Returns the prototype invariant for BitwiseOrLong_xyz */
  public static /*@Prototype*/ BitwiseOrLong_xyz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected BitwiseOrLong_xyz instantiate_dyn(/*>>> @Prototype BitwiseOrLong_xyz this,*/ PptSlice slice) {
    return new BitwiseOrLong_xyz (slice);
  }

  private BitwiseOrLong_xyz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ BitwiseOrLong_xyz () {
    super();
  }

  private static String[] method_name = new String[] {"", " | ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied BitwiseOrLong_xyz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert BitwiseOrLong_xyz.function_id == -1;
    BitwiseOrLong_xyz.function_id = function_id;
  }

  private static int var_order = 1;

  public int get_var_order(/*>>>@GuardSatisfied BitwiseOrLong_xyz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long y, long z) {

    return ((y | z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, y, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, y, z);
    }
    return (add_ordered(x, y, z, count));
  }

  /*@Pure*/
  public boolean isBitwiseOr() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(BitwiseOrLong_xyz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == y) && (z bitwise subset y)
            new NISuppression(result_eq_arg1, arg2_bw_subset_arg1, suppressee),

            // (r == z) && (y bitwise subset z)
            new NISuppression(result_eq_arg2, arg1_bw_subset_arg2, suppressee),

            // All of the below are subsummed by the two above
            // (r == y) && (y == z) ==> r = y | z
            // new NISuppression (result_eq_arg1, arg1_eq_arg2, suppressee),

            // (r == y) && (z == 0) ==> r = y | z
            // new NISuppression (result_eq_arg1, arg2_eq_0, suppressee),

            // (r == z) && (y == 0) ==> r = y | z
            // new NISuppression (result_eq_arg2, arg1_eq_0, suppressee),

            // (r == 1) && (y == 1) && (z boolean)
            // new NISuppression (result_eq_1, arg1_eq_1, arg2_boolean, suppressee),

            // (r == 1) && (z == 1) && (y boolean)
            // new NISuppression (result_eq_1, arg2_eq_1, arg1_boolean, suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = BitwiseOr(x, z)} over three long
 * scalars. 
 */
public static class BitwiseOrLong_yxz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ BitwiseOrLong_yxz proto = new /*@Prototype*/ BitwiseOrLong_yxz ();

  /** Returns the prototype invariant for BitwiseOrLong_yxz */
  public static /*@Prototype*/ BitwiseOrLong_yxz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected BitwiseOrLong_yxz instantiate_dyn(/*>>> @Prototype BitwiseOrLong_yxz this,*/ PptSlice slice) {
    return new BitwiseOrLong_yxz (slice);
  }

  private BitwiseOrLong_yxz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ BitwiseOrLong_yxz () {
    super();
  }

  private static String[] method_name = new String[] {"", " | ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied BitwiseOrLong_yxz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert BitwiseOrLong_yxz.function_id == -1;
    BitwiseOrLong_yxz.function_id = function_id;
  }

  private static int var_order = 2;

  public int get_var_order(/*>>>@GuardSatisfied BitwiseOrLong_yxz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long z) {

    return ((x | z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, x, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, x, z);
    }
    return (add_ordered(y, x, z, count));
  }

  /*@Pure*/
  public boolean isBitwiseOr() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(BitwiseOrLong_yxz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == x) && (z bitwise subset x)
            new NISuppression(result_eq_arg1, arg2_bw_subset_arg1, suppressee),

            // (r == z) && (x bitwise subset z)
            new NISuppression(result_eq_arg2, arg1_bw_subset_arg2, suppressee),

            // All of the below are subsummed by the two above
            // (r == x) && (x == z) ==> r = x | z
            // new NISuppression (result_eq_arg1, arg1_eq_arg2, suppressee),

            // (r == x) && (z == 0) ==> r = x | z
            // new NISuppression (result_eq_arg1, arg2_eq_0, suppressee),

            // (r == z) && (x == 0) ==> r = x | z
            // new NISuppression (result_eq_arg2, arg1_eq_0, suppressee),

            // (r == 1) && (x == 1) && (z boolean)
            // new NISuppression (result_eq_1, arg1_eq_1, arg2_boolean, suppressee),

            // (r == 1) && (z == 1) && (x boolean)
            // new NISuppression (result_eq_1, arg2_eq_1, arg1_boolean, suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = BitwiseOr(x, y)} over three long
 * scalars. 
 */
public static class BitwiseOrLong_zxy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ BitwiseOrLong_zxy proto = new /*@Prototype*/ BitwiseOrLong_zxy ();

  /** Returns the prototype invariant for BitwiseOrLong_zxy */
  public static /*@Prototype*/ BitwiseOrLong_zxy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected BitwiseOrLong_zxy instantiate_dyn(/*>>> @Prototype BitwiseOrLong_zxy this,*/ PptSlice slice) {
    return new BitwiseOrLong_zxy (slice);
  }

  private BitwiseOrLong_zxy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ BitwiseOrLong_zxy () {
    super();
  }

  private static String[] method_name = new String[] {"", " | ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied BitwiseOrLong_zxy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert BitwiseOrLong_zxy.function_id == -1;
    BitwiseOrLong_zxy.function_id = function_id;
  }

  private static int var_order = 3;

  public int get_var_order(/*>>>@GuardSatisfied BitwiseOrLong_zxy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long y) {

    return ((x | y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, x, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, x, y);
    }
    return (add_ordered(z, x, y, count));
  }

  /*@Pure*/
  public boolean isBitwiseOr() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(BitwiseOrLong_zxy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == x) && (y bitwise subset x)
            new NISuppression(result_eq_arg1, arg2_bw_subset_arg1, suppressee),

            // (r == y) && (x bitwise subset y)
            new NISuppression(result_eq_arg2, arg1_bw_subset_arg2, suppressee),

            // All of the below are subsummed by the two above
            // (r == x) && (x == y) ==> r = x | y
            // new NISuppression (result_eq_arg1, arg1_eq_arg2, suppressee),

            // (r == x) && (y == 0) ==> r = x | y
            // new NISuppression (result_eq_arg1, arg2_eq_0, suppressee),

            // (r == y) && (x == 0) ==> r = x | y
            // new NISuppression (result_eq_arg2, arg1_eq_0, suppressee),

            // (r == 1) && (x == 1) && (y boolean)
            // new NISuppression (result_eq_1, arg1_eq_1, arg2_boolean, suppressee),

            // (r == 1) && (y == 1) && (x boolean)
            // new NISuppression (result_eq_1, arg2_eq_1, arg1_boolean, suppressee),

          });

  // Create a suppression factory for functionBinary

}

  // default is that it is not this function, overriden in the subclass
  /*@Pure*/
  public boolean isLogicalOr() {
    return false;
  }

/**
 * Represents the invariant {@code x = LogicalOr(y, z)} over three long
 * scalars. For logical operations, Daikon treats 0 as false and all other values as true.
 */
public static class LogicalOrLong_xyz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ LogicalOrLong_xyz proto = new /*@Prototype*/ LogicalOrLong_xyz ();

  /** Returns the prototype invariant for LogicalOrLong_xyz */
  public static /*@Prototype*/ LogicalOrLong_xyz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected LogicalOrLong_xyz instantiate_dyn(/*>>> @Prototype LogicalOrLong_xyz this,*/ PptSlice slice) {
    return new LogicalOrLong_xyz (slice);
  }

  private LogicalOrLong_xyz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ LogicalOrLong_xyz () {
    super();
  }

  private static String[] method_name = new String[] {"", " || ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied LogicalOrLong_xyz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert LogicalOrLong_xyz.function_id == -1;
    LogicalOrLong_xyz.function_id = function_id;
  }

  private static int var_order = 1;

  public int get_var_order(/*>>>@GuardSatisfied LogicalOrLong_xyz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long y, long z) {

      if ((y < 0) || (y > 1)) {
        throw new ArithmeticException("arg1 (" + y + ") is not boolean ");
      }
      if ((z < 0) || (z > 1)) {
        throw new ArithmeticException("arg2 (" + z + ") is not boolean ");
      }

    return ((((y != 0) || ( z != 0)) ? 1 : 0));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, y, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, y, z);
    }
    return (add_ordered(x, y, z, count));
  }

  /*@Pure*/
  public boolean isLogicalOr() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(LogicalOrLong_xyz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // Note that
            // x == y && y == z does NOT imply x == z because of possibly
            // missing values.  For example:
            //
            //  Sample    X         Y           Z
            //    1       1         1           missing
            //    2       0         missing     1
            //    3       missing   0           0
            //
            //  The best solution seems to be to include all three
            //  equalities for the suppression

            // (r == y) && (y == z) && (r == z) && (r is boolean)
            //    ==> r = y | z
            new NISuppression(result_eq_arg1, arg1_eq_arg2, result_eq_arg2,
                               result_boolean, suppressee),

            // (r == y) && (z == 0) && (r is boolean) ==> r = y | z
            new NISuppression(result_eq_arg1, result_boolean, arg2_eq_0,
                               suppressee),

            // (r == z) && (y == 0) && (r is boolean) ==> r = y | z
            new NISuppression(result_eq_arg2, result_boolean, arg1_eq_0,
                               suppressee),

            // (r == 1) && (y == 1) && (z boolean)
            new NISuppression(result_eq_1, arg1_eq_1, arg2_boolean, suppressee),

            // (r == 1) && (z == 1) && (y boolean)
            new NISuppression(result_eq_1, arg2_eq_1, arg1_boolean, suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = LogicalOr(x, z)} over three long
 * scalars. For logical operations, Daikon treats 0 as false and all other values as true.
 */
public static class LogicalOrLong_yxz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ LogicalOrLong_yxz proto = new /*@Prototype*/ LogicalOrLong_yxz ();

  /** Returns the prototype invariant for LogicalOrLong_yxz */
  public static /*@Prototype*/ LogicalOrLong_yxz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected LogicalOrLong_yxz instantiate_dyn(/*>>> @Prototype LogicalOrLong_yxz this,*/ PptSlice slice) {
    return new LogicalOrLong_yxz (slice);
  }

  private LogicalOrLong_yxz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ LogicalOrLong_yxz () {
    super();
  }

  private static String[] method_name = new String[] {"", " || ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied LogicalOrLong_yxz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert LogicalOrLong_yxz.function_id == -1;
    LogicalOrLong_yxz.function_id = function_id;
  }

  private static int var_order = 2;

  public int get_var_order(/*>>>@GuardSatisfied LogicalOrLong_yxz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long z) {

      if ((x < 0) || (x > 1)) {
        throw new ArithmeticException("arg1 (" + x + ") is not boolean ");
      }
      if ((z < 0) || (z > 1)) {
        throw new ArithmeticException("arg2 (" + z + ") is not boolean ");
      }

    return ((((x != 0) || ( z != 0)) ? 1 : 0));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, x, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, x, z);
    }
    return (add_ordered(y, x, z, count));
  }

  /*@Pure*/
  public boolean isLogicalOr() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(LogicalOrLong_yxz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // Note that
            // x == y && y == z does NOT imply x == z because of possibly
            // missing values.  For example:
            //
            //  Sample    X         Y           Z
            //    1       1         1           missing
            //    2       0         missing     1
            //    3       missing   0           0
            //
            //  The best solution seems to be to include all three
            //  equalities for the suppression

            // (r == x) && (x == z) && (r == z) && (r is boolean)
            //    ==> r = x | z
            new NISuppression(result_eq_arg1, arg1_eq_arg2, result_eq_arg2,
                               result_boolean, suppressee),

            // (r == x) && (z == 0) && (r is boolean) ==> r = x | z
            new NISuppression(result_eq_arg1, result_boolean, arg2_eq_0,
                               suppressee),

            // (r == z) && (x == 0) && (r is boolean) ==> r = x | z
            new NISuppression(result_eq_arg2, result_boolean, arg1_eq_0,
                               suppressee),

            // (r == 1) && (x == 1) && (z boolean)
            new NISuppression(result_eq_1, arg1_eq_1, arg2_boolean, suppressee),

            // (r == 1) && (z == 1) && (x boolean)
            new NISuppression(result_eq_1, arg2_eq_1, arg1_boolean, suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = LogicalOr(x, y)} over three long
 * scalars. For logical operations, Daikon treats 0 as false and all other values as true.
 */
public static class LogicalOrLong_zxy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ LogicalOrLong_zxy proto = new /*@Prototype*/ LogicalOrLong_zxy ();

  /** Returns the prototype invariant for LogicalOrLong_zxy */
  public static /*@Prototype*/ LogicalOrLong_zxy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected LogicalOrLong_zxy instantiate_dyn(/*>>> @Prototype LogicalOrLong_zxy this,*/ PptSlice slice) {
    return new LogicalOrLong_zxy (slice);
  }

  private LogicalOrLong_zxy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ LogicalOrLong_zxy () {
    super();
  }

  private static String[] method_name = new String[] {"", " || ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied LogicalOrLong_zxy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert LogicalOrLong_zxy.function_id == -1;
    LogicalOrLong_zxy.function_id = function_id;
  }

  private static int var_order = 3;

  public int get_var_order(/*>>>@GuardSatisfied LogicalOrLong_zxy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long y) {

      if ((x < 0) || (x > 1)) {
        throw new ArithmeticException("arg1 (" + x + ") is not boolean ");
      }
      if ((y < 0) || (y > 1)) {
        throw new ArithmeticException("arg2 (" + y + ") is not boolean ");
      }

    return ((((x != 0) || ( y != 0)) ? 1 : 0));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, x, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, x, y);
    }
    return (add_ordered(z, x, y, count));
  }

  /*@Pure*/
  public boolean isLogicalOr() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(LogicalOrLong_zxy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // Note that
            // x == y && y == z does NOT imply x == z because of possibly
            // missing values.  For example:
            //
            //  Sample    X         Y           Z
            //    1       1         1           missing
            //    2       0         missing     1
            //    3       missing   0           0
            //
            //  The best solution seems to be to include all three
            //  equalities for the suppression

            // (r == x) && (x == y) && (r == y) && (r is boolean)
            //    ==> r = x | y
            new NISuppression(result_eq_arg1, arg1_eq_arg2, result_eq_arg2,
                               result_boolean, suppressee),

            // (r == x) && (y == 0) && (r is boolean) ==> r = x | y
            new NISuppression(result_eq_arg1, result_boolean, arg2_eq_0,
                               suppressee),

            // (r == y) && (x == 0) && (r is boolean) ==> r = x | y
            new NISuppression(result_eq_arg2, result_boolean, arg1_eq_0,
                               suppressee),

            // (r == 1) && (x == 1) && (y boolean)
            new NISuppression(result_eq_1, arg1_eq_1, arg2_boolean, suppressee),

            // (r == 1) && (y == 1) && (x boolean)
            new NISuppression(result_eq_1, arg2_eq_1, arg1_boolean, suppressee),

          });

  // Create a suppression factory for functionBinary

}

  // #define EQUALITY_SUPPRESS 1

  // default is that it is not this function, overriden in the subclass
  /*@Pure*/
  public boolean isGcd() {
    return false;
  }

/**
 * Represents the invariant {@code x = Gcd(y, z)} over three long
 * scalars. 
 */
public static class GcdLong_xyz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ GcdLong_xyz proto = new /*@Prototype*/ GcdLong_xyz ();

  /** Returns the prototype invariant for GcdLong_xyz */
  public static /*@Prototype*/ GcdLong_xyz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected GcdLong_xyz instantiate_dyn(/*>>> @Prototype GcdLong_xyz this,*/ PptSlice slice) {
    return new GcdLong_xyz (slice);
  }

  private GcdLong_xyz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ GcdLong_xyz () {
    super();
  }

  private static String[] method_name = new String[] {"plume.MathMDE.gcd(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied GcdLong_xyz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert GcdLong_xyz.function_id == -1;
    GcdLong_xyz.function_id = function_id;
  }

  private static int var_order = 1;

  public int get_var_order(/*>>>@GuardSatisfied GcdLong_xyz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long y, long z) {

    return (MathMDE.gcd(y, z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, y, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, y, z);
    }
    return (add_ordered(x, y, z, count));
  }

  /*@Pure*/
  public boolean isGcd() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(GcdLong_xyz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    // gcd (0, y) == y
    // gcd (0, 0) == 0
    // gcd (1, y) == 1

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == y) && (y == z) && (r == z) && (r >= 0)
            //    ==> r = Gcd (y, z)
            new NISuppression(result_eq_arg1, arg1_eq_arg2, result_eq_arg2,
                               result_ge_0, suppressee),

            // (r == y) && (z == 0) && (r >= 0) ==> r = gcd (y,z)
            new NISuppression(result_eq_arg1, result_ge_0, arg2_eq_0, suppressee),

            // (r == z) && (y == 0) && (r >= 0) ==> r = gcd (y,z)
            new NISuppression(result_eq_arg2, result_ge_0, arg1_eq_0, suppressee),

            // (r == 1) && (z == 1)        ==> r = gcd (y, art2)
            new NISuppression(result_eq_1, arg2_eq_1, suppressee),

            // (r == 1) && (y == 1)        ==> r = gcd (y, art2)
            new NISuppression(result_eq_1, arg1_eq_1, suppressee),

            // (r == y) && (y divides z) && (r >= 0)
            new NISuppression(result_eq_arg1, arg1_divides_arg2, result_ge_0, suppressee),

            // (r == z) && (z divides y) && (r >= 0)
            new NISuppression(result_eq_arg2, arg2_divides_arg1, result_ge_0, suppressee),

            // (r == z) && (z boolean) && (z==0 ==> y==0)
            // 0 = gcd (y, 0) true when (y == 0)
            // 1 = gcd (y, 1) always true
            new NISuppression(result_eq_arg2, arg2_track0_arg1, arg2_boolean,
                               suppressee),

            // (r == y) && (y boolean) && (y==0 ==> z==0)
            // 0 = gcd (0, z), true if (z == 0)
            // 1 = gcd (1, z), always true
            new NISuppression(result_eq_arg1, arg1_boolean, arg1_track0_arg2,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = Gcd(x, z)} over three long
 * scalars. 
 */
public static class GcdLong_yxz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ GcdLong_yxz proto = new /*@Prototype*/ GcdLong_yxz ();

  /** Returns the prototype invariant for GcdLong_yxz */
  public static /*@Prototype*/ GcdLong_yxz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected GcdLong_yxz instantiate_dyn(/*>>> @Prototype GcdLong_yxz this,*/ PptSlice slice) {
    return new GcdLong_yxz (slice);
  }

  private GcdLong_yxz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ GcdLong_yxz () {
    super();
  }

  private static String[] method_name = new String[] {"plume.MathMDE.gcd(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied GcdLong_yxz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert GcdLong_yxz.function_id == -1;
    GcdLong_yxz.function_id = function_id;
  }

  private static int var_order = 2;

  public int get_var_order(/*>>>@GuardSatisfied GcdLong_yxz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long z) {

    return (MathMDE.gcd(x, z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, x, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, x, z);
    }
    return (add_ordered(y, x, z, count));
  }

  /*@Pure*/
  public boolean isGcd() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(GcdLong_yxz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    // gcd (0, y) == y
    // gcd (0, 0) == 0
    // gcd (1, y) == 1

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == x) && (x == z) && (r == z) && (r >= 0)
            //    ==> r = Gcd (x, z)
            new NISuppression(result_eq_arg1, arg1_eq_arg2, result_eq_arg2,
                               result_ge_0, suppressee),

            // (r == x) && (z == 0) && (r >= 0) ==> r = gcd (x,z)
            new NISuppression(result_eq_arg1, result_ge_0, arg2_eq_0, suppressee),

            // (r == z) && (x == 0) && (r >= 0) ==> r = gcd (x,z)
            new NISuppression(result_eq_arg2, result_ge_0, arg1_eq_0, suppressee),

            // (r == 1) && (z == 1)        ==> r = gcd (x, art2)
            new NISuppression(result_eq_1, arg2_eq_1, suppressee),

            // (r == 1) && (x == 1)        ==> r = gcd (x, art2)
            new NISuppression(result_eq_1, arg1_eq_1, suppressee),

            // (r == x) && (x divides z) && (r >= 0)
            new NISuppression(result_eq_arg1, arg1_divides_arg2, result_ge_0, suppressee),

            // (r == z) && (z divides x) && (r >= 0)
            new NISuppression(result_eq_arg2, arg2_divides_arg1, result_ge_0, suppressee),

            // (r == z) && (z boolean) && (z==0 ==> x==0)
            // 0 = gcd (x, 0) true when (x == 0)
            // 1 = gcd (x, 1) always true
            new NISuppression(result_eq_arg2, arg2_track0_arg1, arg2_boolean,
                               suppressee),

            // (r == x) && (x boolean) && (x==0 ==> z==0)
            // 0 = gcd (0, z), true if (z == 0)
            // 1 = gcd (1, z), always true
            new NISuppression(result_eq_arg1, arg1_boolean, arg1_track0_arg2,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = Gcd(x, y)} over three long
 * scalars. 
 */
public static class GcdLong_zxy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ GcdLong_zxy proto = new /*@Prototype*/ GcdLong_zxy ();

  /** Returns the prototype invariant for GcdLong_zxy */
  public static /*@Prototype*/ GcdLong_zxy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected GcdLong_zxy instantiate_dyn(/*>>> @Prototype GcdLong_zxy this,*/ PptSlice slice) {
    return new GcdLong_zxy (slice);
  }

  private GcdLong_zxy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ GcdLong_zxy () {
    super();
  }

  private static String[] method_name = new String[] {"plume.MathMDE.gcd(", ", ", ")"};

  public String[] get_method_name(/*>>>@GuardSatisfied GcdLong_zxy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert GcdLong_zxy.function_id == -1;
    GcdLong_zxy.function_id = function_id;
  }

  private static int var_order = 3;

  public int get_var_order(/*>>>@GuardSatisfied GcdLong_zxy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return true;
  }

  public long func(long x, long y) {

    return (MathMDE.gcd(x, y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, x, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, x, y);
    }
    return (add_ordered(z, x, y, count));
  }

  /*@Pure*/
  public boolean isGcd() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(GcdLong_zxy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    // gcd (0, y) == y
    // gcd (0, 0) == 0
    // gcd (1, y) == 1

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == x) && (x == y) && (r == y) && (r >= 0)
            //    ==> r = Gcd (x, y)
            new NISuppression(result_eq_arg1, arg1_eq_arg2, result_eq_arg2,
                               result_ge_0, suppressee),

            // (r == x) && (y == 0) && (r >= 0) ==> r = gcd (x,y)
            new NISuppression(result_eq_arg1, result_ge_0, arg2_eq_0, suppressee),

            // (r == y) && (x == 0) && (r >= 0) ==> r = gcd (x,y)
            new NISuppression(result_eq_arg2, result_ge_0, arg1_eq_0, suppressee),

            // (r == 1) && (y == 1)        ==> r = gcd (x, art2)
            new NISuppression(result_eq_1, arg2_eq_1, suppressee),

            // (r == 1) && (x == 1)        ==> r = gcd (x, art2)
            new NISuppression(result_eq_1, arg1_eq_1, suppressee),

            // (r == x) && (x divides y) && (r >= 0)
            new NISuppression(result_eq_arg1, arg1_divides_arg2, result_ge_0, suppressee),

            // (r == y) && (y divides x) && (r >= 0)
            new NISuppression(result_eq_arg2, arg2_divides_arg1, result_ge_0, suppressee),

            // (r == y) && (y boolean) && (y==0 ==> x==0)
            // 0 = gcd (x, 0) true when (x == 0)
            // 1 = gcd (x, 1) always true
            new NISuppression(result_eq_arg2, arg2_track0_arg1, arg2_boolean,
                               suppressee),

            // (r == x) && (x boolean) && (x==0 ==> y==0)
            // 0 = gcd (0, y), true if (y == 0)
            // 1 = gcd (1, y), always true
            new NISuppression(result_eq_arg1, arg1_boolean, arg1_track0_arg2,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

  // default is that it is not this function, overriden in the subclass
  /*@Pure*/
  public boolean isMod() {
    return false;
  }

/**
 * Represents the invariant {@code x = Mod(y, z)} over three long
 * scalars. 
 */
public static class ModLong_xyz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ ModLong_xyz proto = new /*@Prototype*/ ModLong_xyz ();

  /** Returns the prototype invariant for ModLong_xyz */
  public static /*@Prototype*/ ModLong_xyz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected ModLong_xyz instantiate_dyn(/*>>> @Prototype ModLong_xyz this,*/ PptSlice slice) {
    return new ModLong_xyz (slice);
  }

  private ModLong_xyz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ ModLong_xyz () {
    super();
  }

  private static String[] method_name = new String[] {"", " % ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied ModLong_xyz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert ModLong_xyz.function_id == -1;
    ModLong_xyz.function_id = function_id;
  }

  private static int var_order = 1;

  public int get_var_order(/*>>>@GuardSatisfied ModLong_xyz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long y, long z) {

    return ((y % z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, y, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, y, z);
    }
    return (add_ordered(x, y, z, count));
  }

  /*@Pure*/
  public boolean isMod() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(ModLong_xyz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {
            // anything mod 0 is undefined
            // (r == y) && (y < z) && (z != 0) && (r >= 0) ==> r = y % z
            new NISuppression(result_eq_arg1, arg1_lt_arg2, arg2_ne_0, result_ge_0, suppressee),

            // (r == 0) && ((y % z) == 0)
            new NISuppression(result_eq_0, arg2_divides_arg1, suppressee),

            // These are unnecessary as the divides invariant handles these
            // nicely.
            // (r == 0) && (z == 1)      ==> r = y % z
            // new NISuppression (result_eq_0, arg2_eq_1, suppressee),

            // (r == 0) && (y == z)
            // new NISuppression (result_eq_0, arg1_eq_arg2, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = Mod(x, z)} over three long
 * scalars. 
 */
public static class ModLong_yxz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ ModLong_yxz proto = new /*@Prototype*/ ModLong_yxz ();

  /** Returns the prototype invariant for ModLong_yxz */
  public static /*@Prototype*/ ModLong_yxz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected ModLong_yxz instantiate_dyn(/*>>> @Prototype ModLong_yxz this,*/ PptSlice slice) {
    return new ModLong_yxz (slice);
  }

  private ModLong_yxz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ ModLong_yxz () {
    super();
  }

  private static String[] method_name = new String[] {"", " % ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied ModLong_yxz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert ModLong_yxz.function_id == -1;
    ModLong_yxz.function_id = function_id;
  }

  private static int var_order = 2;

  public int get_var_order(/*>>>@GuardSatisfied ModLong_yxz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long x, long z) {

    return ((x % z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, x, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, x, z);
    }
    return (add_ordered(y, x, z, count));
  }

  /*@Pure*/
  public boolean isMod() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(ModLong_yxz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {
            // anything mod 0 is undefined
            // (r == x) && (x < z) && (z != 0) && (r >= 0) ==> r = x % z
            new NISuppression(result_eq_arg1, arg1_lt_arg2, arg2_ne_0, result_ge_0, suppressee),

            // (r == 0) && ((x % z) == 0)
            new NISuppression(result_eq_0, arg2_divides_arg1, suppressee),

            // These are unnecessary as the divides invariant handles these
            // nicely.
            // (r == 0) && (z == 1)      ==> r = x % z
            // new NISuppression (result_eq_0, arg2_eq_1, suppressee),

            // (r == 0) && (x == z)
            // new NISuppression (result_eq_0, arg1_eq_arg2, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = Mod(x, y)} over three long
 * scalars. 
 */
public static class ModLong_zxy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ ModLong_zxy proto = new /*@Prototype*/ ModLong_zxy ();

  /** Returns the prototype invariant for ModLong_zxy */
  public static /*@Prototype*/ ModLong_zxy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected ModLong_zxy instantiate_dyn(/*>>> @Prototype ModLong_zxy this,*/ PptSlice slice) {
    return new ModLong_zxy (slice);
  }

  private ModLong_zxy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ ModLong_zxy () {
    super();
  }

  private static String[] method_name = new String[] {"", " % ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied ModLong_zxy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert ModLong_zxy.function_id == -1;
    ModLong_zxy.function_id = function_id;
  }

  private static int var_order = 3;

  public int get_var_order(/*>>>@GuardSatisfied ModLong_zxy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long x, long y) {

    return ((x % y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, x, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, x, y);
    }
    return (add_ordered(z, x, y, count));
  }

  /*@Pure*/
  public boolean isMod() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(ModLong_zxy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {
            // anything mod 0 is undefined
            // (r == x) && (x < y) && (y != 0) && (r >= 0) ==> r = x % y
            new NISuppression(result_eq_arg1, arg1_lt_arg2, arg2_ne_0, result_ge_0, suppressee),

            // (r == 0) && ((x % y) == 0)
            new NISuppression(result_eq_0, arg2_divides_arg1, suppressee),

            // These are unnecessary as the divides invariant handles these
            // nicely.
            // (r == 0) && (y == 1)      ==> r = x % y
            // new NISuppression (result_eq_0, arg2_eq_1, suppressee),

            // (r == 0) && (x == y)
            // new NISuppression (result_eq_0, arg1_eq_arg2, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code x = Mod(z, y)} over three long
 * scalars. 
 */
public static class ModLong_xzy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ ModLong_xzy proto = new /*@Prototype*/ ModLong_xzy ();

  /** Returns the prototype invariant for ModLong_xzy */
  public static /*@Prototype*/ ModLong_xzy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected ModLong_xzy instantiate_dyn(/*>>> @Prototype ModLong_xzy this,*/ PptSlice slice) {
    return new ModLong_xzy (slice);
  }

  private ModLong_xzy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ ModLong_xzy () {
    super();
  }

  private static String[] method_name = new String[] {"", " % ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied ModLong_xzy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert ModLong_xzy.function_id == -1;
    ModLong_xzy.function_id = function_id;
  }

  private static int var_order = 4;

  public int get_var_order(/*>>>@GuardSatisfied ModLong_xzy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long z, long y) {

    return ((z % y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, z, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, z, y);
    }
    return (add_ordered(x, z, y, count));
  }

  /*@Pure*/
  public boolean isMod() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(ModLong_xzy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 2, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 2, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(2, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 2, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {
            // anything mod 0 is undefined
            // (r == z) && (z < y) && (y != 0) && (r >= 0) ==> r = z % y
            new NISuppression(result_eq_arg1, arg1_lt_arg2, arg2_ne_0, result_ge_0, suppressee),

            // (r == 0) && ((z % y) == 0)
            new NISuppression(result_eq_0, arg2_divides_arg1, suppressee),

            // These are unnecessary as the divides invariant handles these
            // nicely.
            // (r == 0) && (y == 1)      ==> r = z % y
            // new NISuppression (result_eq_0, arg2_eq_1, suppressee),

            // (r == 0) && (z == y)
            // new NISuppression (result_eq_0, arg1_eq_arg2, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = Mod(z, x)} over three long
 * scalars. 
 */
public static class ModLong_yzx extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ ModLong_yzx proto = new /*@Prototype*/ ModLong_yzx ();

  /** Returns the prototype invariant for ModLong_yzx */
  public static /*@Prototype*/ ModLong_yzx get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected ModLong_yzx instantiate_dyn(/*>>> @Prototype ModLong_yzx this,*/ PptSlice slice) {
    return new ModLong_yzx (slice);
  }

  private ModLong_yzx (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ ModLong_yzx () {
    super();
  }

  private static String[] method_name = new String[] {"", " % ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied ModLong_yzx this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert ModLong_yzx.function_id == -1;
    ModLong_yzx.function_id = function_id;
  }

  private static int var_order = 5;

  public int get_var_order(/*>>>@GuardSatisfied ModLong_yzx this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long z, long x) {

    return ((z % x));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, z, x, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, z, x);
    }
    return (add_ordered(y, z, x, count));
  }

  /*@Pure*/
  public boolean isMod() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(ModLong_yzx.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(2, 0, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(0, 2, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(0, 2, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(0, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(0, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(2, 0, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(0, 2, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(0, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {
            // anything mod 0 is undefined
            // (r == z) && (z < x) && (x != 0) && (r >= 0) ==> r = z % x
            new NISuppression(result_eq_arg1, arg1_lt_arg2, arg2_ne_0, result_ge_0, suppressee),

            // (r == 0) && ((z % x) == 0)
            new NISuppression(result_eq_0, arg2_divides_arg1, suppressee),

            // These are unnecessary as the divides invariant handles these
            // nicely.
            // (r == 0) && (x == 1)      ==> r = z % x
            // new NISuppression (result_eq_0, arg2_eq_1, suppressee),

            // (r == 0) && (z == x)
            // new NISuppression (result_eq_0, arg1_eq_arg2, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = Mod(y, x)} over three long
 * scalars. 
 */
public static class ModLong_zyx extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  private static /*@Prototype*/ ModLong_zyx proto = new /*@Prototype*/ ModLong_zyx ();

  /** Returns the prototype invariant for ModLong_zyx */
  public static /*@Prototype*/ ModLong_zyx get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected ModLong_zyx instantiate_dyn(/*>>> @Prototype ModLong_zyx this,*/ PptSlice slice) {
    return new ModLong_zyx (slice);
  }

  private ModLong_zyx (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ ModLong_zyx () {
    super();
  }

  private static String[] method_name = new String[] {"", " % ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied ModLong_zyx this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert ModLong_zyx.function_id == -1;
    ModLong_zyx.function_id = function_id;
  }

  private static int var_order = 6;

  public int get_var_order(/*>>>@GuardSatisfied ModLong_zyx this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long y, long x) {

    return ((y % x));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, y, x, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, y, x);
    }
    return (add_ordered(z, y, x, count));
  }

  /*@Pure*/
  public boolean isMod() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(ModLong_zyx.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 0, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(0, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(0, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 0, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(0, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(0, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
      new NISuppressionSet(
          new NISuppression[] {
            // anything mod 0 is undefined
            // (r == y) && (y < x) && (x != 0) && (r >= 0) ==> r = y % x
            new NISuppression(result_eq_arg1, arg1_lt_arg2, arg2_ne_0, result_ge_0, suppressee),

            // (r == 0) && ((y % x) == 0)
            new NISuppression(result_eq_0, arg2_divides_arg1, suppressee),

            // These are unnecessary as the divides invariant handles these
            // nicely.
            // (r == 0) && (x == 1)      ==> r = y % x
            // new NISuppression (result_eq_0, arg2_eq_1, suppressee),

            // (r == 0) && (y == x)
            // new NISuppression (result_eq_0, arg1_eq_arg2, suppressee),
          });

  // Create a suppression factory for functionBinary

}

  // default is that it is not this function, overriden in the subclass
  /*@Pure*/
  public boolean isLshift() {
    return false;
  }

/**
 * Represents the invariant {@code x = Lshift(y, z)} over three long
 * scalars. 
 */
public static class LshiftLong_xyz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // z must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ LshiftLong_xyz proto = new /*@Prototype*/ LshiftLong_xyz ();

  /** Returns the prototype invariant for LshiftLong_xyz */
  public static /*@Prototype*/ LshiftLong_xyz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected LshiftLong_xyz instantiate_dyn(/*>>> @Prototype LshiftLong_xyz this,*/ PptSlice slice) {
    return new LshiftLong_xyz (slice);
  }

  private LshiftLong_xyz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ LshiftLong_xyz () {
    super();
  }

  private static String[] method_name = new String[] {"", " << ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied LshiftLong_xyz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert LshiftLong_xyz.function_id == -1;
    LshiftLong_xyz.function_id = function_id;
  }

  private static int var_order = 1;

  public int get_var_order(/*>>>@GuardSatisfied LshiftLong_xyz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long y, long z) {

      if ((z < arg2_bound[0]) || (z > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + z + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((y << z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, y, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, y, z);
    }
    return (add_ordered(x, y, z, count));
  }

  /*@Pure*/
  public boolean isLshift() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(LshiftLong_xyz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == y) && (z == 0) ==> r = y << z
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (y == 0) && (0 <= z <= 63)   ==> r = y << z
            new NISuppression(result_eq_0, arg1_eq_0, arg2_valid_shift,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = Lshift(x, z)} over three long
 * scalars. 
 */
public static class LshiftLong_yxz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // z must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ LshiftLong_yxz proto = new /*@Prototype*/ LshiftLong_yxz ();

  /** Returns the prototype invariant for LshiftLong_yxz */
  public static /*@Prototype*/ LshiftLong_yxz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected LshiftLong_yxz instantiate_dyn(/*>>> @Prototype LshiftLong_yxz this,*/ PptSlice slice) {
    return new LshiftLong_yxz (slice);
  }

  private LshiftLong_yxz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ LshiftLong_yxz () {
    super();
  }

  private static String[] method_name = new String[] {"", " << ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied LshiftLong_yxz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert LshiftLong_yxz.function_id == -1;
    LshiftLong_yxz.function_id = function_id;
  }

  private static int var_order = 2;

  public int get_var_order(/*>>>@GuardSatisfied LshiftLong_yxz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long x, long z) {

      if ((z < arg2_bound[0]) || (z > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + z + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((x << z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, x, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, x, z);
    }
    return (add_ordered(y, x, z, count));
  }

  /*@Pure*/
  public boolean isLshift() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(LshiftLong_yxz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == x) && (z == 0) ==> r = x << z
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (x == 0) && (0 <= z <= 63)   ==> r = x << z
            new NISuppression(result_eq_0, arg1_eq_0, arg2_valid_shift,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = Lshift(x, y)} over three long
 * scalars. 
 */
public static class LshiftLong_zxy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // y must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ LshiftLong_zxy proto = new /*@Prototype*/ LshiftLong_zxy ();

  /** Returns the prototype invariant for LshiftLong_zxy */
  public static /*@Prototype*/ LshiftLong_zxy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected LshiftLong_zxy instantiate_dyn(/*>>> @Prototype LshiftLong_zxy this,*/ PptSlice slice) {
    return new LshiftLong_zxy (slice);
  }

  private LshiftLong_zxy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ LshiftLong_zxy () {
    super();
  }

  private static String[] method_name = new String[] {"", " << ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied LshiftLong_zxy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert LshiftLong_zxy.function_id == -1;
    LshiftLong_zxy.function_id = function_id;
  }

  private static int var_order = 3;

  public int get_var_order(/*>>>@GuardSatisfied LshiftLong_zxy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long x, long y) {

      if ((y < arg2_bound[0]) || (y > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + y + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((x << y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, x, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, x, y);
    }
    return (add_ordered(z, x, y, count));
  }

  /*@Pure*/
  public boolean isLshift() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(LshiftLong_zxy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == x) && (y == 0) ==> r = x << y
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (x == 0) && (0 <= y <= 63)   ==> r = x << y
            new NISuppression(result_eq_0, arg1_eq_0, arg2_valid_shift,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code x = Lshift(z, y)} over three long
 * scalars. 
 */
public static class LshiftLong_xzy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // y must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ LshiftLong_xzy proto = new /*@Prototype*/ LshiftLong_xzy ();

  /** Returns the prototype invariant for LshiftLong_xzy */
  public static /*@Prototype*/ LshiftLong_xzy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected LshiftLong_xzy instantiate_dyn(/*>>> @Prototype LshiftLong_xzy this,*/ PptSlice slice) {
    return new LshiftLong_xzy (slice);
  }

  private LshiftLong_xzy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ LshiftLong_xzy () {
    super();
  }

  private static String[] method_name = new String[] {"", " << ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied LshiftLong_xzy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert LshiftLong_xzy.function_id == -1;
    LshiftLong_xzy.function_id = function_id;
  }

  private static int var_order = 4;

  public int get_var_order(/*>>>@GuardSatisfied LshiftLong_xzy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long z, long y) {

      if ((y < arg2_bound[0]) || (y > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + y + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((z << y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, z, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, z, y);
    }
    return (add_ordered(x, z, y, count));
  }

  /*@Pure*/
  public boolean isLshift() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(LshiftLong_xzy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 2, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 2, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(2, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 2, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == z) && (y == 0) ==> r = z << y
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (z == 0) && (0 <= y <= 63)   ==> r = z << y
            new NISuppression(result_eq_0, arg1_eq_0, arg2_valid_shift,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = Lshift(z, x)} over three long
 * scalars. 
 */
public static class LshiftLong_yzx extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // x must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ LshiftLong_yzx proto = new /*@Prototype*/ LshiftLong_yzx ();

  /** Returns the prototype invariant for LshiftLong_yzx */
  public static /*@Prototype*/ LshiftLong_yzx get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected LshiftLong_yzx instantiate_dyn(/*>>> @Prototype LshiftLong_yzx this,*/ PptSlice slice) {
    return new LshiftLong_yzx (slice);
  }

  private LshiftLong_yzx (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ LshiftLong_yzx () {
    super();
  }

  private static String[] method_name = new String[] {"", " << ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied LshiftLong_yzx this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert LshiftLong_yzx.function_id == -1;
    LshiftLong_yzx.function_id = function_id;
  }

  private static int var_order = 5;

  public int get_var_order(/*>>>@GuardSatisfied LshiftLong_yzx this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long z, long x) {

      if ((x < arg2_bound[0]) || (x > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + x + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((z << x));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, z, x, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, z, x);
    }
    return (add_ordered(y, z, x, count));
  }

  /*@Pure*/
  public boolean isLshift() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(LshiftLong_yzx.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(2, 0, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(0, 2, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(0, 2, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(0, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(0, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(2, 0, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(0, 2, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(0, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == z) && (x == 0) ==> r = z << x
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (z == 0) && (0 <= x <= 63)   ==> r = z << x
            new NISuppression(result_eq_0, arg1_eq_0, arg2_valid_shift,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = Lshift(y, x)} over three long
 * scalars. 
 */
public static class LshiftLong_zyx extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // x must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ LshiftLong_zyx proto = new /*@Prototype*/ LshiftLong_zyx ();

  /** Returns the prototype invariant for LshiftLong_zyx */
  public static /*@Prototype*/ LshiftLong_zyx get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected LshiftLong_zyx instantiate_dyn(/*>>> @Prototype LshiftLong_zyx this,*/ PptSlice slice) {
    return new LshiftLong_zyx (slice);
  }

  private LshiftLong_zyx (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ LshiftLong_zyx () {
    super();
  }

  private static String[] method_name = new String[] {"", " << ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied LshiftLong_zyx this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert LshiftLong_zyx.function_id == -1;
    LshiftLong_zyx.function_id = function_id;
  }

  private static int var_order = 6;

  public int get_var_order(/*>>>@GuardSatisfied LshiftLong_zyx this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long y, long x) {

      if ((x < arg2_bound[0]) || (x > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + x + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((y << x));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, y, x, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, y, x);
    }
    return (add_ordered(z, y, x, count));
  }

  /*@Pure*/
  public boolean isLshift() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(LshiftLong_zyx.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 0, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(0, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(0, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 0, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(0, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(0, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == y) && (x == 0) ==> r = y << x
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (y == 0) && (0 <= x <= 63)   ==> r = y << x
            new NISuppression(result_eq_0, arg1_eq_0, arg2_valid_shift,
                               suppressee),

          });

  // Create a suppression factory for functionBinary

}

  // default is that it is not this function, overriden in the subclass
  /*@Pure*/
  public boolean isRshiftSigned() {
    return false;
  }

/**
 * Represents the invariant {@code x = RshiftSigned(y, z)} over three long
 * scalars. 
 */
public static class RshiftSignedLong_xyz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // z must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ RshiftSignedLong_xyz proto = new /*@Prototype*/ RshiftSignedLong_xyz ();

  /** Returns the prototype invariant for RshiftSignedLong_xyz */
  public static /*@Prototype*/ RshiftSignedLong_xyz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected RshiftSignedLong_xyz instantiate_dyn(/*>>> @Prototype RshiftSignedLong_xyz this,*/ PptSlice slice) {
    return new RshiftSignedLong_xyz (slice);
  }

  private RshiftSignedLong_xyz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ RshiftSignedLong_xyz () {
    super();
  }

  private static String[] method_name = new String[] {"", " >> ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied RshiftSignedLong_xyz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert RshiftSignedLong_xyz.function_id == -1;
    RshiftSignedLong_xyz.function_id = function_id;
  }

  private static int var_order = 1;

  public int get_var_order(/*>>>@GuardSatisfied RshiftSignedLong_xyz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long y, long z) {

      if ((z < arg2_bound[0]) || (z > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + z + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((y >> z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, y, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, y, z);
    }
    return (add_ordered(x, y, z, count));
  }

  /*@Pure*/
  public boolean isRshiftSigned() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(RshiftSignedLong_xyz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == y) && (z == 0) ==> r = y >>> z
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (y == 0) && (0 <= z <= 63)   ==> r = y >>> z
            // new NISuppression (result_eq_0, arg1_eq_0, arg2_valid_shift
            //                   ,suppressee),

            // (r == 0) && ((y >> z) == 0)
            new NISuppression(result_eq_0, arg1_shift0_arg2, suppressee),

            // (r == 0) && (z >= y) && (y >= 0) && (z valid shift)
            // This suppression really ought to have 2**z >= y, but we
            // don't have that invariant.  This still might catch a lot of these.
            // new NISuppression (result_eq_0, arg1_le_arg2, arg1_ge_0,
            //                   arg2_valid_shift, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = RshiftSigned(x, z)} over three long
 * scalars. 
 */
public static class RshiftSignedLong_yxz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // z must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ RshiftSignedLong_yxz proto = new /*@Prototype*/ RshiftSignedLong_yxz ();

  /** Returns the prototype invariant for RshiftSignedLong_yxz */
  public static /*@Prototype*/ RshiftSignedLong_yxz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected RshiftSignedLong_yxz instantiate_dyn(/*>>> @Prototype RshiftSignedLong_yxz this,*/ PptSlice slice) {
    return new RshiftSignedLong_yxz (slice);
  }

  private RshiftSignedLong_yxz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ RshiftSignedLong_yxz () {
    super();
  }

  private static String[] method_name = new String[] {"", " >> ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied RshiftSignedLong_yxz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert RshiftSignedLong_yxz.function_id == -1;
    RshiftSignedLong_yxz.function_id = function_id;
  }

  private static int var_order = 2;

  public int get_var_order(/*>>>@GuardSatisfied RshiftSignedLong_yxz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long x, long z) {

      if ((z < arg2_bound[0]) || (z > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + z + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((x >> z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, x, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, x, z);
    }
    return (add_ordered(y, x, z, count));
  }

  /*@Pure*/
  public boolean isRshiftSigned() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(RshiftSignedLong_yxz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == x) && (z == 0) ==> r = x >>> z
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (x == 0) && (0 <= z <= 63)   ==> r = x >>> z
            // new NISuppression (result_eq_0, arg1_eq_0, arg2_valid_shift
            //                   ,suppressee),

            // (r == 0) && ((x >> z) == 0)
            new NISuppression(result_eq_0, arg1_shift0_arg2, suppressee),

            // (r == 0) && (z >= x) && (x >= 0) && (z valid shift)
            // This suppression really ought to have 2**z >= x, but we
            // don't have that invariant.  This still might catch a lot of these.
            // new NISuppression (result_eq_0, arg1_le_arg2, arg1_ge_0,
            //                   arg2_valid_shift, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = RshiftSigned(x, y)} over three long
 * scalars. 
 */
public static class RshiftSignedLong_zxy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // y must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ RshiftSignedLong_zxy proto = new /*@Prototype*/ RshiftSignedLong_zxy ();

  /** Returns the prototype invariant for RshiftSignedLong_zxy */
  public static /*@Prototype*/ RshiftSignedLong_zxy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected RshiftSignedLong_zxy instantiate_dyn(/*>>> @Prototype RshiftSignedLong_zxy this,*/ PptSlice slice) {
    return new RshiftSignedLong_zxy (slice);
  }

  private RshiftSignedLong_zxy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ RshiftSignedLong_zxy () {
    super();
  }

  private static String[] method_name = new String[] {"", " >> ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied RshiftSignedLong_zxy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert RshiftSignedLong_zxy.function_id == -1;
    RshiftSignedLong_zxy.function_id = function_id;
  }

  private static int var_order = 3;

  public int get_var_order(/*>>>@GuardSatisfied RshiftSignedLong_zxy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long x, long y) {

      if ((y < arg2_bound[0]) || (y > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + y + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((x >> y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, x, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, x, y);
    }
    return (add_ordered(z, x, y, count));
  }

  /*@Pure*/
  public boolean isRshiftSigned() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(RshiftSignedLong_zxy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == x) && (y == 0) ==> r = x >>> y
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (x == 0) && (0 <= y <= 63)   ==> r = x >>> y
            // new NISuppression (result_eq_0, arg1_eq_0, arg2_valid_shift
            //                   ,suppressee),

            // (r == 0) && ((x >> y) == 0)
            new NISuppression(result_eq_0, arg1_shift0_arg2, suppressee),

            // (r == 0) && (y >= x) && (x >= 0) && (y valid shift)
            // This suppression really ought to have 2**y >= x, but we
            // don't have that invariant.  This still might catch a lot of these.
            // new NISuppression (result_eq_0, arg1_le_arg2, arg1_ge_0,
            //                   arg2_valid_shift, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code x = RshiftSigned(z, y)} over three long
 * scalars. 
 */
public static class RshiftSignedLong_xzy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // y must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ RshiftSignedLong_xzy proto = new /*@Prototype*/ RshiftSignedLong_xzy ();

  /** Returns the prototype invariant for RshiftSignedLong_xzy */
  public static /*@Prototype*/ RshiftSignedLong_xzy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected RshiftSignedLong_xzy instantiate_dyn(/*>>> @Prototype RshiftSignedLong_xzy this,*/ PptSlice slice) {
    return new RshiftSignedLong_xzy (slice);
  }

  private RshiftSignedLong_xzy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ RshiftSignedLong_xzy () {
    super();
  }

  private static String[] method_name = new String[] {"", " >> ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied RshiftSignedLong_xzy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert RshiftSignedLong_xzy.function_id == -1;
    RshiftSignedLong_xzy.function_id = function_id;
  }

  private static int var_order = 4;

  public int get_var_order(/*>>>@GuardSatisfied RshiftSignedLong_xzy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long z, long y) {

      if ((y < arg2_bound[0]) || (y > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + y + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((z >> y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, z, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, z, y);
    }
    return (add_ordered(x, z, y, count));
  }

  /*@Pure*/
  public boolean isRshiftSigned() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(RshiftSignedLong_xzy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 2, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 2, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(2, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 2, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == z) && (y == 0) ==> r = z >>> y
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (z == 0) && (0 <= y <= 63)   ==> r = z >>> y
            // new NISuppression (result_eq_0, arg1_eq_0, arg2_valid_shift
            //                   ,suppressee),

            // (r == 0) && ((z >> y) == 0)
            new NISuppression(result_eq_0, arg1_shift0_arg2, suppressee),

            // (r == 0) && (y >= z) && (z >= 0) && (y valid shift)
            // This suppression really ought to have 2**y >= z, but we
            // don't have that invariant.  This still might catch a lot of these.
            // new NISuppression (result_eq_0, arg1_le_arg2, arg1_ge_0,
            //                   arg2_valid_shift, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = RshiftSigned(z, x)} over three long
 * scalars. 
 */
public static class RshiftSignedLong_yzx extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // x must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ RshiftSignedLong_yzx proto = new /*@Prototype*/ RshiftSignedLong_yzx ();

  /** Returns the prototype invariant for RshiftSignedLong_yzx */
  public static /*@Prototype*/ RshiftSignedLong_yzx get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected RshiftSignedLong_yzx instantiate_dyn(/*>>> @Prototype RshiftSignedLong_yzx this,*/ PptSlice slice) {
    return new RshiftSignedLong_yzx (slice);
  }

  private RshiftSignedLong_yzx (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ RshiftSignedLong_yzx () {
    super();
  }

  private static String[] method_name = new String[] {"", " >> ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied RshiftSignedLong_yzx this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert RshiftSignedLong_yzx.function_id == -1;
    RshiftSignedLong_yzx.function_id = function_id;
  }

  private static int var_order = 5;

  public int get_var_order(/*>>>@GuardSatisfied RshiftSignedLong_yzx this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long z, long x) {

      if ((x < arg2_bound[0]) || (x > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + x + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((z >> x));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, z, x, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, z, x);
    }
    return (add_ordered(y, z, x, count));
  }

  /*@Pure*/
  public boolean isRshiftSigned() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(RshiftSignedLong_yzx.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(2, 0, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(0, 2, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(0, 2, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(0, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(0, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(2, 0, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(0, 2, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(0, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == z) && (x == 0) ==> r = z >>> x
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (z == 0) && (0 <= x <= 63)   ==> r = z >>> x
            // new NISuppression (result_eq_0, arg1_eq_0, arg2_valid_shift
            //                   ,suppressee),

            // (r == 0) && ((z >> x) == 0)
            new NISuppression(result_eq_0, arg1_shift0_arg2, suppressee),

            // (r == 0) && (x >= z) && (z >= 0) && (x valid shift)
            // This suppression really ought to have 2**x >= z, but we
            // don't have that invariant.  This still might catch a lot of these.
            // new NISuppression (result_eq_0, arg1_le_arg2, arg1_ge_0,
            //                   arg2_valid_shift, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = RshiftSigned(y, x)} over three long
 * scalars. 
 */
public static class RshiftSignedLong_zyx extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // x must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ RshiftSignedLong_zyx proto = new /*@Prototype*/ RshiftSignedLong_zyx ();

  /** Returns the prototype invariant for RshiftSignedLong_zyx */
  public static /*@Prototype*/ RshiftSignedLong_zyx get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected RshiftSignedLong_zyx instantiate_dyn(/*>>> @Prototype RshiftSignedLong_zyx this,*/ PptSlice slice) {
    return new RshiftSignedLong_zyx (slice);
  }

  private RshiftSignedLong_zyx (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ RshiftSignedLong_zyx () {
    super();
  }

  private static String[] method_name = new String[] {"", " >> ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied RshiftSignedLong_zyx this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert RshiftSignedLong_zyx.function_id == -1;
    RshiftSignedLong_zyx.function_id = function_id;
  }

  private static int var_order = 6;

  public int get_var_order(/*>>>@GuardSatisfied RshiftSignedLong_zyx this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long y, long x) {

      if ((x < arg2_bound[0]) || (x > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + x + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((y >> x));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, y, x, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, y, x);
    }
    return (add_ordered(z, y, x, count));
  }

  /*@Pure*/
  public boolean isRshiftSigned() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(RshiftSignedLong_zyx.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 0, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(0, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(0, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 0, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(0, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(0, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == y) && (x == 0) ==> r = y >>> x
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (y == 0) && (0 <= x <= 63)   ==> r = y >>> x
            // new NISuppression (result_eq_0, arg1_eq_0, arg2_valid_shift
            //                   ,suppressee),

            // (r == 0) && ((y >> x) == 0)
            new NISuppression(result_eq_0, arg1_shift0_arg2, suppressee),

            // (r == 0) && (x >= y) && (y >= 0) && (x valid shift)
            // This suppression really ought to have 2**x >= y, but we
            // don't have that invariant.  This still might catch a lot of these.
            // new NISuppression (result_eq_0, arg1_le_arg2, arg1_ge_0,
            //                   arg2_valid_shift, suppressee),
          });

  // Create a suppression factory for functionBinary

}

  // default is that it is not this function, overriden in the subclass
  /*@Pure*/
  public boolean isRshiftUnsigned() {
    return false;
  }

/**
 * Represents the invariant {@code x = RshiftUnsigned(y, z)} over three long
 * scalars. 
 */
public static class RshiftUnsignedLong_xyz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // z must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ RshiftUnsignedLong_xyz proto = new /*@Prototype*/ RshiftUnsignedLong_xyz ();

  /** Returns the prototype invariant for RshiftUnsignedLong_xyz */
  public static /*@Prototype*/ RshiftUnsignedLong_xyz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected RshiftUnsignedLong_xyz instantiate_dyn(/*>>> @Prototype RshiftUnsignedLong_xyz this,*/ PptSlice slice) {
    return new RshiftUnsignedLong_xyz (slice);
  }

  private RshiftUnsignedLong_xyz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ RshiftUnsignedLong_xyz () {
    super();
  }

  private static String[] method_name = new String[] {"", " >>> ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied RshiftUnsignedLong_xyz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert RshiftUnsignedLong_xyz.function_id == -1;
    RshiftUnsignedLong_xyz.function_id = function_id;
  }

  private static int var_order = 1;

  public int get_var_order(/*>>>@GuardSatisfied RshiftUnsignedLong_xyz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long y, long z) {

      if ((z < arg2_bound[0]) || (z > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + z + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((y >>> z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, y, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, y, z);
    }
    return (add_ordered(x, y, z, count));
  }

  /*@Pure*/
  public boolean isRshiftUnsigned() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(RshiftUnsignedLong_xyz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == y) && (z == 0) ==> r = y >>> z
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (y == 0) && (z valid shift) ==> r = y >>> z
            // new NISuppression (result_eq_0, arg1_eq_0, arg2_valid_shift
            //                   ,suppressee),

            // (r == 0) && ((y >> z) == 0)
            new NISuppression(result_eq_0, arg1_shift0_arg2, suppressee),

            // (r == 0) && (z >= y) && (y >= 0) && (z valid shift)
            // This suppression really ought to have 2**z >= y, but we
            // don't have that suppression.  This still might catch a lot of these.
            // new NISuppression (result_eq_0, arg1_le_arg2, arg1_ge_0,
            //                   arg2_valid_shift, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = RshiftUnsigned(x, z)} over three long
 * scalars. 
 */
public static class RshiftUnsignedLong_yxz extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // z must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ RshiftUnsignedLong_yxz proto = new /*@Prototype*/ RshiftUnsignedLong_yxz ();

  /** Returns the prototype invariant for RshiftUnsignedLong_yxz */
  public static /*@Prototype*/ RshiftUnsignedLong_yxz get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected RshiftUnsignedLong_yxz instantiate_dyn(/*>>> @Prototype RshiftUnsignedLong_yxz this,*/ PptSlice slice) {
    return new RshiftUnsignedLong_yxz (slice);
  }

  private RshiftUnsignedLong_yxz (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ RshiftUnsignedLong_yxz () {
    super();
  }

  private static String[] method_name = new String[] {"", " >>> ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied RshiftUnsignedLong_yxz this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert RshiftUnsignedLong_yxz.function_id == -1;
    RshiftUnsignedLong_yxz.function_id = function_id;
  }

  private static int var_order = 2;

  public int get_var_order(/*>>>@GuardSatisfied RshiftUnsignedLong_yxz this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long x, long z) {

      if ((z < arg2_bound[0]) || (z > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + z + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((x >>> z));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, x, z, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, x, z);
    }
    return (add_ordered(y, x, z, count));
  }

  /*@Pure*/
  public boolean isRshiftUnsigned() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(RshiftUnsignedLong_yxz.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 2, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(2, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(2, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 2, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(2, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(2, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == x) && (z == 0) ==> r = x >>> z
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (x == 0) && (z valid shift) ==> r = x >>> z
            // new NISuppression (result_eq_0, arg1_eq_0, arg2_valid_shift
            //                   ,suppressee),

            // (r == 0) && ((x >> z) == 0)
            new NISuppression(result_eq_0, arg1_shift0_arg2, suppressee),

            // (r == 0) && (z >= x) && (x >= 0) && (z valid shift)
            // This suppression really ought to have 2**z >= x, but we
            // don't have that suppression.  This still might catch a lot of these.
            // new NISuppression (result_eq_0, arg1_le_arg2, arg1_ge_0,
            //                   arg2_valid_shift, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = RshiftUnsigned(x, y)} over three long
 * scalars. 
 */
public static class RshiftUnsignedLong_zxy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // y must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ RshiftUnsignedLong_zxy proto = new /*@Prototype*/ RshiftUnsignedLong_zxy ();

  /** Returns the prototype invariant for RshiftUnsignedLong_zxy */
  public static /*@Prototype*/ RshiftUnsignedLong_zxy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected RshiftUnsignedLong_zxy instantiate_dyn(/*>>> @Prototype RshiftUnsignedLong_zxy this,*/ PptSlice slice) {
    return new RshiftUnsignedLong_zxy (slice);
  }

  private RshiftUnsignedLong_zxy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ RshiftUnsignedLong_zxy () {
    super();
  }

  private static String[] method_name = new String[] {"", " >>> ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied RshiftUnsignedLong_zxy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert RshiftUnsignedLong_zxy.function_id == -1;
    RshiftUnsignedLong_zxy.function_id = function_id;
  }

  private static int var_order = 3;

  public int get_var_order(/*>>>@GuardSatisfied RshiftUnsignedLong_zxy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long x, long y) {

      if ((y < arg2_bound[0]) || (y > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + y + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((x >>> y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, x, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, x, y);
    }
    return (add_ordered(z, x, y, count));
  }

  /*@Pure*/
  public boolean isRshiftUnsigned() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(RshiftUnsignedLong_zxy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 0, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 0, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(0, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 0, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == x) && (y == 0) ==> r = x >>> y
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (x == 0) && (y valid shift) ==> r = x >>> y
            // new NISuppression (result_eq_0, arg1_eq_0, arg2_valid_shift
            //                   ,suppressee),

            // (r == 0) && ((x >> y) == 0)
            new NISuppression(result_eq_0, arg1_shift0_arg2, suppressee),

            // (r == 0) && (y >= x) && (x >= 0) && (y valid shift)
            // This suppression really ought to have 2**y >= x, but we
            // don't have that suppression.  This still might catch a lot of these.
            // new NISuppression (result_eq_0, arg1_le_arg2, arg1_ge_0,
            //                   arg2_valid_shift, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code x = RshiftUnsigned(z, y)} over three long
 * scalars. 
 */
public static class RshiftUnsignedLong_xzy extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // y must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ RshiftUnsignedLong_xzy proto = new /*@Prototype*/ RshiftUnsignedLong_xzy ();

  /** Returns the prototype invariant for RshiftUnsignedLong_xzy */
  public static /*@Prototype*/ RshiftUnsignedLong_xzy get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected RshiftUnsignedLong_xzy instantiate_dyn(/*>>> @Prototype RshiftUnsignedLong_xzy this,*/ PptSlice slice) {
    return new RshiftUnsignedLong_xzy (slice);
  }

  private RshiftUnsignedLong_xzy (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ RshiftUnsignedLong_xzy () {
    super();
  }

  private static String[] method_name = new String[] {"", " >>> ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied RshiftUnsignedLong_xzy this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert RshiftUnsignedLong_xzy.function_id == -1;
    RshiftUnsignedLong_xzy.function_id = function_id;
  }

  private static int var_order = 4;

  public int get_var_order(/*>>>@GuardSatisfied RshiftUnsignedLong_xzy this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long z, long y) {

      if ((y < arg2_bound[0]) || (y > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + y + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((z >>> y));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(x, z, y, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", x, z, y);
    }
    return (add_ordered(x, z, y, count));
  }

  /*@Pure*/
  public boolean isRshiftUnsigned() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(RshiftUnsignedLong_xzy.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(0, 2, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(0, 1, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(2, 1, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(0, 2, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(0, 1, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(1, 2, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(0, 2, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(0, 1, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(1, 2, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(0,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(0, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(1, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(0,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(0, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(1, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(0,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(0, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(1, 2, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(2, 1, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(0, 2, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(0, 1, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(2, 1, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(1, 2, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(1, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == z) && (y == 0) ==> r = z >>> y
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (z == 0) && (y valid shift) ==> r = z >>> y
            // new NISuppression (result_eq_0, arg1_eq_0, arg2_valid_shift
            //                   ,suppressee),

            // (r == 0) && ((z >> y) == 0)
            new NISuppression(result_eq_0, arg1_shift0_arg2, suppressee),

            // (r == 0) && (y >= z) && (z >= 0) && (y valid shift)
            // This suppression really ought to have 2**y >= z, but we
            // don't have that suppression.  This still might catch a lot of these.
            // new NISuppression (result_eq_0, arg1_le_arg2, arg1_ge_0,
            //                   arg2_valid_shift, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code y = RshiftUnsigned(z, x)} over three long
 * scalars. 
 */
public static class RshiftUnsignedLong_yzx extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // x must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ RshiftUnsignedLong_yzx proto = new /*@Prototype*/ RshiftUnsignedLong_yzx ();

  /** Returns the prototype invariant for RshiftUnsignedLong_yzx */
  public static /*@Prototype*/ RshiftUnsignedLong_yzx get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected RshiftUnsignedLong_yzx instantiate_dyn(/*>>> @Prototype RshiftUnsignedLong_yzx this,*/ PptSlice slice) {
    return new RshiftUnsignedLong_yzx (slice);
  }

  private RshiftUnsignedLong_yzx (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ RshiftUnsignedLong_yzx () {
    super();
  }

  private static String[] method_name = new String[] {"", " >>> ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied RshiftUnsignedLong_yzx this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert RshiftUnsignedLong_yzx.function_id == -1;
    RshiftUnsignedLong_yzx.function_id = function_id;
  }

  private static int var_order = 5;

  public int get_var_order(/*>>>@GuardSatisfied RshiftUnsignedLong_yzx this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long z, long x) {

      if ((x < arg2_bound[0]) || (x > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + x + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((z >>> x));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(y, z, x, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", y, z, x);
    }
    return (add_ordered(y, z, x, count));
  }

  /*@Pure*/
  public boolean isRshiftUnsigned() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(RshiftUnsignedLong_yzx.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(1, 2, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(1, 0, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(2, 0, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(1, 2, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(0, 2, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(1, 2, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(0, 2, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(1,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(2, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(0, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(1,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(2, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(0, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(1,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(2, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(1, 2, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(0, 2, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(2, 0, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(1, 2, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(2, 0, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(0, 2, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(0, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == z) && (x == 0) ==> r = z >>> x
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (z == 0) && (x valid shift) ==> r = z >>> x
            // new NISuppression (result_eq_0, arg1_eq_0, arg2_valid_shift
            //                   ,suppressee),

            // (r == 0) && ((z >> x) == 0)
            new NISuppression(result_eq_0, arg1_shift0_arg2, suppressee),

            // (r == 0) && (x >= z) && (z >= 0) && (x valid shift)
            // This suppression really ought to have 2**x >= z, but we
            // don't have that suppression.  This still might catch a lot of these.
            // new NISuppression (result_eq_0, arg1_le_arg2, arg1_ge_0,
            //                   arg2_valid_shift, suppressee),
          });

  // Create a suppression factory for functionBinary

}

/**
 * Represents the invariant {@code z = RshiftUnsigned(y, x)} over three long
 * scalars. 
 */
public static class RshiftUnsignedLong_zyx extends FunctionBinary {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

    // x must be between arg2_bound[0] and arg2_bound[1] inclusive
    static int[] arg2_bound = {0, 63};

  private static /*@Prototype*/ RshiftUnsignedLong_zyx proto = new /*@Prototype*/ RshiftUnsignedLong_zyx ();

  /** Returns the prototype invariant for RshiftUnsignedLong_zyx */
  public static /*@Prototype*/ RshiftUnsignedLong_zyx get_proto() {
    return proto;
  }

  /** instantiate an invariant on the specified slice */
  protected RshiftUnsignedLong_zyx instantiate_dyn(/*>>> @Prototype RshiftUnsignedLong_zyx this,*/ PptSlice slice) {
    return new RshiftUnsignedLong_zyx (slice);
  }

  private RshiftUnsignedLong_zyx (PptSlice slice) {
    super(slice);
  }

  public /*@Prototype*/ RshiftUnsignedLong_zyx () {
    super();
  }

  private static String[] method_name = new String[] {"", " >>> ", ""};

  public String[] get_method_name(/*>>>@GuardSatisfied RshiftUnsignedLong_zyx this*/) {
    return method_name;
  }

  private static int function_id = -1;

  public int get_function_id() {
    return function_id;
  }

  public void set_function_id(int function_id) {
    assert RshiftUnsignedLong_zyx.function_id == -1;
    RshiftUnsignedLong_zyx.function_id = function_id;
  }

  private static int var_order = 6;

  public int get_var_order(/*>>>@GuardSatisfied RshiftUnsignedLong_zyx this*/) {
    return var_order;
  }

  /*@Pure*/
  public boolean is_symmetric() {

      return false;
  }

  public long func(long y, long x) {

      if ((x < arg2_bound[0]) || (x > arg2_bound[1])) {
        throw new ArithmeticException("arg2 (" + x + ") out of range "
                                       + arg2_bound[0] + ".." + arg2_bound[1]);
      }

    return ((y >>> x));
  }

  public InvariantStatus check_modified(long x, long y,
                                      long z, int count) {
    return (check_ordered(z, y, x, count));
  }

  public InvariantStatus add_modified(long x, long y,
                                      long z, int count) {
    if (Debug.logDetail()) {
      log("result=%s, arg1=%s, arg2=%s", z, y, x);
    }
    return (add_ordered(z, y, x, count));
  }

  /*@Pure*/
  public boolean isRshiftUnsigned() {
    return true;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    if (NIS.dkconfig_enabled && dkconfig_enabled) {
      return suppressions;
    } else {
      return null;
    }
  }

  /** definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(RshiftUnsignedLong_zyx.class, 3);

  // suppressor definitions (used below)
  private static NISuppressor result_eq_arg1 =
      new NISuppressor(2, 1, IntEqual.class);
  private static NISuppressor result_eq_arg2 =
      new NISuppressor(2, 0, IntEqual.class);
  private static NISuppressor arg1_eq_arg2 =
      new NISuppressor(1, 0, IntEqual.class);

  private static NISuppressor result_lt_arg1 =
      new NISuppressor(2, 1, IntLessThan.class);
  private static NISuppressor result_lt_arg2 =
      new NISuppressor(2, 0, IntLessThan.class);
  private static NISuppressor arg1_lt_arg2 =
      new NISuppressor(1, 0, IntLessThan.class);
  private static NISuppressor arg2_lt_arg1 =
      new NISuppressor(0, 1, IntLessThan.class);

  private static NISuppressor result_le_arg1 =
      new NISuppressor(2, 1, IntLessEqual.class);
  private static NISuppressor result_le_arg2 =
      new NISuppressor(2, 0, IntLessEqual.class);
  private static NISuppressor arg1_le_arg2 =
      new NISuppressor(1, 0, IntLessEqual.class);
  private static NISuppressor arg2_le_arg1 =
      new NISuppressor(0, 1, IntLessEqual.class);

  private static NISuppressor result_track0_arg1 =
      new NISuppressor(2, 1, NumericInt.ZeroTrack.class);
  private static NISuppressor result_track0_arg2 =
      new NISuppressor(2, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_arg2 =
      new NISuppressor(1, 0, NumericInt.ZeroTrack.class);
  private static NISuppressor arg1_track0_result =
      new NISuppressor(1, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_result =
      new NISuppressor(0, 2, NumericInt.ZeroTrack.class);
  private static NISuppressor arg2_track0_arg1 =
      new NISuppressor(0, 1, NumericInt.ZeroTrack.class);

  private static NISuppressor result_eq_1 =
      new NISuppressor(2, RangeInt.EqualOne.class);
  private static NISuppressor arg1_eq_1 =
      new NISuppressor(1, RangeInt.EqualOne.class);
  private static NISuppressor arg2_eq_1 =
      new NISuppressor(0, RangeInt.EqualOne.class);

  private static NISuppressor result_eq_0 =
      new NISuppressor(2,RangeInt.EqualZero.class);
  private static NISuppressor arg1_eq_0 =
      new NISuppressor(1, RangeInt.EqualZero.class);
  private static NISuppressor arg2_eq_0 =
      new NISuppressor(0, RangeInt.EqualZero.class);

  private static NISuppressor result_ne_0 =
      new NISuppressor(2, NonZero.class);
  private static NISuppressor arg1_ne_0 =
      new NISuppressor(1, NonZero.class);
  private static NISuppressor arg2_ne_0 =
      new NISuppressor(0, NonZero.class);

  private static NISuppressor result_ge_0 =
      new NISuppressor(2, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg1_ge_0 =
      new NISuppressor(1, RangeInt.GreaterEqualZero.class);
  private static NISuppressor arg2_ge_0 =
      new NISuppressor(0, RangeInt.GreaterEqualZero.class);

  private static NISuppressor result_ge_64 =
      new NISuppressor(2, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg1_ge_64 =
      new NISuppressor(1, RangeInt.GreaterEqual64.class);
  private static NISuppressor arg2_ge_64 =
      new NISuppressor(0, RangeInt.GreaterEqual64.class);

  private static NISuppressor result_boolean =
      new NISuppressor(2,RangeInt.BooleanVal.class);
  private static NISuppressor arg1_boolean =
      new NISuppressor(1, RangeInt.BooleanVal.class);
  private static NISuppressor arg2_boolean =
      new NISuppressor(0, RangeInt.BooleanVal.class);

  private static NISuppressor result_even =
      new NISuppressor(2, RangeInt.Even.class);
  private static NISuppressor arg1_even =
      new NISuppressor(1, RangeInt.Even.class);
  private static NISuppressor arg2_even =
      new NISuppressor(0, RangeInt.Even.class);

  private static NISuppressor result_power2 =
      new NISuppressor(2,RangeInt.PowerOfTwo.class);
  private static NISuppressor arg1_power2 =
      new NISuppressor(1, RangeInt.PowerOfTwo.class);
  private static NISuppressor arg2_power2 =
      new NISuppressor(0, RangeInt.PowerOfTwo.class);

  private static NISuppressor result_and0_arg1 =
      new NISuppressor(2, 1, NumericInt.BitwiseAndZero.class);
  private static NISuppressor result_and0_arg2 =
      new NISuppressor(2, 0, NumericInt.BitwiseAndZero.class);
  private static NISuppressor arg1_and0_arg2 =
      new NISuppressor(1, 0, NumericInt.BitwiseAndZero.class);

  // The arguments to bitwise subset are backwards from what one
  // might expect.  The second argument is a subset of the first
  // argument
  private static NISuppressor arg1_bw_subset_arg2 =
      new NISuppressor(0, 1, NumericInt.BitwiseSubset.class);
  private static NISuppressor arg2_bw_subset_arg1 =
      new NISuppressor(1, 0, NumericInt.BitwiseSubset.class);

  private static NISuppressor result_shift0_arg1 =
      new NISuppressor(2, 1, NumericInt.ShiftZero.class);
  private static NISuppressor result_shift0_arg2 =
      new NISuppressor(2, 0, NumericInt.ShiftZero.class);
  private static NISuppressor arg1_shift0_arg2 =
      new NISuppressor(1, 0, NumericInt.ShiftZero.class);

  private static NISuppressor arg2_divides_arg1 =
      new NISuppressor(1, 0, NumericInt.Divides.class);
  private static NISuppressor arg1_divides_arg2 =
      new NISuppressor(0, 1, NumericInt.Divides.class);

  private static NISuppressor arg2_valid_shift =
      new NISuppressor(0, RangeInt.Bound0_63.class);

    private static NISuppressionSet suppressions =
        new NISuppressionSet(
          new NISuppression[] {

            // (r == y) && (x == 0) ==> r = y >>> x
            new NISuppression(result_eq_arg1, arg2_eq_0, suppressee),

            // (r == 0) && (y == 0) && (x valid shift) ==> r = y >>> x
            // new NISuppression (result_eq_0, arg1_eq_0, arg2_valid_shift
            //                   ,suppressee),

            // (r == 0) && ((y >> x) == 0)
            new NISuppression(result_eq_0, arg1_shift0_arg2, suppressee),

            // (r == 0) && (x >= y) && (y >= 0) && (x valid shift)
            // This suppression really ought to have 2**x >= y, but we
            // don't have that suppression.  This still might catch a lot of these.
            // new NISuppression (result_eq_0, arg1_le_arg2, arg1_ge_0,
            //                   arg2_valid_shift, suppressee),
          });

  // Create a suppression factory for functionBinary

}

}
